<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>leejs&#39;s blog</title>
    <link>https://dl137584.github.io/</link>
    
    <atom:link href="https://dl137584.github.io/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description></description>
    <pubDate>Sat, 10 Jan 2026 10:31:39 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>[Android] LifecycleScope의 종류</title>
      <link>https://dl137584.github.io/2026/01/10/031-lifecyclescope-classification/</link>
      <guid>https://dl137584.github.io/2026/01/10/031-lifecyclescope-classification/</guid>
      <pubDate>Sat, 10 Jan 2026 09:33:14 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;&lt;img src=&quot;/2026/01/10/031-lifecyclescope-classification/031-lifecyclescope_table.png&quot; alt=&quot;image.png&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;1-Activity의-lifecycleS</description>
        
      
      
      
      <content:encoded><![CDATA[<p><img src="/2026/01/10/031-lifecyclescope-classification/031-lifecyclescope_table.png" alt="image.png"></p><h1 id="1-Activity의-lifecycleScope"><a href="#1-Activity의-lifecycleScope" class="headerlink" title="1. Activity의 lifecycleScope"></a>1. Activity의 lifecycleScope</h1><ul><li>Activity나 Fragment의 전체 생명주기를 따름</li><li><code>Lifecycle.State.DESTROYED</code>가 되면 자동으로 코루틴 취소</li></ul><p>따라서 아래 코드는 “3datastore=PATTERN” 로그만 찍힌다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onDestroy</span><span class="params">()</span></span> &#123;</span><br><span class="line">    DEBUG.d(<span class="string">&quot;leejs - onDestroy&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 실행 안됨: Destroy를 호출하기 전에 실행</span></span><br><span class="line">    lifecycleScope.launch &#123;</span><br><span class="line">        DEBUG.d(<span class="string">&quot;leejs - 1datastore=<span class="subst">$&#123;viewModel.getLockMethod()&#125;</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">super</span>.onDestroy()</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 실행 안 됨: Destroy된 상태기 때문.</span></span><br><span class="line">    lifecycleScope.launch &#123;</span><br><span class="line">        DEBUG.d(<span class="string">&quot;leejs - 2datastore=<span class="subst">$&#123;viewModel.getLockMethod()&#125;</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 실행됨: lifecycle과 관련 없는 코루틴에서 실행.</span></span><br><span class="line">    CoroutineScope(Dispatchers.Main).launch &#123;</span><br><span class="line">        DEBUG.d(<span class="string">&quot;leejs - 3datastore=<span class="subst">$&#123;viewModel.getLockMethod()&#125;</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 결과 //</span></span><br><span class="line"><span class="comment">// leejs - onDestroy</span></span><br><span class="line"><span class="comment">// leejs - 3datastore=PATTERN</span></span><br></pre></td></tr></table></figure><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-8868044834754772"     crossorigin="anonymous"></script><p><ins class="adsbygoogle"     style="display:block; text-align:center;"     data-ad-layout="in-article"     data-ad-format="fluid"     data-ad-client="ca-pub-8868044834754772"     data-ad-slot="1292114373"></ins></p><script>     (adsbygoogle = window.adsbygoogle || []).push({});</script><h1 id="2-Fragment의-viewLifecycleOwner-lifecycleScope"><a href="#2-Fragment의-viewLifecycleOwner-lifecycleScope" class="headerlink" title="2. Fragment의 viewLifecycleOwner.lifecycleScope"></a>2. Fragment의 viewLifecycleOwner.lifecycleScope</h1><p>Fragment는 백스택에 있을 때 <code>onDestroyView()</code>가 호출되지만 Fragment 자체는 살아있는 상태다. 따라서 Fragment에서 lifecycleScope를 쓰게 되는 경우 메모리 누수가 발생할 수 있다. 이때 사용하는 게 viewLifecycleOwner.lifecycleScope이며, onViewCreated(뷰가 생성완료 되었을 때)에서 launch한다.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class TestFragment : Fragment() &#123;</span><br><span class="line">    override onViewCreated(...) &#123;</span><br><span class="line">        viewLifecycleOwner.lifecycleScope.launch &#123;</span><br><span class="line">            // Fragment의 lifecycle을 따르는 (Fragment의 onCreate에서 호출하는) lifecycleScope.launch와는 다르게,</span><br><span class="line">            // Fragment의 View의 lifecycle을 따르기 때문에 &quot;Fragment가 DESTROYED되기 전, 그리고 Fragment의 View가 DESTROYED된 후&quot;의 메모리 누수를 방지할 수 있다.</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="3-ViewModel의-viewModelScope"><a href="#3-ViewModel의-viewModelScope" class="headerlink" title="3. ViewModel의 viewModelScope"></a>3. ViewModel의 viewModelScope</h1><ul><li>ViewModel이 clear될 때만 취소됨</li><li><code>Dispatchers.Main.immediate</code> 사용</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class TestViewModel : ViewModel() &#123;</span><br><span class="line">    init &#123;</span><br><span class="line">        viewModelScope.launch &#123;</span><br><span class="line">            // 해당 ViewModel의 lifecycle을 따르기 때문에 viewModel이 살아있는 동안에만(Cleared되기 전까지) 여기의 코루틴을 실행하도록 해준다.</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="4-앱의-ProcessLifecycleOwner-get-lifecycleScope"><a href="#4-앱의-ProcessLifecycleOwner-get-lifecycleScope" class="headerlink" title="4. 앱의 ProcessLifecycleOwner.get().lifecycleScope"></a>4. 앱의 ProcessLifecycleOwner.get().lifecycleScope</h1><ul><li>Application 레벨의 lifecycle을 따르며, 앱 프로세스가 종료될 때 취소된다.</li><li>앱 전체의 포그라운드/백그라운드 상태를 감지할 수 있다.</li><li>앱 레벨 데이터 동기화에 사용한다.</li></ul><h3 id="사용처"><a href="#사용처" class="headerlink" title="사용처"></a>사용처</h3><ul><li>Application을 상속받는 클래스 또는 위젯 관련 로직에서 사용한다.</li></ul><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-8868044834754772"     crossorigin="anonymous"></script><p><ins class="adsbygoogle"     style="display:block; text-align:center;"     data-ad-layout="in-article"     data-ad-format="fluid"     data-ad-client="ca-pub-8868044834754772"     data-ad-slot="1292114373"></ins></p><script>     (adsbygoogle = window.adsbygoogle || []).push({});</script>]]></content:encoded>
      
      
      <category domain="https://dl137584.github.io/categories/Android/">Android</category>
      
      
      
      <comments>https://dl137584.github.io/2026/01/10/031-lifecyclescope-classification/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[Android] lifecycleScope vs viewLifecycleOwner.lifecycleScope</title>
      <link>https://dl137584.github.io/2025/12/16/032-lifecycleScope-vs-viewLifecycleOwner-lifecycleScope/</link>
      <guid>https://dl137584.github.io/2025/12/16/032-lifecycleScope-vs-viewLifecycleOwner-lifecycleScope/</guid>
      <pubDate>Tue, 16 Dec 2025 10:17:34 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;Lifecycle&quot;&gt;&lt;a href=&quot;#Lifecycle&quot; class=&quot;headerlink&quot; title=&quot;Lifecycle&quot;&gt;&lt;/a&gt;Lifecycle&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;/2025/12/16/032-lifecycleScope-v</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="Lifecycle"><a href="#Lifecycle" class="headerlink" title="Lifecycle"></a>Lifecycle</h1><p><img src="/2025/12/16/032-lifecycleScope-vs-viewLifecycleOwner-lifecycleScope/032-fragment_lifecycle.png" alt="Fragment의 Lifecycle"></p><p>Fragment는 Activity의 lifecycle과 다르게 Fragment의 lifecycle과 Fragment의 View의 lifecycle, 두 개가 있다.</p><h1 id="lifecycleScope-vs-viewLifecycleOwner-lifecycleScope"><a href="#lifecycleScope-vs-viewLifecycleOwner-lifecycleScope" class="headerlink" title="lifecycleScope vs viewLifecycleOwner.lifecycleScope"></a>lifecycleScope vs viewLifecycleOwner.lifecycleScope</h1><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestActivity</span> : <span class="type">AppCompatActivity</span></span>() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        </span><br><span class="line">        lifecycleScope.launch &#123;  <span class="comment">// Activity가 destroy될 때까지 살아있다.</span></span><br><span class="line">            repeatOnLifecycle(Lifecycle.State.STARTED) &#123;</span><br><span class="line">                viewModel.inputEventSharedFlow.collect &#123; event -&gt;</span><br><span class="line">                    <span class="comment">// Activity가 STARTED 이상일 때만 실행된다.</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-8868044834754772"     crossorigin="anonymous"></script><p><ins class="adsbygoogle"     style="display:block; text-align:center;"     data-ad-layout="in-article"     data-ad-format="fluid"     data-ad-client="ca-pub-8868044834754772"     data-ad-slot="1292114373"></ins></p><script>     (adsbygoogle = window.adsbygoogle || []).push({});</script><p><strong>생명주기:</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">onCreate() ──► lifecycleScope 시작</span><br><span class="line">    │</span><br><span class="line">    ├─ coroutine <span class="number">1</span> (collect)</span><br><span class="line">    │</span><br><span class="line">onDestroy() ──► lifecycleScope 자동 취소</span><br></pre></td></tr></table></figure><p><strong>생명주기 (백스택 시나리오):</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">onCreateView() ──► View 생성</span><br><span class="line">    │</span><br><span class="line">onViewCreated() ──► viewLifecycleOwner.lifecycleScope 시작</span><br><span class="line">    │                   │</span><br><span class="line">    │                   ├─ coroutine <span class="number">1</span> (collect openEvent)</span><br><span class="line">    │                   ├─ coroutine <span class="number">2</span> (collect toastEvent)</span><br><span class="line">    │                   └─ coroutine <span class="number">3</span> (collect alertEvent)</span><br><span class="line">    │</span><br><span class="line">[다른 Fragment로 이동]</span><br><span class="line">    │</span><br><span class="line">onDestroyView() ──► View 파괴</span><br><span class="line">                    viewLifecycleOwner.lifecycleScope내 모든 코루틴이 자동 취소된다.</span><br><span class="line">                    </span><br><span class="line">(Fragment는 메모리(백스택)에 남아있는 상태)</span><br><span class="line">    </span><br><span class="line">[뒤로가기]</span><br><span class="line">    │</span><br><span class="line">onCreateView() ──► View 다시 생성</span><br><span class="line">    │</span><br><span class="line">onViewCreated() ──► 새로운 viewLifecycleOwner.lifecycleScope에서 새로운 코루틴들이 시작한다.</span><br></pre></td></tr></table></figure><h1 id="잘못-사용한-예"><a href="#잘못-사용한-예" class="headerlink" title="잘못 사용한 예"></a>잘못 사용한 예</h1><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyFragment</span> : <span class="type">Fragment</span></span>() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onViewCreated</span><span class="params">(view: <span class="type">View</span>, savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        lifecycleScope.launch &#123;  <span class="comment">// Fragment lifecycle</span></span><br><span class="line">            viewModel.events.collect &#123;</span><br><span class="line">                <span class="comment">// binding.textView 접근 → onDestroyView 후에도 실행됨!</span></span><br><span class="line">                binding.textView.text = <span class="string">&quot;...&quot;</span>  <span class="comment">// 앱 크래시 가능성이 있다.</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">onCreateView() ──► View 생성</span><br><span class="line">    │</span><br><span class="line">    ├─ lifecycleScope.launch (Fragment의 lifecycle)</span><br><span class="line">    │      └─ collect 시작</span><br><span class="line">    │</span><br><span class="line">onDestroyView() ──► View 파괴 (binding.textView 사라짐)</span><br><span class="line">    │</span><br><span class="line">    │  (하지만 collect는 계속 실행 중인 상태)</span><br><span class="line">    │</span><br><span class="line">    └─ viewModel.events.emit() 발생</span><br><span class="line">         └─ binding.textView.text = <span class="string">&quot;...&quot;</span> <span class="comment">// 앱 크래시 가능성이 있다.</span></span><br><span class="line">         </span><br><span class="line">onDestroy() ──► 여기서야 lifecycleScope 내 코루틴들이 취소된다.</span><br></pre></td></tr></table></figure><h1 id="repeatOnLifecycle-vs-viewLifecycleOwner-repeatOnLifecycle"><a href="#repeatOnLifecycle-vs-viewLifecycleOwner-repeatOnLifecycle" class="headerlink" title="repeatOnLifecycle vs viewLifecycleOwner.repeatOnLifecycle"></a>repeatOnLifecycle vs viewLifecycleOwner.repeatOnLifecycle</h1><p><code>repeatOnLifecycle</code>과 <code>viewLifecycleOwner.repeatOnLifecycle</code>도 동작 차이가 있다.</p><p>Fragment에서 사용했을 때 <code>viewLifecycleOwner.lifecycleScope</code>에서 launch하더라도 <code>repeatOnLifecycle</code>은 <code>this.repeatOnLifecycle</code>이기 때문에 Fragment의 View 라이프사이클이 아닌 Fragment 라이프사이클을 따르기 때문에 메모리 누수 가능성이 있다.</p><p>따라서 아래와 같이 사용해야 한다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyFragment</span> : <span class="type">Fragment</span></span>() &#123;</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onViewCreated</span><span class="params">(view: <span class="type">View</span>, savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">    viewLifecycleOwner.lifecycleScope.launch &#123;</span><br><span class="line">      viewLifecycleOwner.repeatOnLifecycle(Lifecycle.State.STARTED) &#123;</span><br><span class="line">        viewModel.events.collect &#123;</span><br><span class="line">          binding.textView.text = <span class="string">&quot;...&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-8868044834754772"     crossorigin="anonymous"></script><p><ins class="adsbygoogle"     style="display:block; text-align:center;"     data-ad-layout="in-article"     data-ad-format="fluid"     data-ad-client="ca-pub-8868044834754772"     data-ad-slot="1292114373"></ins></p><script>     (adsbygoogle = window.adsbygoogle || []).push({});</script>]]></content:encoded>
      
      
      <category domain="https://dl137584.github.io/categories/Android/">Android</category>
      
      
      
      <comments>https://dl137584.github.io/2025/12/16/032-lifecycleScope-vs-viewLifecycleOwner-lifecycleScope/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[Android] Android 15 대응 - EdgeToEdge: 4. 디스플레이 컷아웃</title>
      <link>https://dl137584.github.io/2025/06/25/036-android15-edge-to-edge-03-display-cutout/</link>
      <guid>https://dl137584.github.io/2025/06/25/036-android15-edge-to-edge-03-display-cutout/</guid>
      <pubDate>Wed, 25 Jun 2025 11:02:57 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;컷아웃&quot;&gt;&lt;a href=&quot;#컷아웃&quot; class=&quot;headerlink&quot; title=&quot;컷아웃&quot;&gt;&lt;/a&gt;&lt;strong&gt;컷아웃&lt;/strong&gt;&lt;/h1&gt;&lt;p&gt;⚠️ 픽셀 기기에서는 컷아웃이 제대로 넘어오지 않는 것 같음. 카메라가 있는데도 컷아웃이</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="컷아웃"><a href="#컷아웃" class="headerlink" title="컷아웃"></a><strong>컷아웃</strong></h1><p>⚠️ 픽셀 기기에서는 컷아웃이 제대로 넘어오지 않는 것 같음. 카메라가 있는데도 컷아웃이 0으로 내려옴.</p><p>Android 9 이상을 실행하는 기기에서는 일관성, 앱 호환성을 보장하기 위해 다음과 같은 컷아웃 동작을 보장해야 한다.</p><ul><li>단일 가장자리에 컷아웃을 최대 1개 포함할 수 있다.</li><li>기기에 컷아웃이 3개 이상 있을 수 없다.</li><li>기기 양 쪽의 긴 가장자리(세로 모드 시 좌우)에는 컷아웃이 있을 수 없다.</li><li>특수 플래그를 설정하지 않은 세로 방향에서는 상태 표시줄이 적어도 컷아웃 높이까지 확장되어야 한다.</li><li>기본적으로 전체 화면 또는 가로 방향에서는 전체 컷아웃 영역이 레터박스 처리되어야 한다.</li></ul><p>따라서, 다음과 같은 컷아웃 유형을 지원한다.</p><ul><li>상단 중앙: 상단 가장자리 중앙의 컷아웃</li><li>상단 비중앙: 컷아웃이 모서리에 위치하거나 중앙에서 약간 벗어날 수 있다.</li><li>하단: 하단의 컷아웃</li><li>이중: 상단의 컷아웃 1개, 하단의 컷아웃 1개</li></ul><p>콘텐츠가 컷아웃 영역과 겹치지 않게 하려면 콘텐츠가 스테이터스 바 및 네비게이션 바와 겹치지 않게 하려면 컷아웃 영역에서 Inset을 부여하여 처리하면 해결이 가능하다.</p><p>컷아웃 영역으로 렌더링하는 경우 <code>WindowInsets#getDisplayCutout()</code> 함수를 사용하여 각 컷아웃의 Safe Inset Area와 Safe Area가 포함된 DisplayCutout 객체를 탐색할 수 있다. 따라서 이러한 API를 사용해 콘텐츠가 컷아웃과 겹치는지 여부를 판단하여 위치를 조정할 수 있다.</p><p>아래 세 가지 옵션은 Android 15(API 35)에서 deprecated된 <a href="https://developer.android.com/reference/android/view/View#SYSTEM_UI_FLAG_FULLSCREEN"><code>View.SYSTEM_UI_FLAG_FULLSCREEN</code></a> or <a href="https://developer.android.com/reference/android/view/View#SYSTEM_UI_FLAG_HIDE_NAVIGATION"><code>View.SYSTEM_UI_FLAG_HIDE_NAVIGATION</code></a>를 사용할 경우 유효한 옵션이다. </p><ul><li><a href="https://developer.android.com/reference/android/view/WindowManager.LayoutParams#LAYOUT_IN_DISPLAY_CUTOUT_MODE_DEFAULT">LAYOUT_IN_DISPLAY_CUTOUT_MODE_DEFAULT</a>: 기본 동작이며, 세로 모드에서는 콘텐츠가 컷아웃 영역으로 렌더링되고 가로 모드에서는 콘텐츠가 레터박스 처리된다.</li><li><a href="https://developer.android.com/reference/android/view/WindowManager.LayoutParams#LAYOUT_IN_DISPLAY_CUTOUT_MODE_SHORT_EDGES">LAYOUT_IN_DISPLAY_CUTOUT_MODE_SHORT_EDGES</a>: 세로 모드와 가로 모드 모두에서 콘텐츠가 컷아웃 영역으로 렌더링된다.</li><li><a href="https://developer.android.com/reference/android/view/WindowManager.LayoutParams#LAYOUT_IN_DISPLAY_CUTOUT_MODE_NEVER">LAYOUT_IN_DISPLAY_CUTOUT_MODE_NEVER</a>: 콘텐츠가 컷아웃 영역으로 렌더링되지 않는다.</li></ul><p>Android 15(API 35)부터는 <code>WindowInsets#getDisplayCutout()</code> 함수를 사용하면 된다.</p><p>컷아웃 영역은 카메라와 같은 하드웨어가 디스플레이를 가리는 경우 생긴다.<br>관련 예로, 폰에서 카메라 영역(컷아웃 영역) 때문에 상단 인셋을 적용했는데, 이 코드를 컷아웃 영역이 없는 태블릿에서 실행하니 컷아웃 영역이 없는데도 상단 인셋이 적용되어 버린다.<br>따라서 아래와 같이 컷아웃을 사용해 패딩을 설정하면 컷아웃에 따른 인셋을 설정할 수 있게 된다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ViewCompat.setOnApplyWindowInsetsListener(findViewById(android.R.id.content)) &#123; view, insets -&gt;</span><br><span class="line">  insets.displayCutout?.let &#123;</span><br><span class="line">    view.setPadding(<span class="number">0</span>, it.safeInsetTop, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  insets</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>관련글<ul><li><a href="https://dl137584.github.io/2025/06/25/033-android15-edge-to-edge-01-inset/">[Android] Android 15 대응 - EdgeToEdge: 1. Inset 적용</a></li><li><a href="https://dl137584.github.io/2025/06/25/034-android15-edge-to-edge-02-statusbar-and-navigationbar/">[Android] Android 15 대응 - EdgeToEdge: 2. StatusBar 및 NavigationBar</a></li><li><a href="https://dl137584.github.io/2025/06/25/035-android15-edge-to-edge-03-windowinsetscontroller/">[Android] Android 15 대응 - EdgeToEdge: 3. WindowInsetsController</a></li></ul></li></ul><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-8868044834754772"     crossorigin="anonymous"></script><p><ins class="adsbygoogle"     style="display:block; text-align:center;"     data-ad-layout="in-article"     data-ad-format="fluid"     data-ad-client="ca-pub-8868044834754772"     data-ad-slot="1292114373"></ins></p><script>     (adsbygoogle = window.adsbygoogle || []).push({});</script>]]></content:encoded>
      
      
      <category domain="https://dl137584.github.io/categories/Android/">Android</category>
      
      
      
      <comments>https://dl137584.github.io/2025/06/25/036-android15-edge-to-edge-03-display-cutout/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[Android] Android 15 대응 - EdgeToEdge: 3. WindowInsetsController</title>
      <link>https://dl137584.github.io/2025/06/25/035-android15-edge-to-edge-03-windowinsetscontroller/</link>
      <guid>https://dl137584.github.io/2025/06/25/035-android15-edge-to-edge-03-windowinsetscontroller/</guid>
      <pubDate>Wed, 25 Jun 2025 10:56:47 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;WindowInsetsController&quot;&gt;&lt;a href=&quot;#WindowInsetsController&quot; class=&quot;headerlink&quot; title=&quot;WindowInsetsController&quot;&gt;&lt;/a&gt;&lt;strong&gt;WindowInsets</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="WindowInsetsController"><a href="#WindowInsetsController" class="headerlink" title="WindowInsetsController"></a><strong>WindowInsetsController</strong></h1><p>setSystemUiVisibility가 deprecated되어 Android 15(API 35)부터는 WindowInsetsController 인터페이스를 사용해야 한다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Inset 생성 시 Window를 제어하기 위한 인터페이스</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">WindowInsetsController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 어두운 백그라운드, 밝은 포그라운드 색상을 가진 불투명한 상태표시줄을 만듦</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@hide</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">int</span> APPEARANCE_OPAQUE_STATUS_BARS = <span class="number">1</span>;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 어두운 백그라운드, 밝은 포그라운드 색상을 가진 불투명한 네비게이션 바를 만듦</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@hide</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">int</span> APPEARANCE_OPAQUE_NAVIGATION_BARS = <span class="number">1</span> &lt;&lt; <span class="number">1</span>;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 상태바 레이아웃이 변경됨 없이 덜 두드러지게 상태표시줄의 아이템을 적용함</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@hide</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">int</span> APPEARANCE_LOW_PROFILE_BARS = <span class="number">1</span> &lt;&lt; <span class="number">2</span>;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 밝은 상태표시줄로 변경하여 상태바 내 아이템들의 시연성을 뚜렷하게 함</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">int</span> APPEARANCE_LIGHT_STATUS_BARS = <span class="number">1</span> &lt;&lt; <span class="number">3</span>;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 밝은 네비게이션 바로 변경하여 상태바 내 아이템들의 시연성을 뚜렷하게 함</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">int</span> APPEARANCE_LIGHT_NAVIGATION_BARS = <span class="number">1</span> &lt;&lt; <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>여기의 플래그를 보면 기존에 제공하던 아래 플래그와 전혀 다른 것을 알 수 있다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">decorView.systemUiVisibility = </span><br><span class="line">    <span class="comment">// 아래 SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION 와 중복?</span></span><br><span class="line">    View.SYSTEM_UI_FLAG_HIDE_NAVIGATION or </span><br><span class="line">    View.SYSTEM_UI_FLAG_FULLSCREEN or</span><br><span class="line">    <span class="comment">// 가장 자리 스와이프 시 발동, 다만 앱에서는 인지 못함</span></span><br><span class="line">    View.SYSTEM_UI_FLAG_IMMERSIVE_STICKY or</span><br><span class="line">    <span class="comment">// 하단 네비게이션 바 숨기기</span></span><br><span class="line">    View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION </span><br></pre></td></tr></table></figure><p>여러 SDK 버전을 커버하는 WindowCompat 클래스에는 다음과 같이 분기처리가 되어 있다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Window의 Inset을 적용하는 경우 //</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setDecorFitsSystemWindows</span><span class="params">(<span class="meta">@NonNull</span> Window window,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">final</span> <span class="keyword">boolean</span> decorFitsSystemWindows)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= <span class="number">30</span>) &#123;</span><br><span class="line">        Api30Impl.setDecorFitsSystemWindows(window, decorFitsSystemWindows);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Api16Impl.setDecorFitsSystemWindows(window, decorFitsSystemWindows);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-8868044834754772"     crossorigin="anonymous"></script><p><ins class="adsbygoogle"     style="display:block; text-align:center;"     data-ad-layout="in-article"     data-ad-format="fluid"     data-ad-client="ca-pub-8868044834754772"     data-ad-slot="1292114373"></ins></p><script>     (adsbygoogle = window.adsbygoogle || []).push({});</script><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Api16Impl</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Api16Impl</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// This class is not instantiable.</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setDecorFitsSystemWindows</span><span class="params">(<span class="meta">@NonNull</span> Window window,</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="keyword">final</span> <span class="keyword">boolean</span> decorFitsSystemWindows)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> decorFitsFlags = View.SYSTEM_UI_FLAG_LAYOUT_STABLE</span><br><span class="line">                | View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION</span><br><span class="line">                | View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN;</span><br><span class="line">        <span class="keyword">final</span> View decorView = window.getDecorView();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> sysUiVis = decorView.getSystemUiVisibility();</span><br><span class="line">        decorView.setSystemUiVisibility(decorFitsSystemWindows</span><br><span class="line">                ? sysUiVis &amp; ~decorFitsFlags</span><br><span class="line">                : sysUiVis | decorFitsFlags);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequiresApi(30)</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Api30Impl</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Api30Impl</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// This class is not instantiable.</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@DoNotInline</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setDecorFitsSystemWindows</span><span class="params">(<span class="meta">@NonNull</span> Window window,</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="keyword">final</span> <span class="keyword">boolean</span> decorFitsSystemWindows)</span> </span>&#123;</span><br><span class="line">        window.setDecorFitsSystemWindows(decorFitsSystemWindows);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이와 같이 Android 15(API 35) 이상에서는 Window의 Inset을 부분적으로 적용하는 경우, Window#setDecorFitsSystemWindows를 사용하면 된다.</p><p><a href="https://developer.android.com/develop/ui/views/layout/edge-to-edge#handle-overlaps">인셋의 종류</a>는 다음 세 가지이다.</p><ul><li>System bars insets</li><li>Display cutout insets</li><li>System gesture insets</li></ul><h1 id="SystemBar-숨김-표시"><a href="#SystemBar-숨김-표시" class="headerlink" title="SystemBar 숨김/표시"></a><strong>SystemBar 숨김/표시</strong></h1><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> windowInsetsController = WindowCompat.getInsetsController(window, window.decorView)</span><br><span class="line">windowInsetsController.show(WindowInsets.Type.systemBars())</span><br></pre></td></tr></table></figure><p>이를 사용해 시스템바를 표시하거나(show) 숨길(hide) 수 있다.</p><h1 id="Window-Inset-제어를-통한-FullScreen-구현"><a href="#Window-Inset-제어를-통한-FullScreen-구현" class="headerlink" title="Window Inset 제어를 통한 FullScreen 구현"></a><strong>Window Inset 제어를 통한 FullScreen 구현</strong></h1><ul><li>[<a href="https://developer.android.com/develop/ui/views/layout/immersive?hl=ko">AndroidDev</a>] 몰입형 모드를 위한 시스템 표시줄 숨기기</li></ul><p>기존에 decorView에 systemUiVisibility 옵션을 주었던 것과는 달리 안드로이드 11(API 30)에 대응하기 위해서는 InsetsController를 이용해야 한다.</p><p>Android 11에서 기존 옵션에 매칭되는 사항은 다음과 같다.</p><ul><li>WindowInsetsController.BEHAVIOR_SHOW_BARS_BY_TOUCH: lean back</li><li>WindowInsetsController.BEHAVIOR_SHOW_BARS_BY_SWIPE: immersive</li><li>WindowInsetsController.BEHAVIOR_SHOW_TRANSIENT_BARS_BY_SWIPE: sticky immersive  최상단에서 쓸어내리거나 최하단에서 쓸어올리면 잠깐 나타나고 뷰에서 영역을 차지하지 않는다.</li></ul><p>BEHAVIOR_SHOW_TRANSIENT_BARS_BY_SWIPE를 적용한 예시 코드는 다음과 같다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">WindowCompat.getInsetsController(<span class="keyword">this</span>, <span class="keyword">this</span>.decorView).apply &#123;</span><br><span class="line">  hide(WindowInsetsCompat.Type.navigationBars())</span><br><span class="line">  systemBarsBehavior = WindowInsetsControllerCompat.BEHAVIOR_SHOW_TRANSIENT_BARS_BY_SWIPE</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>관련글<ul><li><a href="https://dl137584.github.io/2025/06/25/033-android15-edge-to-edge-01-inset/">[Android] Android 15 대응 - EdgeToEdge: 1. Inset 적용</a></li><li><a href="https://dl137584.github.io/2025/06/25/034-android15-edge-to-edge-02-statusbar-and-navigationbar/">[Android] Android 15 대응 - EdgeToEdge: 2. StatusBar 및 NavigationBar</a></li><li><a href="https://dl137584.github.io/2025/06/25/036-android15-edge-to-edge-03-display-cutout/">[Android] Android 15 대응 - EdgeToEdge: 4. 디스플레이 컷아웃</a></li></ul></li></ul><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-8868044834754772"     crossorigin="anonymous"></script><p><ins class="adsbygoogle"     style="display:block; text-align:center;"     data-ad-layout="in-article"     data-ad-format="fluid"     data-ad-client="ca-pub-8868044834754772"     data-ad-slot="1292114373"></ins></p><script>     (adsbygoogle = window.adsbygoogle || []).push({});</script>]]></content:encoded>
      
      
      <category domain="https://dl137584.github.io/categories/Android/">Android</category>
      
      
      
      <comments>https://dl137584.github.io/2025/06/25/035-android15-edge-to-edge-03-windowinsetscontroller/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[Android] Android 15 대응 - EdgeToEdge: 2. StatusBar 및 NavigationBar</title>
      <link>https://dl137584.github.io/2025/06/25/034-android15-edge-to-edge-02-statusbar-and-navigationbar/</link>
      <guid>https://dl137584.github.io/2025/06/25/034-android15-edge-to-edge-02-statusbar-and-navigationbar/</guid>
      <pubDate>Wed, 25 Jun 2025 10:47:24 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;배경색&quot;&gt;&lt;a href=&quot;#배경색&quot; class=&quot;headerlink&quot; title=&quot;배경색&quot;&gt;&lt;/a&gt;&lt;strong&gt;배경색&lt;/strong&gt;&lt;/h1&gt;&lt;p&gt;statusBar의 배경색을 지정할 수 있는 window.statusBarColor는 A</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="배경색"><a href="#배경색" class="headerlink" title="배경색"></a><strong>배경색</strong></h1><p>statusBar의 배경색을 지정할 수 있는 window.statusBarColor는 Android 15(API 35)에서 지원 종료되었다.</p><blockquote><p>If the app targets VANILLA_ICE_CREAM or above, the color will be transparent and cannot be changed. - Window#setStatusBarColor 주석</p></blockquote><p>VANILLA_ICE_CREAM 이상을 타겟팅한다면 색상은 투명이고 이 값을 사용할 수 없다고 가이드되어 있다.</p><p>따라서 status bar와 navigation bar 영역의 색상을 바꾸려면 setOnApplyWindowInsetsListener에 넘겨주는 findViewById(android.R.id.content)의 배경색을 바꿔야한다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">ViewCompat.setOnApplyWindowInsetsListener(</span><br><span class="line">  findViewById(android.R.id.content)</span><br><span class="line">) &#123; view, insets -&gt;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> systemBars = insets.getInsets(WindowInsetsCompat.Type.systemBars())</span><br><span class="line">  view.setPadding(</span><br><span class="line">    systemBars.left,</span><br><span class="line">    systemBars.top,</span><br><span class="line">    systemBars.right,</span><br><span class="line">    systemBars.bottom</span><br><span class="line">  )</span><br><span class="line">  </span><br><span class="line">  view.setBackgroundColor(</span><br><span class="line">    ContextCompat.getColor(view.context, R.color.white)</span><br><span class="line">  )</span><br><span class="line">  </span><br><span class="line">  insets</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이는 뷰의 배경색이기 때문에 padding을 설정해야 보이게 된다.</p><p>또한 status bar와 navigation bar의 색상을 다르게 하려면 아래 코드만으로는 안되고, 또 다른 조치를 취해줘야할 것으로 보인다.</p><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-8868044834754772"     crossorigin="anonymous"></script><p><ins class="adsbygoogle"     style="display:block; text-align:center;"     data-ad-layout="in-article"     data-ad-format="fluid"     data-ad-client="ca-pub-8868044834754772"     data-ad-slot="1292114373"></ins></p><script>     (adsbygoogle = window.adsbygoogle || []).push({});</script><p>statusBar는 위 코드와 같이 지정하고, navigationBar는 Activity의 최상위 뷰의 background에 컬러값 옵션과 paddingBottom을 설정함으로써 statusBar와 navigationBar의 색상을 다르게 처리하였다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">    window.setupWindowInsetsClassroom()</span><br><span class="line">    ViewCompat.setOnApplyWindowInsetsListener(window.findViewById(android.R.id.content)) &#123; view, insets -&gt;</span><br><span class="line">        <span class="keyword">val</span> systemBars = insets.getInsets(WindowInsetsCompat.Type.systemBars())</span><br><span class="line">    view.setBackgroundColor(ContextCompat.getColor(view.context, R.color.common_blue_color))</span><br><span class="line">        view.setPadding(<span class="number">0</span>, systemBars.top, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">        binding.slidingPanelLayout.setPadding(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, systemBars.bottom)</span><br><span class="line">        insets</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="아이콘-색상"><a href="#아이콘-색상" class="headerlink" title="아이콘 색상"></a><strong>아이콘 색상</strong></h1><p>Android 15(API 35)에서는 다크모드에서의 흰색과 라이트 모드에서의 회색으로만 설정할 수 있다.</p><p>이를 설정하기 위해서는 아래 두 가지 setter를 사용한다.</p><ul><li>InsetsController#isAppearanceLightStatusBars(boolean)</li><li>InsetsController#isAppearanceLightNavigationBars(boolean)</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">WindowCompat.getInsetsController(<span class="keyword">this</span>, <span class="keyword">this</span>.decorView).apply &#123;</span><br><span class="line">  <span class="comment">// 배경이 밝으니 스테이터스 바의 아이콘 색상을 회색으로 설정한다. //</span></span><br><span class="line">  isAppearanceLightStatusBars = <span class="literal">true</span></span><br><span class="line">  <span class="comment">// 배경이 밝으니 네비게이션 바의 아이콘 색상을 회색으로 설정한다. //</span></span><br><span class="line">  isAppearanceLightNavigationBars = <span class="literal">true</span></span><br><span class="line">  <span class="comment">// 3버튼 네비 바의 배경이 완전 투명 //</span></span><br><span class="line">  isNavigationBarContrastEnforced = <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>InsetsController에 관해서는 아래에서 설명한다.</p><h1 id="제스처-네비게이션-바"><a href="#제스처-네비게이션-바" class="headerlink" title="제스처 네비게이션 바"></a><strong>제스처 네비게이션 바</strong></h1><p>⚠️ 픽셀 기기에서는 제스처 네비게이션 바의 색상이 제제대로 처리되지 않는 것 같음. 흰배경이 뒤에 있는데도 흰색으로 설정되어있음.</p><p>제스처 네비게이션의 바 색상은 흰색↔회색으로 변하는데, 이는 아래 인용과 같이 시스템에서 알아서 변경해준다.</p><blockquote><p>동작 탐색 모드: 시스템은 시스템 표시줄의 콘텐츠가 뒤에 있는 콘텐츠를 기반으로 색상을 변경하는 동적 색상 조정을 적용한다. (<a href="https://developer.android.com/develop/ui/views/layout/edge-to-edge-manually?hl=ko#change-color">시스템 표시줄 색상 변경하기</a> 영상 참고)</p></blockquote><ul><li>관련글<ul><li><a href="https://dl137584.github.io/2025/06/25/033-android15-edge-to-edge-01-inset/">[Android] Android 15 대응 - EdgeToEdge: 1. Inset 적용</a></li><li><a href="https://dl137584.github.io/2025/06/25/035-android15-edge-to-edge-03-windowinsetscontroller/">[Android] Android 15 대응 - EdgeToEdge: 3. WindowInsetsController</a></li><li><a href="https://dl137584.github.io/2025/06/25/036-android15-edge-to-edge-03-display-cutout/">[Android] Android 15 대응 - EdgeToEdge: 4. 디스플레이 컷아웃</a></li></ul></li></ul><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-8868044834754772"     crossorigin="anonymous"></script><p><ins class="adsbygoogle"     style="display:block; text-align:center;"     data-ad-layout="in-article"     data-ad-format="fluid"     data-ad-client="ca-pub-8868044834754772"     data-ad-slot="1292114373"></ins></p><script>     (adsbygoogle = window.adsbygoogle || []).push({});</script>]]></content:encoded>
      
      
      <category domain="https://dl137584.github.io/categories/Android/">Android</category>
      
      
      
      <comments>https://dl137584.github.io/2025/06/25/034-android15-edge-to-edge-02-statusbar-and-navigationbar/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[Android] Android 15 대응 - EdgeToEdge: 1. Inset 적용</title>
      <link>https://dl137584.github.io/2025/06/25/033-android15-edge-to-edge-01-inset/</link>
      <guid>https://dl137584.github.io/2025/06/25/033-android15-edge-to-edge-01-inset/</guid>
      <pubDate>Wed, 25 Jun 2025 10:32:22 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;TL-DR&quot;&gt;&lt;a href=&quot;#TL-DR&quot; class=&quot;headerlink&quot; title=&quot;TL; DR&quot;&gt;&lt;/a&gt;&lt;strong&gt;TL; DR&lt;/strong&gt;&lt;/h1&gt;&lt;figure class=&quot;highlight kotlin&quot;&gt;&lt;table&gt;&lt;t</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="TL-DR"><a href="#TL-DR" class="headerlink" title="TL; DR"></a><strong>TL; DR</strong></h1><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> android.view.View</span><br><span class="line"><span class="keyword">import</span> android.view.Window</span><br><span class="line"><span class="keyword">import</span> androidx.core.view.ViewCompat</span><br><span class="line"><span class="keyword">import</span> androidx.core.view.WindowCompat</span><br><span class="line"><span class="keyword">import</span> androidx.core.view.WindowInsetsCompat</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * EdgeToEdge(API 30부터 지원) 적용에 따른 인셋을 적용한다.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> Window.<span class="title">setupWindowInsets</span><span class="params">()</span></span> &#123;</span><br><span class="line">    WindowCompat.getInsetsController(<span class="keyword">this</span>, <span class="keyword">this</span>.decorView).apply &#123;</span><br><span class="line">        isAppearanceLightStatusBars = <span class="literal">true</span></span><br><span class="line">        isAppearanceLightNavigationBars = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ViewCompat.setOnApplyWindowInsetsListener(findViewById(android.R.id.content)) &#123; view, insets -&gt;</span><br><span class="line">        <span class="keyword">val</span> systemBars = insets.getInsets(WindowInsetsCompat.Type.systemBars())</span><br><span class="line">        view.setPadding(systemBars.left, systemBars.top, systemBars.right, systemBars.bottom)</span><br><span class="line">        insets</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * EdgeToEdge(API 30부터 지원) 적용에 따른 인셋을 적용한다.</span></span><br><span class="line"><span class="comment"> * 추가로, 키보드가 올라올 때 (IME 인셋이 있을 때) 버튼을 이동시킨다.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> viewForKeyboard 키보드가 올라올 때 이동시킬 View</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> Window.<span class="title">setupWindowInsetsKeyboard</span><span class="params">(viewForKeyboard: <span class="type">View</span>)</span></span> &#123;</span><br><span class="line">    WindowCompat.getInsetsController(<span class="keyword">this</span>, <span class="keyword">this</span>.decorView).apply &#123;</span><br><span class="line">        isAppearanceLightStatusBars = <span class="literal">false</span></span><br><span class="line">        isAppearanceLightNavigationBars = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ViewCompat.setOnApplyWindowInsetsListener(findViewById(android.R.id.content)) &#123; view, insets -&gt;</span><br><span class="line">        <span class="keyword">val</span> systemBars = insets.getInsets(WindowInsetsCompat.Type.systemBars())</span><br><span class="line">        <span class="keyword">val</span> imeInsets = insets.getInsets(WindowInsetsCompat.Type.ime())</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 키보드가 올라올 때 (IME 인셋이 있을 때) 버튼을 이동</span></span><br><span class="line">        viewForKeyboard.translationY = <span class="keyword">if</span> (imeInsets.bottom &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            -(imeInsets.bottom - systemBars.bottom).toFloat()</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="number">0f</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        view.setPadding(systemBars.left, systemBars.top, systemBars.right, systemBars.bottom)</span><br><span class="line">        insets</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-8868044834754772"     crossorigin="anonymous"></script><p><ins class="adsbygoogle"     style="display:block; text-align:center;"     data-ad-layout="in-article"     data-ad-format="fluid"     data-ad-client="ca-pub-8868044834754772"     data-ad-slot="1292114373"></ins></p><script>     (adsbygoogle = window.adsbygoogle || []).push({});</script><h1 id="EdgeToEdge-적용"><a href="#EdgeToEdge-적용" class="headerlink" title="EdgeToEdge 적용"></a><strong>EdgeToEdge 적용</strong></h1><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> : <span class="type">ComponentActivitiy</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">setupWindowInsets</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ViewCompat.setOnApplyWindowInsetsListener(findViewById(android.R.id.content)) &#123; view, insets -&gt;</span><br><span class="line">      <span class="keyword">val</span> systemBars = insets.getInsets(WindowInsetsCompat.Type.systemBars())</span><br><span class="line">      view.setPadding(systemBars.left, systemBars.top, systemBars.right, systemBars.bottom)</span><br><span class="line">      insets</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">    enableEdgeToEdge() <span class="comment">// 반드시 onCreate보다 먼저 호출해야 한다.</span></span><br><span class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">    setupWindowInsets()</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="setDecorFitsSystemWindows"><a href="#setDecorFitsSystemWindows" class="headerlink" title="setDecorFitsSystemWindows"></a><a href="https://developer.android.com/reference/androidx/core/view/WindowCompat#setDecorFitsSystemWindows(android.view.Window,boolean)">setDecorFitsSystemWindows</a></h1><blockquote><p>WindowInsetsCompat에 따라 decorView가 루트 수준 콘텐츠 뷰에 맞출 것인지 여부를 설정한다.</p><p>false로 설정하면 프레임워크는 콘텐츠 뷰를 인셋에 맞추지 않고 WindowInsetsCompat을 통해 콘텐츠 뷰에 전달한다.</p></blockquote><p>API 35 미만에서는 시스템 바까지 확장된 풀스크린(edgeToEdge)이 decorFitsSystemWindows 옵션을 통해 선택적이었다.</p><p>decorFitsSystemWindows는 내부적으로 API 16-29에서 setSystemUiVisibility를 사용한다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">static <span class="class"><span class="keyword">class</span> <span class="title">Api16Impl</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Api16Impl() &#123;</span><br><span class="line">        <span class="comment">// This class is not instantiable.</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static void setDecorFitsSystemWindows(</span><br><span class="line">            <span class="meta">@NonNull</span> Window window,</span><br><span class="line">            <span class="keyword">final</span> boolean decorFitsSystemWindows</span><br><span class="line">    ) &#123;</span><br><span class="line">        <span class="keyword">final</span> int decorFitsFlags = View.SYSTEM_UI_FLAG_LAYOUT_STABLE</span><br><span class="line">                | View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION</span><br><span class="line">                | View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN;</span><br><span class="line">        <span class="keyword">final</span> View decorView = window.getDecorView();</span><br><span class="line">        <span class="keyword">final</span> int sysUiVis = decorView.getSystemUiVisibility();</span><br><span class="line">        decorView.setSystemUiVisibility(decorFitsSystemWindows</span><br><span class="line">                ? sysUiVis &amp; ~decorFitsFlags</span><br><span class="line">                : sysUiVis | decorFitsFlags);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>WindowCompat.setDecorFitsSystemWindows(window, boolean)은 API에 맞는 동작으로 하도록 구성되어, API 30 이상과 API 16-29가 분기처리되어 있다.</p><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-8868044834754772"     crossorigin="anonymous"></script><p><ins class="adsbygoogle"     style="display:block; text-align:center;"     data-ad-layout="in-article"     data-ad-format="fluid"     data-ad-client="ca-pub-8868044834754772"     data-ad-slot="1292114373"></ins></p><script>     (adsbygoogle = window.adsbygoogle || []).push({});</script><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> static void setDecorFitsSystemWindows(<span class="meta">@NonNull</span> Window window,</span><br><span class="line">        <span class="keyword">final</span> boolean decorFitsSystemWindows) &#123;</span><br><span class="line">    <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= <span class="number">30</span>) &#123;</span><br><span class="line">        Api30Impl.setDecorFitsSystemWindows(window, decorFitsSystemWindows);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Api16Impl.setDecorFitsSystemWindows(window, decorFitsSystemWindows);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>그런데, API 35에서 이를 아우를 수 있는, 즉 decorFitsSystemWindows나 setSystemUiVisibility를 개발자가 사용하지 않고 enableEdgeToEdge() 함수 호출만으로 풀스크린을 구현할 수 있게 되었다.</p><p>문제는 그것 뿐만이 아니라 풀스크린이 기본 기기 설정이 된 것이다. enableEdgeToEdge()를 설정하지 않아도 targetSDK가 35인 앱은 풀스크린으로 실행된다. 따라서 그 기본 설정을 위해 enableEdgeToEdge()를 호출해줘야 하는 것이다.</p><p>enableEdgeToEdge()를 사용하기 이전에는 decorFitsSystemWindows를 사용하여 시스템 표시줄 뒤에 앱을 배치하였다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">  <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">  WindowCompat.setDecorFitsSystemWindows(window, <span class="literal">false</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">RelativeLayout</span></span></span><br><span class="line"><span class="tag">  <span class="attr">...</span></span></span><br><span class="line"><span class="tag">  <span class="attr">android:fitsSystemWindows</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p>그런데 enableEdgeToEdge()의 내부 코드를 보면 내부적으로 모두 setDecorFitsSystemWindows(window, false)를 호출하고 있음을 볼 수 있다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@JvmName(<span class="meta-string">&quot;enable&quot;</span>)</span></span><br><span class="line"><span class="meta">@JvmOverloads</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> ComponentActivity.<span class="title">enableEdgeToEdge</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    statusBarStyle: <span class="type">SystemBarStyle</span> = SystemBarStyle.auto(Color.TRANSPARENT, Color.TRANSPARENT)</span></span>,</span><br><span class="line">    navigationBarStyle: SystemBarStyle = SystemBarStyle.auto(DefaultLightScrim, DefaultDarkScrim)</span><br><span class="line">) &#123;</span><br><span class="line">    <span class="keyword">val</span> view = window.decorView</span><br><span class="line">    <span class="keyword">val</span> statusBarIsDark = statusBarStyle.detectDarkMode(view.resources)</span><br><span class="line">    <span class="keyword">val</span> navigationBarIsDark = navigationBarStyle.detectDarkMode(view.resources)</span><br><span class="line">    <span class="keyword">val</span> impl = Impl ?: <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= <span class="number">29</span>) &#123;</span><br><span class="line">        EdgeToEdgeApi29()</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= <span class="number">26</span>) &#123;</span><br><span class="line">        EdgeToEdgeApi26()</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= <span class="number">23</span>) &#123;</span><br><span class="line">        EdgeToEdgeApi23()</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= <span class="number">21</span>) &#123;</span><br><span class="line">        EdgeToEdgeApi21()</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        EdgeToEdgeBase()</span><br><span class="line">    &#125;.also &#123; Impl = it &#125;</span><br><span class="line">    impl.setUp(</span><br><span class="line">        statusBarStyle, navigationBarStyle, window, view, statusBarIsDark, navigationBarIsDark</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequiresApi(21)</span></span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">EdgeToEdgeApi21</span> : <span class="type">EdgeToEdgeImpl &#123;</span></span></span><br><span class="line">    <span class="meta">@Suppress(<span class="meta-string">&quot;DEPRECATION&quot;</span>)</span></span><br><span class="line">    <span class="meta">@DoNotInline</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">setUp</span><span class="params">(...)</span></span> &#123;</span><br><span class="line">        WindowCompat.setDecorFitsSystemWindows(window, <span class="literal">false</span>)</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequiresApi(23)</span></span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">EdgeToEdgeApi23</span> : <span class="type">EdgeToEdgeImpl &#123;</span></span></span><br><span class="line">    <span class="meta">@DoNotInline</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">setUp</span><span class="params">(...)</span></span> &#123;</span><br><span class="line">        WindowCompat.setDecorFitsSystemWindows(window, <span class="literal">false</span>)</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequiresApi(26)</span></span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">EdgeToEdgeApi26</span> : <span class="type">EdgeToEdgeImpl &#123;</span></span></span><br><span class="line">    <span class="meta">@DoNotInline</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">setUp</span><span class="params">(...)</span></span> &#123;</span><br><span class="line">        WindowCompat.setDecorFitsSystemWindows(window, <span class="literal">false</span>)</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequiresApi(29)</span></span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">EdgeToEdgeApi29</span> : <span class="type">EdgeToEdgeImpl &#123;</span></span></span><br><span class="line">    <span class="meta">@DoNotInline</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">setUp</span><span class="params">(...)</span></span> &#123;</span><br><span class="line">        WindowCompat.setDecorFitsSystemWindows(window, <span class="literal">false</span>)</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><a href="https://velog.io/@hyemdooly/enableEdgeToEdge-%EB%82%B4%EB%B6%80-%EC%BD%94%EB%93%9C-%EC%95%8C%EA%B3%A0-%EC%93%B0%EA%B8%B0">링크</a> Scrim은 연극 용어이다. 앞쪽에 빛을 비추면 불투명하고, 뒤쪽에 빛을 비추면 투명하거나 반투명하게 보이는 theater drop을 의미한다.</p></blockquote><h1 id="키보드가-나타났을-때의-인셋-대응-adjustResize"><a href="#키보드가-나타났을-때의-인셋-대응-adjustResize" class="headerlink" title="키보드가 나타났을 때의 인셋 대응 - adjustResize"></a><strong>키보드가 나타났을 때의 인셋 대응 - adjustResize</strong></h1><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * EdgeToEdge(API 30부터 지원) 적용에 따른 인셋을 적용한다.</span></span><br><span class="line"><span class="comment"> * 추가로, 키보드가 올라올 때 (IME 인셋이 있을 때) 버튼을 이동시킨다.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> viewForKeyboard 키보드가 올라올 때 이동시킬 View</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> Window.<span class="title">setupWindowInsetsKeyboard</span><span class="params">(viewForKeyboard: <span class="type">View</span>)</span></span> &#123;</span><br><span class="line">    ViewCompat.setOnApplyWindowInsetsListener(findViewById(android.R.id.content)) &#123; view, insets -&gt;</span><br><span class="line">        <span class="keyword">val</span> systemBars = insets.getInsets(WindowInsetsCompat.Type.systemBars())</span><br><span class="line">        <span class="keyword">val</span> imeInsets = insets.getInsets(WindowInsetsCompat.Type.ime())</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 키보드가 올라올 때 (IME 인셋이 있을 때) 버튼을 이동</span></span><br><span class="line">        viewForKeyboard.translationY = <span class="keyword">if</span> (imeInsets.bottom &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            -(imeInsets.bottom - systemBars.bottom).toFloat()</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="number">0f</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        view.setPadding(systemBars.left, systemBars.top, systemBars.right, systemBars.bottom)</span><br><span class="line">        insets</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>관련글<ul><li><a href="https://dl137584.github.io/2025/06/25/034-android15-edge-to-edge-02-statusbar-and-navigationbar/">[Android] Android 15 대응 - EdgeToEdge: 2. StatusBar 및 NavigationBar</a></li><li><a href="https://dl137584.github.io/2025/06/25/035-android15-edge-to-edge-03-windowinsetscontroller/">[Android] Android 15 대응 - EdgeToEdge: 3. WindowInsetsController</a></li><li><a href="https://dl137584.github.io/2025/06/25/036-android15-edge-to-edge-03-display-cutout/">[Android] Android 15 대응 - EdgeToEdge: 4. 디스플레이 컷아웃</a></li></ul></li></ul><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-8868044834754772"     crossorigin="anonymous"></script><p><ins class="adsbygoogle"     style="display:block; text-align:center;"     data-ad-layout="in-article"     data-ad-format="fluid"     data-ad-client="ca-pub-8868044834754772"     data-ad-slot="1292114373"></ins></p><script>     (adsbygoogle = window.adsbygoogle || []).push({});</script>]]></content:encoded>
      
      
      <category domain="https://dl137584.github.io/categories/Android/">Android</category>
      
      
      
      <comments>https://dl137584.github.io/2025/06/25/033-android15-edge-to-edge-01-inset/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[Android/Flow] LiveData가 아닌 Flow를 사용해야 하는 이유</title>
      <link>https://dl137584.github.io/2025/05/12/037-why-you-should-use-flow-instead-of-livedata/</link>
      <guid>https://dl137584.github.io/2025/05/12/037-why-you-should-use-flow-instead-of-livedata/</guid>
      <pubDate>Mon, 12 May 2025 11:16:16 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;&lt;img src=&quot;/2025/05/12/037-why-you-should-use-flow-instead-of-livedata/037-livedata-and-flow.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;예전에는,&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;LiveData는 생명주</description>
        
      
      
      
      <content:encoded><![CDATA[<p><img src="/2025/05/12/037-why-you-should-use-flow-instead-of-livedata/037-livedata-and-flow.png"></p><p>예전에는,</p><ul><li>LiveData는 생명주기에 종속적이었고, 메인 스레드에서 실행되었기 때문에 Repository에서 사용하기엔 알맞지 않았다.</li><li>반면 Flow는 생명주기를 인식할 수 없었으나 데이터 스트림을 관리하는 객체로서 확장 함수가 잘 구성되어있었고, 코틀린 코루틴 라이브러리의 일부이기 때문에 Repository에서 사용하더라도 클린 아키텍처에 반하지 않았다.<ul><li>Flow는 coroutine 라이브러리에 포함되어있기 때문에 Repository에서 사용 시 의존성을 추가하지 않아도 된다.  <figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> kotlinx.coroutines.flow.MutableSharedFlow</span><br><span class="line"><span class="keyword">import</span> kotlinx.coroutines.flow.asSharedFlow</span><br></pre></td></tr></table></figure></li></ul>  또한,<blockquote><p>Flow는 Cold Stream 방식이다. 연속해서 계속 들어오는 데이터를 처리할 수 없고, collect 되었을 때만 생성되고 값을 반환한다. 만약 하나의 Flow Builder에 대해 다수의 collector가 있다면 collector 하나마다 하나씩 데이터를 호출하기 대문에 비용이 비싼 DB 접근, 서버 통신 등을 수행한다면 여러 번 리소스 요청을 하게될 수 있다.</p></blockquote></li></ul><p>→ LiveData는 ViewModel, Flow는 Repository에서 사용하는 상호보완적 관계였다.</p><ul><li>그런데 repeatOnLifecycle 블록에서 데이터를 collect함으로써 생명주기를 인식할 수 있는 StateFlow/SharedFlow가 등장했다.<ul><li>LiveData와 Flow는 ViewModel단에서는 상호대체 가능해졌다.</li></ul>  → 하지만 Flow가 사용성이 더 높기 때문에(ViewModel과 Repository 두 영역에서 모두 사용할 수 있게 되었기 때문에) LiveData보다는 Flow를 더 선호하게 되었다.</li><li>StateFlow<blockquote><p>StateFlow는 현재 상태와 새로운 상태 업데이트를 수집기에 내보내는 관찰 가능한 상태 홀더 흐름이다. value 속성을 통해서도 현재 상태 값을 읽을 수 있다. 상태를 업데이트하고 Flow에 전송하려면 MutableStateFlow 클래스의 value 속성에 새 값을 할당한다.</p></blockquote><blockquote><p>StateFlow는 Hot Flow이다. Flow에서 수집해도 생산자 코드가 트리거되지 않는다.</p></blockquote>  즉, StateFlow는 Hot 스트림 방식으로, 소비자의 collect 요청이 없어도 바로 값을 내보내고, 데이터가 업데이트 될 떄마다 데이터를 발행한다.</li></ul><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-8868044834754772"     crossorigin="anonymous"></script><p><ins class="adsbygoogle"     style="display:block; text-align:center;"     data-ad-layout="in-article"     data-ad-format="fluid"     data-ad-client="ca-pub-8868044834754772"     data-ad-slot="1292114373"></ins></p><script>     (adsbygoogle = window.adsbygoogle || []).push({});</script>]]></content:encoded>
      
      
      <category domain="https://dl137584.github.io/categories/Android/">Android</category>
      
      
      
      <comments>https://dl137584.github.io/2025/05/12/037-why-you-should-use-flow-instead-of-livedata/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[Android] 쿠키에 관하여</title>
      <link>https://dl137584.github.io/2025/03/20/038-about-cookie/</link>
      <guid>https://dl137584.github.io/2025/03/20/038-about-cookie/</guid>
      <pubDate>Thu, 20 Mar 2025 11:21:46 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;쿠키&quot;&gt;&lt;a href=&quot;#쿠키&quot; class=&quot;headerlink&quot; title=&quot;쿠키&quot;&gt;&lt;/a&gt;&lt;strong&gt;쿠키&lt;/strong&gt;&lt;/h1&gt;&lt;p&gt;여기서는 앱에 내려주는 쿠키형식에 관하여 이야기한다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;[&lt;a href=&quot;</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="쿠키"><a href="#쿠키" class="headerlink" title="쿠키"></a><strong>쿠키</strong></h1><p>여기서는 앱에 내려주는 쿠키형식에 관하여 이야기한다.</p><ul><li>[<a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Reference/Headers/Set-Cookie">MDN</a>] Set-Cookie</li></ul><h2 id="1-세션-쿠키"><a href="#1-세션-쿠키" class="headerlink" title="1. 세션 쿠키"></a>1. 세션 쿠키</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set-Cookie: sessionId=38afes7a8</span><br></pre></td></tr></table></figure><p>가장 간단한 형재는 key=value 형태로 되어있다.</p><p><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Reference/Headers/Set-Cookie#expiresdate">Expires 속성</a> 설명에 나와있듯이,</p><blockquote><p>If unspecified, the cookie becomes a <strong>session cookie</strong>. A session finishes when the client shuts down, after which the session cookie is removed.</p></blockquote><p>Expires 속성값이 지정되지 않으면 세션 쿠키이고, Chrome Inspector의 쿠키 리스트 중 expires 값에 “session”이라고 나타난다.</p><h2 id="2-지속-persistent-쿠키"><a href="#2-지속-persistent-쿠키" class="headerlink" title="2. 지속(persistent) 쿠키"></a>2. 지속(persistent) 쿠키</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set-Cookie: id=a3fWa; Expires=Wed, <span class="number">21</span> Oct <span class="number">2015</span> <span class="number">07</span>:<span class="number">28</span>:<span class="number">00</span> GMT</span><br></pre></td></tr></table></figure><p>지속 쿠키는 Expires 값이 <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Reference/Headers/Date">HTTP Date</a> 형태로 지정된 값이다. 이는 GMT(그리니치 평균시)를 따르며 런던을 기점으로 하는 시각이고, 로컬 시각이 아니다.</p><p>⚠️ 한국의 경우 GMT+09:00으로 표현하나, Expires 속성값 마지막에 “GMT” 대신 “GMT+09:00”를 쓰더라도 “+09:00”는 무시되기 때문에 날짜는 항상 “GMT” 시간을 나타내는 점에 주의해야 한다.</p><p>이렇게 Expires 속성값이 지정된 쿠키는 지정된 만료 일자까지 살아있는다.</p><h2 id="3-안드로이드-웹뷰에도-세션-쿠키와-지속-쿠키가-나뉘어져서-보관되는가"><a href="#3-안드로이드-웹뷰에도-세션-쿠키와-지속-쿠키가-나뉘어져서-보관되는가" class="headerlink" title="3. 안드로이드 웹뷰에도 세션 쿠키와 지속 쿠키가 나뉘어져서 보관되는가?"></a>3. 안드로이드 웹뷰에도 세션 쿠키와 지속 쿠키가 나뉘어져서 보관되는가?</h2><p>결론만 말하면, 그렇다.</p><p>이는 CookieManager의 removeSessionCookies()와 removeAllCookies() 메소드로 확인할 수 있다.</p><ol><li>우선 expires 속성값이 내려오는 “test” 쿠키가 있다고 하자. <figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set-Cookie: test=<span class="number">1</span>; Expires=Thu, <span class="number">20</span> Mar <span class="number">2025</span> <span class="number">11</span>:<span class="number">13</span>:<span class="number">47</span> GMT+09:<span class="number">00</span>; Domain=.megastudy.net; Path=/;</span><br></pre></td></tr></table></figure></li><li>이를 앱에서 받아(받는 방법은 아래의 [okhttp3.CookieJar] 항목을 참조) cookieManager를 이용해 setCookie한다.</li><li>removeSessionCookies()와 removeAllCookies()를 각각 수행하고 쿠키가 삭제되는지 확인한다.</li></ol><p>그 결과는 다음과 같다.</p><table><thead><tr><th></th><th>expires 속성 없음</th><th>expires 속성 있음</th></tr></thead><tbody><tr><td>removeSessionCookies</td><td>삭제됨</td><td>삭제안됨</td></tr><tr><td>removeAllCookies</td><td>삭제됨</td><td>삭제됨</td></tr></tbody></table><p>여기서 removeSessionCookie로 삭제되지 않는 값, 즉 expires 속성이 있는 쿠키값은 지속 쿠키로 간주할 수 있겠다.</p><p>CookieManager의 getCookie를 통해서는 쿠키의 이름과 값만 내려온다. 따라서 CookieManager를 통해 해당 쿠키의 만료일자 또는 만료여부를 판단할 수 있는 deprecated되지 않은 메소드는 없다.(CookieManager#removeExpiredCookie()는 deprecated되었다.) 그러나 앱 내부적으로 쿠키DB에 저장은 되고 있음을 inspector의 [Application] 탭 &gt; 사이드바의 [Storage] &gt; [Cookies] &gt; [해당 도메인]으로 접근하여 expires 값이 세팅되어있음을 확인할 수 있다.</p><p><img src="/2025/03/20/038-about-cookie/038-01.png"></p><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-8868044834754772"     crossorigin="anonymous"></script><p><ins class="adsbygoogle"     style="display:block; text-align:center;"     data-ad-layout="in-article"     data-ad-format="fluid"     data-ad-client="ca-pub-8868044834754772"     data-ad-slot="1292114373"></ins></p><script>     (adsbygoogle = window.adsbygoogle || []).push({});</script><h1 id="okhttp3-CookieJar"><a href="#okhttp3-CookieJar" class="headerlink" title="okhttp3.CookieJar"></a><strong>okhttp3.CookieJar</strong></h1><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> cookieManager = CookieManager.getInstance()</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> myCookieJar = <span class="keyword">object</span> : CookieJar &#123;</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">loadForRequest</span><span class="params">(url: <span class="type">HttpUrl</span>)</span></span>: MutableList&lt;Cookie&gt; &#123;</span><br><span class="line">    <span class="keyword">val</span> cookies = mutableListOf&lt;Cookie&gt;()</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 여기서 앱에서 가지고 있는 쿠키를 웹으로 보낼 수 있다.</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> cookies</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">saveFromResponse</span><span class="params">(url: <span class="type">HttpUrl</span>, cookies: <span class="type">MutableList</span>&lt;<span class="type">Cookie</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 여기서 파라미터를 통해 받아온 cookies 값은 웹에서 세팅된 쿠키값이며</span></span><br><span class="line">    <span class="comment">// 이를 안드로이드에 setCookie 해주어야 한다.</span></span><br><span class="line">    </span><br><span class="line">    cookies.forEachIndexed &#123; i, cookie -&gt;</span><br><span class="line">      cookieManager.setCookie(url.toString(), cookie.toString())</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>CookieJar은 loadForRequest와 saveFromResponse 두 개의 함수를 구현하도록 되어 있다.</p><ul><li>loadForRequest: HTTP 요청을 보내 기 전에 요청에 사용할 쿠키를 반환한다.</li><li>saveFromResponse: HTTP 응답으로부터 받은 쿠키를 저장소에 저장한다.</li></ul><p>따라서 순서로 따지면 loadForRequest 후에 saveFromReponse가 호출된다.</p><p>이를 적용하는 코드는 다음과 같다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> clientBuilder = OkHttpClient.Builder().apply &#123;</span><br><span class="line">  connectTimeout(Const.TIMEOUT, TimeUnit.SECONDS)</span><br><span class="line">  writeTimeout(Const.TIMEOUT, TimeUnit.SECONDS)</span><br><span class="line">  readTimeout(Const.TIMEOUT, TimeUnit.SECONDS)</span><br><span class="line">&#125;</span><br><span class="line">.cookieJar(myCookieJar)</span><br></pre></td></tr></table></figure><h1 id="Web-Attribute-Expires"><a href="#Web-Attribute-Expires" class="headerlink" title="[Web/Attribute] Expires"></a><strong>[Web/Attribute] Expires</strong></h1><p>Expires 속성을 가진 지속 쿠키를 웹으로부터 받아온 경우(CookieJar의 saveFromResponse로 확인) 이 만료 기간이 잘 작동하는지 확인하고자 하였다.</p><p>우선 아래와 같이 test 라는 이름의 쿠키를 추가한다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> time = SimpleDateFormat(<span class="string">&quot;EEE, dd MMM yyyy HH:mm:ss z&quot;</span>, Locale.US)</span><br><span class="line">time.timeZone = TimeZone.getTimeZone(<span class="string">&quot;GMT&quot;</span>)</span><br><span class="line"><span class="keyword">val</span> expiryDate = time.format(</span><br><span class="line">    Date(System.currentTimeMillis() + <span class="number">60</span> * <span class="number">1000</span>)</span><br><span class="line">)</span><br><span class="line">cookieManager.setCookie(</span><br><span class="line">  url.toString(),</span><br><span class="line">  <span class="string">&quot;test=1; Expires=<span class="variable">$expiryDate</span>;Domain=.megastudy.net; Path=/;&quot;</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// &quot;test=1; Expires=Thu, 20 Mar 2025 11:13:47 GMT+09:00;Domain=.megastudy.net; Path=/;&quot;</span></span><br></pre></td></tr></table></figure><p>Expires 속성값은 <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Reference/Headers/Date">HTTP Date 형식</a>으로 되어, GMT(그리니치 표준시)를 따른다. 이를 위해 타임존을 설정하면 로컬(한국)의 시간보다 9시간차이가 나는 값을 얻을 수 있다. 즉 아래 두 값은 같은 시각을 나타낸다고 보면 된다.</p><ol><li>Thu, 20 Mar 2025 15:00:00 GMT+09:00</li><li>Thu, 20 Mar 2025 06:00:00 GMT</li></ol><p>그리고 Expires 속성값은 1번을 넣어도 2번으로 인식하는 게 아니기 때문에 반드시 로컬 시간을 보정해주어야 하며 이를 위해 timeZone을 <code>TimeZone.getTimeZone(&quot;GMT&quot;)</code>로 설정한다.</p><p><img src="/2025/03/20/038-about-cookie/038-02.png" alt="chrome inspector"></p><p>그리고 해당 “test” 쿠키는 GMT 값에 따라 만료일이 경과하면 자동으로 사라지는 것을 inspector를 통해 확인할 수 있다.</p><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-8868044834754772"     crossorigin="anonymous"></script><p><ins class="adsbygoogle"     style="display:block; text-align:center;"     data-ad-layout="in-article"     data-ad-format="fluid"     data-ad-client="ca-pub-8868044834754772"     data-ad-slot="1292114373"></ins></p><script>     (adsbygoogle = window.adsbygoogle || []).push({});</script>]]></content:encoded>
      
      
      <category domain="https://dl137584.github.io/categories/Android/">Android</category>
      
      
      
      <comments>https://dl137584.github.io/2025/03/20/038-about-cookie/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[Android] LifecycleOwnerWrapper 분석</title>
      <link>https://dl137584.github.io/2025/01/08/039-lifecycleownerwrapper/</link>
      <guid>https://dl137584.github.io/2025/01/08/039-lifecycleownerwrapper/</guid>
      <pubDate>Wed, 08 Jan 2025 11:33:12 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;앱이 포그라운드에서 백그라운드로 전환됐을 때 해당 Activity가 onPause에서 onStop으로 전환된다. 이때 ViewModel의 LiveData가 변경을 감지하고자 등록된 (Activity 또는 Fragment로부터 받은) lifecyc</description>
        
      
      
      
      <content:encoded><![CDATA[<p>앱이 포그라운드에서 백그라운드로 전환됐을 때 해당 Activity가 onPause에서 onStop으로 전환된다. 이때 ViewModel의 LiveData가 변경을 감지하고자 등록된 (Activity 또는 Fragment로부터 받은) lifecycleOwner는 활성화(active) 상태에서 비활성화(inActive) 상태로 전환된다.</p><p>이때 onStop(inActive 상태) 시에도 활성화 상태를 유지하기 위해 구현된 LifecycleOwnerWrapper 상세는 다음과 같다.</p><ul><li><a href="https://stackoverflow.com/questions/57909258/android-viewmodel-observer-not-called-from-background/72467101#72467101">stackoverflow</a></li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LifecycleOwnerWrapper</span></span>(</span><br><span class="line">  sourceOwner: LifecycleOwner</span><br><span class="line">): LifecycleOwner, LifecycleEventObserver &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="keyword">val</span> lifecycle = LifecycleRegistry(<span class="keyword">this</span>)</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">init</span> &#123;</span><br><span class="line">    sourceOwner.lifecycle.addObserver(<span class="keyword">this</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">when</span> (<span class="keyword">val</span> state = sourceOwner.lifecycle.currentState) &#123;</span><br><span class="line">      Lifecycle.State.DESTROYED -&gt; lifecycle.handleLifecycleEvent(Lifecycle.Event.ON_DESTROY)</span><br><span class="line">      Lifecycle.State.CREATED -&gt; lifecycle.handleLifecycleEvent(Lifecycle.Event.ON_CREATE)</span><br><span class="line">      Lifecycle.State.STARTED -&gt; lifecycle.handleLifecycleEvent(Lifecycle.Event.ON_START)</span><br><span class="line">      Lifecycle.State.RESUMED -&gt; lifecycle.handleLifecycleEvent(Lifecycle.Event.ON_RESUME)</span><br><span class="line">      <span class="keyword">else</span> -&gt; &#123;</span><br><span class="line">        <span class="comment">// do nothing, the observer will catch up</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onStateChanged</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    source: <span class="type">LifecycleOwner</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    event: <span class="type">Lifecycle</span>.<span class="type">Event</span></span></span></span><br><span class="line"><span class="params"><span class="function">  )</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (event != Lifecycle.Event.ON_PAUSE</span><br><span class="line">      &amp;&amp; event != Lifecycle.Event.ON_STOP) &#123;</span><br><span class="line">      lifecycle.handleLifecycleEvent(event)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-8868044834754772"     crossorigin="anonymous"></script><p><ins class="adsbygoogle"     style="display:block; text-align:center;"     data-ad-layout="in-article"     data-ad-format="fluid"     data-ad-client="ca-pub-8868044834754772"     data-ad-slot="1292114373"></ins></p><script>     (adsbygoogle = window.adsbygoogle || []).push({});</script><ol><li><p>“onStop(inactive 상태) 시에도 활성화 상태를 유지하”는 lifecycle을 새롭게 만들기 위해 LifecycleOwner를 상속받아 lifecycle 변수를 새로 정의한다.</p> <figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LifecycleOwnerWrapper</span></span>(sourceOwner: LifecycleOwner): LifecycleOwner, LifecycleEventObserver &#123;</span><br><span class="line">  <span class="keyword">override</span> <span class="keyword">val</span> lifecycle = LifecycleRegistry(<span class="keyword">this</span>)</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>그 lifecycle이 생성되었을 때 현재 state를 init을 통해 등록한다.</p> <figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">init</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">when</span> (<span class="keyword">val</span> state = sourceOwner.lifecycle.currentState) &#123;</span><br><span class="line">    Lifecycle.State.DESTROYED -&gt; lifecycle.handleLifecycleEvent(Lifecycle.Event.ON_DESTROY)</span><br><span class="line">    Lifecycle.State.CREATED -&gt; lifecycle.handleLifecycleEvent(Lifecycle.Event.ON_CREATE)</span><br><span class="line">    Lifecycle.State.STARTED -&gt; lifecycle.handleLifecycleEvent(Lifecycle.Event.ON_START)</span><br><span class="line">    Lifecycle.State.RESUMED -&gt; lifecycle.handleLifecycleEvent(Lifecycle.Event.ON_RESUME)</span><br><span class="line">    <span class="keyword">else</span> -&gt; &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 여기서 handleLifecycleEvent는 아래 구현부와 같이 파라미터로 받은 state를 currentState로 등록하는 역할을 한다.</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Sets the current state and notifies the observers.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">open fun <span class="title">handleLifecycleEvent</span><span class="params">(event: Event)</span> </span>&#123;</span><br><span class="line">    enforceMainThreadIfNeeded(<span class="string">&quot;handleLifecycleEvent&quot;</span>)</span><br><span class="line">    moveToState(event.targetState)</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">private</span> fun <span class="title">moveToState</span><span class="params">(next: State)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (state == next) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    check(!(state == State.INITIALIZED &amp;&amp; next == State.DESTROYED)) &#123;</span><br><span class="line">        <span class="string">&quot;no event down from $state in component $&#123;lifecycleOwner.get()&#125;&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    state = <span class="function">next</span></span><br><span class="line"><span class="function">    <span class="title">if</span> <span class="params">(handlingEvent || addingObserverCounter != <span class="number">0</span>)</span> </span>&#123;</span><br><span class="line">        newEventOccurred = <span class="keyword">true</span></span><br><span class="line">        <span class="comment">// we will figure out what to do on upper level.</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    handlingEvent = <span class="function"><span class="keyword">true</span></span></span><br><span class="line"><span class="function">    <span class="title">sync</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    handlingEvent </span>= <span class="function"><span class="keyword">false</span></span></span><br><span class="line"><span class="function">    <span class="title">if</span> <span class="params">(state == State.DESTROYED)</span> </span>&#123;</span><br><span class="line">        observerMap = FastSafeIterableMap()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>새로운 lifecycle에 대한 동작을 구현하기 위해 LifecycleEventObserver를 상속받도록 하여 onStateChanged를 구현할 수 있도록 한다.</p> <figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LifecycleOwnerWrapper</span></span>(</span><br><span class="line">  sourceOwner: LifecycleOwner</span><br><span class="line">): LifecycleOwner, LifecycleEventObserver &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onStateChanged</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    source: <span class="type">LifecycleOwner</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    event: <span class="type">Lifecycle</span>.<span class="type">Event</span></span></span></span><br><span class="line"><span class="params"><span class="function">  )</span></span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>여기서 LifecycleEventObserver를 상속받지 않고 LifecycleOwnerWrapper를 사용하는 Activity 또는 Fragment 내의 observer를 등록하는 부분에서 LifecycleEventObserver를 구현해도 된다.<ul><li><a href="https://velog.io/@blucky8649/%EC%95%88%EB%93%9C%EB%A1%9C%EC%9D%B4%EB%93%9C-%EC%88%98%EB%AA%85%EC%A3%BC%EA%B8%B0-%EC%9D%B8%EC%8B%9D-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8">링크</a></li></ul></li></ul></li><li><p>onStateChanged에는 “onStop(inactive 상태) 시에도 활성화 상태를 유지하”기 위해 onStop일 경우 정상적으로 handleLifecycleEvent를 호출하지 <strong>않도록</strong> 한다.</p> <figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onStateChanged</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  source: <span class="type">LifecycleOwner</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">  event: <span class="type">Lifecycle</span>.<span class="type">Event</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (event != Lifecycle.Event.ON_PAUSE</span><br><span class="line">    &amp;&amp; event != Lifecycle.Event.ON_STOP) &#123;</span><br><span class="line">    lifecycle.handleLifecycleEvent(event)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 그럼으로써 이 lifecycle에서는 다음과 같은 커스텀 lifecycle이 적용된다.</p><table><thead><tr><th>정상 lifecycle</th><th>활성화 여부</th><th>커스텀 lifecycle에서의 state</th><th>활성화 여부</th></tr></thead><tbody><tr><td>onCreate</td><td>x</td><td>ON_CREATE</td><td>x</td></tr><tr><td>onStart</td><td>o</td><td>ON_START</td><td>o</td></tr><tr><td>onResume</td><td>o</td><td>ON_RESUME</td><td>o</td></tr><tr><td>onPause</td><td>o*</td><td>ON_RESUME</td><td>o</td></tr><tr><td>onStop</td><td>x</td><td>ON_RESUME</td><td>o</td></tr><tr><td>onDestroy</td><td>x</td><td>ON_DESTROY</td><td>x</td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td>*<a href="https://pluu.github.io/blog/android/2023/01/19/fragment_visible_lifecycleowner/">링크</a>에 따르면, Fragment에서는 onPause에서도 active하다고 함.</td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr></tbody></table></li><li><p>마지막으로 구현된 새로운 lifecycle을 적용하기 위해 sourceOwner에 LifecycleEventObserver를 등록(addObserver)한다.</p> <figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sourceOwner.lifecycle.addObserver(<span class="keyword">this</span>)</span><br></pre></td></tr></table></figure></li></ol><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-8868044834754772"     crossorigin="anonymous"></script><p><ins class="adsbygoogle"     style="display:block; text-align:center;"     data-ad-layout="in-article"     data-ad-format="fluid"     data-ad-client="ca-pub-8868044834754772"     data-ad-slot="1292114373"></ins></p><script>     (adsbygoogle = window.adsbygoogle || []).push({});</script>]]></content:encoded>
      
      
      <category domain="https://dl137584.github.io/categories/Android/">Android</category>
      
      
      
      <comments>https://dl137584.github.io/2025/01/08/039-lifecycleownerwrapper/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[Coil/번역] 2.3.0</title>
      <link>https://dl137584.github.io/2024/06/26/040-coil-2-3-0/</link>
      <guid>https://dl137584.github.io/2024/06/26/040-coil-2-3-0/</guid>
      <pubDate>Wed, 26 Jun 2024 11:37:25 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;📌 &lt;code&gt;implementation &amp;#39;io.coil-kt:coil-compose:2.3.0’&lt;/code&gt;&lt;/p&gt;
&lt;h1 id=&quot;인트로&quot;&gt;&lt;a href=&quot;#인트로&quot; class=&quot;headerlink&quot; title=&quot;인트로&quot;&gt;&lt;/a&gt;&lt;st</description>
        
      
      
      
      <content:encoded><![CDATA[<p>📌 <code>implementation &#39;io.coil-kt:coil-compose:2.3.0’</code></p><h1 id="인트로"><a href="#인트로" class="headerlink" title="인트로"></a><strong>인트로</strong></h1><p>SubcomposeAsyncImage을 다음과 같이 사용했을 때 LazyColumn 동작에서 버벅이는 이슈가 있었다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">SubcomposeAsyncImage(</span><br><span class="line">  model = imageUrl,</span><br><span class="line">  imageLoader = CoilImageLoader.getImageLoader(context = context),</span><br><span class="line">  error = &#123;</span><br><span class="line">    Image(</span><br><span class="line">      modifier = Modifier.size(<span class="number">50.</span>dp),</span><br><span class="line">      painter = painterResource(id = R.drawable.none),</span><br><span class="line">      contentDescription = <span class="string">&quot;&quot;</span></span><br><span class="line">    )</span><br><span class="line">  &#125;,</span><br><span class="line">  contentDescription = <span class="string">&quot;&quot;</span>,</span><br><span class="line">  modifier = Modifier</span><br><span class="line">    .size(<span class="number">50.</span>dp)</span><br><span class="line">    .clip(CircleShape)</span><br><span class="line">    .zIndex(<span class="number">1f</span>),</span><br><span class="line">  contentScale = ContentScale.Crop</span><br><span class="line">)</span><br></pre></td></tr></table></figure><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">object</span> CoilImageLoader &#123;</span><br><span class="line">    <span class="meta">@Composable</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getImageLoader</span><span class="params">(context: <span class="type">Context</span>)</span></span>: ImageLoader &#123;</span><br><span class="line">        <span class="keyword">val</span> imageLoader = remember &#123;</span><br><span class="line">            ImageLoader.Builder(context)</span><br><span class="line">                .memoryCache &#123; MemoryCache.Builder(context).maxSizePercent(<span class="number">0.3</span>).build() &#125;</span><br><span class="line">                .crossfade(<span class="literal">true</span>)</span><br><span class="line">                .allowHardware(<span class="literal">false</span>)</span><br><span class="line">                .build()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> imageLoader</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>테스트 해보니, Coil에서는 url에 빈값이 들어올 경우 error로 넘어간다.(Glide는 빈값일 경우 네트워크를 통하지 않고 바로 placeholder를 그대로 보여준다) 그래서 스크롤 할 때마다 로딩이미지도 깜빡거리면서 다시 그려지는 모션을 보이게 되었다.</p><p>여기서 문제는 Subcomposition이었다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">AsyncImage(</span><br><span class="line">  model = memberImage,</span><br><span class="line">  contentDescription = stringResource(id = R.string.description_profile_image),</span><br><span class="line">  imageLoader = CoilImageLoader.getImageLoader(context = context),</span><br><span class="line">  modifier = Modifier</span><br><span class="line">    .size(<span class="number">50.</span>dp)</span><br><span class="line">    .clip(CircleShape)</span><br><span class="line">    .zIndex(<span class="number">1f</span>),</span><br><span class="line">  placeholder = painterResource(id = R.drawable.none_profile_02),</span><br><span class="line">  error = painterResource(id = R.drawable.none_profile_02),</span><br><span class="line">  contentScale = ContentScale.Crop,</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>평범하게 AsyncImage를 사용하여 어느정도 예상대로의 움직임을 보이도록 성공했다.</p><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-8868044834754772"     crossorigin="anonymous"></script><p><ins class="adsbygoogle"     style="display:block; text-align:center;"     data-ad-layout="in-article"     data-ad-format="fluid"     data-ad-client="ca-pub-8868044834754772"     data-ad-slot="1292114373"></ins></p><script>     (adsbygoogle = window.adsbygoogle || []).push({});</script><p>📌 이하는 <a href="https://coil-kt.github.io/coil/compose/">Coil 공식 문서</a>를 번역한 것입니다.</p><p>AsyncImage 컴포저블을 사용하는 예시는 다음과 같다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">AsyncImage(</span><br><span class="line">  model = <span class="string">&quot;https://example.com/iamge.jpg&quot;</span>,</span><br><span class="line">  contentDescription = <span class="literal">null</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>model은 <code>ImageRequest.data</code> 값이나 <code>ImageRequest</code> 그 자체를 넘길 수 있다.</p><h1 id="AsyncImage"><a href="#AsyncImage" class="headerlink" title="AsyncImage"></a><strong>AsyncImage</strong></h1><p>AsyncImage는 비동기적으로 image를 요청하여 결과값을 렌더링하는 컴포저블이다. 이는 Image 컴포저블의 표준 매개변수를 동일하게 지원하고, 부가적으로 <code>placeholder</code>, <code>error</code>, <code>fallback</code> painters와 <code>onLoading</code>, <code>onSuccess</code>, <code>onError</code> 콜백을 추가 지원한다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">AsyncImage(</span><br><span class="line">  model = ImageRequest.Builder(LocalContext.current)</span><br><span class="line">    .<span class="keyword">data</span>(<span class="string">&quot;https://example.com/image.jpg&quot;</span>)</span><br><span class="line">    .crossfade(<span class="literal">true</span>)</span><br><span class="line">    .build(),</span><br><span class="line">  placeholder = painterResource(R.drawable.placeholder),</span><br><span class="line">  contentDescription = stringResource(R.string.description),</span><br><span class="line">  contentScale = ContentScale.Crop,</span><br><span class="line">  modifier = Modifier.clip(CircleShape)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h1 id="SubcomposeAsyncImage"><a href="#SubcomposeAsyncImage" class="headerlink" title="SubcomposeAsyncImage"></a><strong>SubcomposeAsyncImage</strong></h1><p>SubcomposeAsyncImage는 AsyncImage의 변형이다. 이것은 <code>Painter</code>를 사용하는 대신 <code>AsyncImagePainter</code>의 상태를 API 슬롯(아래 예제에서 loading 와 같은 것)에 제공하는 subcomposition을 사용하는 데에 쓰인다. 그 예제는 다음과 같다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SubcomposeAsyncImage(</span><br><span class="line">  model = <span class="string">&quot;https://example.com/image.jpg&quot;</span>,</span><br><span class="line">  loading = &#123;</span><br><span class="line">    CircularProgressIndicator() <span class="comment">// subcomposition?</span></span><br><span class="line">  &#125;,</span><br><span class="line">  contentDescription = straintResource(R.string.description)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>거기에 더해, 현재 상태에 따라 렌더링하는 항목이 달라지도록 복잡한 로직을 만들 수도 있다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">SubcomposeAsyncImage(</span><br><span class="line">  model = <span class="string">&quot;https://example.com/image.jpg&quot;</span>,</span><br><span class="line">  contentDescription = stringResource(R.string.description)</span><br><span class="line">) &#123;</span><br><span class="line">  <span class="keyword">val</span> state = painter.state</span><br><span class="line">  <span class="keyword">if</span> (state <span class="keyword">is</span> AsyncImagePainter.State.Loading</span><br><span class="line">      || state <span class="keyword">is</span> AsyncImagePainter.State.Error) &#123;</span><br><span class="line">    CirclularProgressIndicator()</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    SubcomposeAsyncImageContent()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Subcomposition은 정규 composition보다 효율이 낮다. 그래서 <strong>이 컴포저블은 높은 퍼포먼스(부드러운 스크롤 동작 등)를 요구하는 UI에서는 맞지 않을 수 있다.</strong></p><p>If you set a custom size for the <code>ImageRequest</code> using <code>ImageRequest.Builder.size</code> (e.g. <code>size(Size.ORIGINAL)</code>), <code>SubcomposeAsyncImage</code> will not use subcomposition since it doesn’t need to resolve the composable’s constraints.</p><p><code>ImageRequest.Builder.size</code> 를 사용하여 <code>ImageRequest</code>의 맞춤 크기를 설정하면 SubcomposeAsyncImage는 컴포저블의 제약 조건을 해결할 필요가 없으므로 하위 컴포지션을 사용하지 않습니다.</p><h1 id="AsyncImagePainter"><a href="#AsyncImagePainter" class="headerlink" title="AsyncImagePainter"></a><strong><del>AsyncImagePainter</del></strong></h1><p>내부적으로 AsyncImage와 SubcomposeAsyncImage는 model을 로드할 때 AsyncImagePainter를 사용한다. 만약 Painter가 필요한데 AsyncImage를 사용할 수 없다면 rememberAsyncImagePainter를 사용할 수 있을 것이다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> painter = rememberAsyncImagePainter(<span class="string">&quot;https://example.com/image.jpg&quot;</span>)</span><br></pre></td></tr></table></figure><p>단, rememberAsyncImagePainter는 <strong>모든 경우에서 예상대로 동작하지 않을 수 있</strong>는 하위 수준 API다.</p><p>만약 AsyncImagePainter를 렌더링하는 Image 컴포저블에 커스텀 ContentScale를 적용한다면 rememberAsyncImagePainter도 함께 세팅해야 한다. 이건 로드할 이미지의 크기를 결정하는 데에 필수적이기 때문이다.</p><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-8868044834754772"     crossorigin="anonymous"></script><p><ins class="adsbygoogle"     style="display:block; text-align:center;"     data-ad-layout="in-article"     data-ad-format="fluid"     data-ad-client="ca-pub-8868044834754772"     data-ad-slot="1292114373"></ins></p><script>     (adsbygoogle = window.adsbygoogle || []).push({});</script>]]></content:encoded>
      
      
      <category domain="https://dl137584.github.io/categories/Android/">Android</category>
      
      
      
      <comments>https://dl137584.github.io/2024/06/26/040-coil-2-3-0/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[Android/푸시] 알림 Notification</title>
      <link>https://dl137584.github.io/2024/03/24/041-notification/</link>
      <guid>https://dl137584.github.io/2024/03/24/041-notification/</guid>
      <pubDate>Sun, 24 Mar 2024 11:31:05 GMT</pubDate>
      
        
        
      <description>&lt;h3 id=&quot;권한-확인-동작&quot;&gt;&lt;a href=&quot;#권한-확인-동작&quot; class=&quot;headerlink&quot; title=&quot;권한 확인 동작&quot;&gt;&lt;/a&gt;&lt;strong&gt;권한 확인 동작&lt;/strong&gt;&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;API 32 이하&lt;/stro</description>
        
      
      
      
      <content:encoded><![CDATA[<h3 id="권한-확인-동작"><a href="#권한-확인-동작" class="headerlink" title="권한 확인 동작"></a><strong>권한 확인 동작</strong></h3><ul><li><strong>API 32 이하</strong> 앱의 경우, 시스템이 자동으로 퍼미션 팝업을 띄웠을 때, 사용자가 Don’t allow 버튼을 한번 누르면, 앱이 재시작해도 팝업이 발생하지 않는다.</li><li><strong>API 33 이상</strong> 앱의 경우, 앱이 퍼미션 팝업을 띄웠을 때, 사용자가 Don’t allow 버튼을 <strong>두 번</strong> 누르기 전까지 퍼미션 팝업을 계속 띄울 수 있다.</li><li>사용자가 Don’t allow 버튼을 눌러서 더 이상 팝업을 띄울 수 없다면 사용자가 직접 앱 설정에 들어가서 권한을 허가해줘야한다.</li></ul><h3 id="Android-13에서-변경된-사항"><a href="#Android-13에서-변경된-사항" class="headerlink" title="Android 13에서 변경된 사항"></a><strong>Android 13에서 변경된 사항</strong></h3><ul><li>POST_NOTIFICATIONS (Notification Permission) 은 Target SDK API 33 이상부터 추가 가능</li><li>Target SDK API 32 이하의 앱이 Android 13 디바이스에 설치되면 Notification Channel을 등록할 때 <strong>자동으로</strong> Notification 권한 요청 팝업이 나옴</li><li>Target SDK API 33 이상의 앱이 Android 13 디바이스에 설치되면 Notification 권한요청을 <strong>개발자가 원하는 타이밍에 노출 가능</strong></li><li>Target SDK API 33 이상의 앱이 Android 12 이하 디바이스에 설치되면 기존과 동일하게 Notification 권한 요청 없이 사용 가능</li><li>Target SDK API 32 앱을 33으로 업데이트 시 기존 알림 권한 동의 상태라면 업데이트 이후 기본으로 허용이지만 예외 있음<ul><li><strong>기기에 따라</strong> 자동으로 허용되지 않고 다시 한 번 권한을 얻어야하는 경우가 있음</li><li>그렇기 때문에 Notification 권한이 허가되어 있는지 한 번 확인하는 작업을 넣기를 권장함</li></ul></li></ul><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-8868044834754772"     crossorigin="anonymous"></script><p><ins class="adsbygoogle"     style="display:block; text-align:center;"     data-ad-layout="in-article"     data-ad-format="fluid"     data-ad-client="ca-pub-8868044834754772"     data-ad-slot="1292114373"></ins></p><script>     (adsbygoogle = window.adsbygoogle || []).push({});</script><h3 id="특성"><a href="#특성" class="headerlink" title="특성"></a><strong>특성</strong></h3><ul><li>삼성 폰에서만 노티 아이콘에 색제한이 없다. 구글에서 권장하는 아이콘 색상배열은 투명배경에 흰색을 사용한 아이콘이다.<br>배경색이 있는 런처 아이콘을 사용한 경우 픽셀 단말에서 아이콘이 깨진다.</li></ul><ul><li><p>채널 중요도 수준</p><p>  <img src="/2024/03/24/041-notification/041-06.png" alt="출처: Android 공식문서"></p><blockquote><p>⚠️ setTicker넣었더니 Android API 27에서 테스트하길, 아이콘도 제대로 안나오고 priority high로 설정했는데 헤드업이 안뜸.</p></blockquote></li></ul><ul><li><p>옵션</p><p>  <img src="/2024/03/24/041-notification/041-08.png"></p><ul><li>출처: <a href="https://hyeonlog-developer.tistory.com/120">https://hyeonlog-developer.tistory.com/120</a></li></ul></li></ul><ul><li>가시성  잠금화면상태(system ui가 신뢰할 수 없는)에서 알림의 존재와 내용을 표시하는 방법, 가시성을 설정 (setVisibility()를 이용해 notificaiton에서 설정)<ul><li><a href="https://developer.android.com/reference/androidx/core/app/NotificationCompat?hl=ko#VISIBILITY_PUBLIC()"><code>VISIBILITY_PUBLIC</code></a>: 알림의 전체 콘텐츠가 잠금 화면에 표시된다.</li><li><a href="https://developer.android.com/reference/androidx/core/app/NotificationCompat?hl=ko#VISIBILITY_SECRET()"><code>VISIBILITY_SECRET</code></a>: 알림의 어느 부분도 잠금 화면에 표시되지 않는다.</li><li><a href="https://developer.android.com/reference/androidx/core/app/NotificationCompat?hl=ko#VISIBILITY_PRIVATE()"><code>VISIBILITY_PRIVATE</code></a>: 알림 아이콘과 콘텐츠 제목과 같은 기본 정보만 잠금 화면에 표시된다. 알림의 전체 콘텐츠가 표시되지 않는다.</li></ul></li></ul><ul><li>[<a href="https://support.google.com/android/answer/9079661?hl=ko">Google</a>] 푸시 펼치기 기능은 OS가 아닌 단말에 따라 존재 유무가 달라진다.</li></ul><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-8868044834754772"     crossorigin="anonymous"></script><p><ins class="adsbygoogle"     style="display:block; text-align:center;"     data-ad-layout="in-article"     data-ad-format="fluid"     data-ad-client="ca-pub-8868044834754772"     data-ad-slot="1292114373"></ins></p><script>     (adsbygoogle = window.adsbygoogle || []).push({});</script>]]></content:encoded>
      
      
      <category domain="https://dl137584.github.io/categories/Android/">Android</category>
      
      
      
      <comments>https://dl137584.github.io/2024/03/24/041-notification/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[번역: Kotlin Coroutines: Deep Dive] (2) 코틀린 코루틴에서 일시 정지 작업을 하는 방법</title>
      <link>https://dl137584.github.io/2024/03/22/030-kotlin-coroutines-deep-dive-02/</link>
      <guid>https://dl137584.github.io/2024/03/22/030-kotlin-coroutines-deep-dive-02/</guid>
      <pubDate>Fri, 22 Mar 2024 12:22:31 GMT</pubDate>
      
        
        
      <description>&lt;blockquote&gt;
&lt;p&gt;이 포스팅은 &lt;a href=&quot;https://kt.academy/book/coroutines&quot;&gt;Kotlin Coroutines: Deep Dive&lt;/a&gt;의 글을 번역한 것입니다. 오역, 많은 의역, 생략이 있으니 감안하여 읽</description>
        
      
      
      
      <content:encoded><![CDATA[<blockquote><p>이 포스팅은 <a href="https://kt.academy/book/coroutines">Kotlin Coroutines: Deep Dive</a>의 글을 번역한 것입니다. 오역, 많은 의역, 생략이 있으니 감안하여 읽어주십시오.</p></blockquote><p>하나의 코루틴을 일시정지하는 것은 중간에 멈추는 것을 의미한다. 이건 세이브한 게임을 멈추고 당신이 다른 일에 집중할 수 있는 상태와 유사하다. 그리고 후에 언제든 세이브포인트에서 게임을 다시 시작할 수 있다. 코루틴은 일시정지하면 Continuation을 반환한다. 이를 사용하여 멈춘 지점에서 다시 시작할 수 있다.</p><p>이는 save가 아니라 block하는 스레드와는 매우 다르다는 사실에 주의하라. 코루틴은 매우 강력하다. 일시정지했을 때 어떤 리소스도 사용하지 않는다. 코루틴은 다른 스레드를 다시 시작할 수 있다. (적어도 이론 상으로는) 하나의 continuation은 직렬화, 비직렬화되어있을 수 있고 다시 시작될 수도 있다.</p><h3 id="다시-시작"><a href="#다시-시작" class="headerlink" title="다시 시작"></a><strong>다시 시작</strong></h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  println(<span class="string">&quot;Before&quot;</span>)</span><br><span class="line">suspendCoroutine&lt;<span class="built_in">Unit</span>&gt; &#123; &#125;</span><br><span class="line">println(<span class="string">&quot;After&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위 코드를 실행하면 “After” 글자를 볼 수 없을 것이다. 그리고 (main 함수는 절대 끝나지 않기 때문에) 코드가 실행을 멈춘 것도 아니다. 우리는 게임을 멈췄지만 다시 시작하지는 않았다. 그렇다면 어떻게 다시 시작할 것인가? 앞서 언급한 Continuation는 어디에 있는가?</p><p>suspendCoroutine 블록의 람다식을 다시 보자. argument를 받는 이 함수는 일시정지하기 전에 불리워진다. 그때의 매개변수가 continuation이다. </p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  println(<span class="string">&quot;Before&quot;</span>)</span><br><span class="line">suspendCoroutine&lt;<span class="built_in">Unit</span>&gt; &#123; continuation -&gt;</span><br><span class="line">println(<span class="string">&quot;Before too&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">println(<span class="string">&quot;After&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>같은 곳에서 다른 함수를 부르는 이러한 함수는 전혀 새로운 것이 아니다. 이는 let이나 apply, useLines와 유사하다. suspendCoroutine 함수는 이와 같은 방식으로 디자인되었다. 즉 일시정지하기 전에 continuation을 사용할 수 있도록 하는 것이다. suspendCoroutine이 호출된 후면 너무 늦을 것이다. 그래서 람다식을 통해 그 전에 부를 수 있도록 한다. 람다는 continuation을 어디서든 저장하거나 이를 다시시작할지 여부를 계획하기도 한다.</p><p>즉시 다시 시작하려면 이렿게하면 된다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  println(<span class="string">&quot;Before&quot;</span>)</span><br><span class="line">suspendCoroutine&lt;<span class="built_in">Unit</span>&gt; &#123; continuation -&gt;</span><br><span class="line">continuation.resume(<span class="built_in">Unit</span>)</span><br><span class="line">&#125;</span><br><span class="line">println(<span class="string">&quot;After&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Before</span></span><br><span class="line"><span class="comment">// After</span></span><br></pre></td></tr></table></figure><p>위에서 “After”가 suspendCoroutine 안에서 resume을 호출했기 때문에 출력되었음에 주의하라.</p><blockquote><p>Kotlin 1.3 이후로 Continuation 정의가 바뀌었다. resume과 resumeWithException 대신 하나의 결과값이 있는 resumeWith 함수가 있다. 우리가 사용하고 있는 resume과 resumeWithException 함수는 resumeWith를 사용한 표준 라이브러리에 있는 extension 함수이다.</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> Continuation<span class="type">&lt;T&gt;</span>.<span class="title">resume</span><span class="params">(value: <span class="type">T</span>)</span></span>: <span class="built_in">Unit</span> =</span><br><span class="line">resumeWith(Result.success(value))</span><br><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> Continuation<span class="type">&lt;T&gt;</span>.<span class="title">resumeWithException</span><span class="params">(exception: <span class="type">Throwable</span>)</span></span>: <span class="built_in">Unit</span> =</span><br><span class="line">resumeWith(Result.failure(exception))</span><br></pre></td></tr></table></figure><p>설정된 시간동안 sleep할 다른 스레드를 시작할 수도 있다. 이는 언제든지 다시 시작할 수 있다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">print(<span class="string">&quot;Before &quot;</span>)</span><br><span class="line">suspendCoroutine&lt;<span class="built_in">Unit</span>&gt;&#123; continuation -&gt;</span><br><span class="line">thread &#123;</span><br><span class="line">print(<span class="string">&quot;Suspended &quot;</span>)</span><br><span class="line">Thread.sleep(<span class="number">1000</span>)</span><br><span class="line">continuation.resume(<span class="built_in">Unit</span>)</span><br><span class="line">print(<span class="string">&quot;Resumed &quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">print(<span class="string">&quot;After &quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Before Suspended (1 second delay) After Resumed </span></span><br></pre></td></tr></table></figure><p>중요한 부분이다. 정의된 시간이 끝난 후에 continuation을 다시 시작할 함수를 만들 수 있음에 주목하라. 여기서 continuation은 아래 보이는 것처럼 람다식에 의해 좌우된다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">continueAfterSecond</span><span class="params">(continuation: <span class="type">Continuation</span>&lt;<span class="type">Unit</span>&gt;)</span></span> &#123;</span><br><span class="line">thread &#123;</span><br><span class="line">Thread.sleep(<span class="number">1000</span>)</span><br><span class="line">continuation.resume(<span class="built_in">Unit</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">print(<span class="string">&quot;Before &quot;</span>)</span><br><span class="line">suspendCoroutine&lt;<span class="built_in">Unit</span>&gt; &#123; continutaion -&gt;</span><br><span class="line">continueAfterSecond(continuation)</span><br><span class="line">&#125;</span><br><span class="line">print(<span class="string">&quot;After &quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Before (1 sec) After </span></span><br></pre></td></tr></table></figure><p>이건 오류 없이 작동은 한다. 하지만 단 일 초 동안만 비활성화 상태가 되었다가 끝나는 스레드를 불필요하게 생성한다. 스레드는 비용이 싸지 않은데도 왜 낭비하고 있는가? 더 좋은 방법은 “알람”을 설정하는 것이다. JVM에서 그것을 구현하기 위해 ScheduledExecutorService를 사용했다. 여기서는 정의된 얼마간의 시간 후에 몇 개의 continuation.resume(Unit)을 호출하는 걸로 알람을 설정할 수 있다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> executor = </span><br><span class="line">Executor.newSingleThreadScheduledExecutor &#123;</span><br><span class="line">Thread(it, <span class="string">&quot;scheduler&quot;</span>).apply &#123; isDaemon = <span class="literal">true</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">print(<span class="string">&quot;Before &quot;</span>)</span><br><span class="line">suspendCoroutine&lt;<span class="built_in">Unit</span>&gt; &#123; continuation -&gt;</span><br><span class="line">executorschedule(&#123;</span><br><span class="line">continuation.resume(<span class="built_in">Unit</span>)</span><br><span class="line">&#125;, <span class="number">1000</span>, TimeUnit.MILLISECONDS)</span><br><span class="line">&#125;</span><br><span class="line">print(<span class="string">&quot;After &quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Before (1 seconds delay) After</span></span><br></pre></td></tr></table></figure><p>설정한 시간동안 일시정지하는 건 유용한 피처로 보인다. 그러니 이걸 delay라는 함수로 추출해보자.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">delay</span><span class="params">(timeMillis: <span class="type">Long</span>)</span></span>: <span class="built_in">Unit</span> = </span><br><span class="line">suspendCoroutine &#123; continuation -&gt;</span><br><span class="line">executor.schedule(&#123;</span><br><span class="line">continuation.resume(<span class="built_in">Unit</span>)</span><br><span class="line">&#125;, timeMillis, TimeUnit.MILLISECONDS)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>executor가 여전히 스레드를 사용하고 있지만 delay 함수를 사용하는 모든 코루틴에 한 개의 스레드만을 할당한다. 이 점은 하나의 스레드를 매번 블록하는 것보다는 낫다.</p><p>이는 코틀린 코루틴 라이브러리에서 지원하는 delay의 방식이다. 구현은 더 복잡하지만 필수적인 요소는 이렇다.</p><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-8868044834754772"     crossorigin="anonymous"></script><p><ins class="adsbygoogle"     style="display:block; text-align:center;"     data-ad-layout="in-article"     data-ad-format="fluid"     data-ad-client="ca-pub-8868044834754772"     data-ad-slot="1292114373"></ins></p><script>     (adsbygoogle = window.adsbygoogle || []).push({});</script><h3 id="어떤-값을-가지고-다시-시작하기"><a href="#어떤-값을-가지고-다시-시작하기" class="headerlink" title="어떤 값을 가지고 다시 시작하기"></a><strong>어떤 값을 가지고 다시 시작하기</strong></h3><p>resume 함수에서 Unit을 넘겨주는 거에 대해 걱정할 수도 있다. 그러면서 suspendCoroutine의 매개변수로 Unit을 사용하는 이유가 궁금해질 것이다. 이 두가지가 같다는 사실은 우연이 아니다. Unit은 함수로부터 반환되고, Continuation 타입 파라미터는 제네릭 타입이다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> ret: <span class="built_in">Unit</span> = </span><br><span class="line">suspendCoroutine&lt;<span class="built_in">Unit</span>&gt; &#123; cont: Continuation&lt;<span class="built_in">Unit</span>&gt; -&gt;</span><br><span class="line">cont.resume(<span class="built_in">Unit</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>suspendCoroutine이 호출될 때, 이 continuation에서 반환되는 타입이 어떤 것인지 명확해진다. 그 타입은 resume을 호출할 때 사용되곤 한다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">val</span> i: <span class="built_in">Int</span> = suspendCoroutine&lt;<span class="built_in">Int</span>&gt; &#123; cont -&gt;</span><br><span class="line">cont.resume(<span class="number">42</span>)</span><br><span class="line">&#125;</span><br><span class="line">println(i) <span class="comment">// 42</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> str: String = suspendCoroutine&lt;String&gt; &#123; cont -&gt;</span><br><span class="line">cont.resume(<span class="string">&quot;Some text&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">println(str) <span class="comment">// Some text</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> b: <span class="built_in">Boolean</span> = suspendCoroutine&lt;<span class="built_in">Boolean</span>&gt; &#123; cont -&gt;</span><br><span class="line">cont.resume(<span class="literal">true</span>)</span><br><span class="line">&#125;</span><br><span class="line">println(b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이는 (save-resume) 게임 비유에는 잘 들어맞지 않는다. 저장본을 다시 시작할 때 게임 내에서 어떤 것(값)을 가져올 수 있는 게임을 나는 알지 못한다. 그러나 이 점은 코루틴을 사용하면 완벽하게 이해된다. 종종 우리는 API로부터 네트워크 response를 받는 것처럼 어떤 데이터를 받아오기 위해 대기하곤 한다. 흔한 시나리오다. 스레드는 특정 데이터가 있는 지점에 도달할 때가지 비즈니스 로직을 실행시킨다. 그래서 네트워크 라이브러리에 이를 전달할 것을 요구한다. 코루틴 없이, 이 스레드는 앉아서 기다릴 수밖에 없다. 스레드가 비싼 자원이기 때문에 이는 엄청난 낭비다. 특히 안드로이드의 메인스레드와 같이 중요한 스레드라면 더욱 그렇다. 코루틴을 사용하면 그냥 일시정지 시켰다가, 라이브러리에게 “이 데이터를 받자마자 resume 함수에게 그냥 넘겨”라는 명령과 함께 continuation을 넘기기만 하면 된다. 그러면 스레드는 다른 일을 하러 갈 수 있다. 데이터가 오면 바로 그 스레드는 코루틴이 일시정지한 지점부터 다시 시작할 것이다.</p><p>실제로 이를 확인하기 위해 데이터를 수신할 때까지 일시정지하는 방법을 살펴보자. 아래 예제에서는 외부에서 가져온 requestUser 콜백함수를 사용한다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">println(<span class="string">&quot;Before&quot;</span>)</span><br><span class="line"><span class="keyword">val</span> user = suspendCoroutine&lt;User&gt; &#123; cont -&gt;</span><br><span class="line">requestUser &#123; user -&gt;</span><br><span class="line">cont.resume(user)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">println(user)</span><br><span class="line">println(<span class="string">&quot;After&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Before</span></span><br><span class="line"><span class="comment">// (1 second delay)</span></span><br><span class="line"><span class="comment">// User(name=Test)</span></span><br><span class="line"><span class="comment">// After</span></span><br></pre></td></tr></table></figure><p>suspendCoroutine을 직접 호출하는 것은 편리하지 않다. 대신 suspend 함수를 만드는 것을 선호한다. 그래서 이를 추출할 수도 있다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">requestUser</span><span class="params">()</span></span>: User &#123;</span><br><span class="line"><span class="keyword">return</span> suspendCoroutine&lt;User&gt; &#123; cont -&gt;</span><br><span class="line">requestUser &#123; user -&gt;</span><br><span class="line">cont.resume(user)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">println(<span class="string">&quot;Before&quot;</span>)</span><br><span class="line"><span class="keyword">val</span> user = requestUser()</span><br><span class="line">println(user)</span><br><span class="line">println(<span class="string">&quot;After&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>현재 suspend 함수는 Retrofit이나 Room과 같은 많은 유명한 라이브러리에서 지원하고 있다. 그물게 suspend 함수 안에 콜백 함수를 쓸 때가 있다. 하지만 그런 경우라면 suspendCoroutine 때신suspendConcellableCoroutine을 사용하는 걸 추천한다. 이는 Cancellation 챕터에서 설명할 것이다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">requestUser</span><span class="params">()</span></span>: User &#123;</span><br><span class="line"><span class="keyword">return</span> suspendCancellableCoroutine&lt;User&gt; &#123; cont -&gt;</span><br><span class="line">requestUser &#123; user -&gt;</span><br><span class="line">cont.resume(user)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>여기서 API가 데이터가 아닌 다른 문제가 발생했을 때는 어떻게 될지 궁금할 수도 있다. 서비스가 죽거나 오류를 수신할까? 위 예제에서는 데이터를 반환하지 않는다. 대신 코루틴이 일시정지한 곳에서 예외가 발생해야 한다. 예외를 받고 다시 시작한다.</p><h3 id="예외를-받은-resume"><a href="#예외를-받은-resume" class="headerlink" title="예외를 받은 resume"></a><strong>예외를 받은 resume</strong></h3><p>우리가 호출하는 모든 함수는 어떤 값을 반환하거나 예외를 던진다. suspendCoroutine도 같다. resume이 호출되면 매개변수로 데이터를 넘긴다. resumeWithException이 호출되면 매개변수로 전달된 예외가 일시정지한 지점에 개념적으로 던져진다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyException</span> : <span class="type">Throwable</span></span>(<span class="string">&quot;Just an exception&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">suspendCoroutine&lt;<span class="built_in">Unit</span>&gt; &#123; cont -&gt;</span><br><span class="line">cont.resumeWithException(MyException())</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (e: MyException) &#123;</span><br><span class="line">println(<span class="string">&quot;Caught!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Caught!</span></span><br></pre></td></tr></table></figure><p>이 매커니즘은 다른 문제에서도 쓰인다. 한 예로, 네트워크 예외 신호를 보낼 때가 있다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">requestUser</span><span class="params">()</span></span>: User &#123;</span><br><span class="line"><span class="keyword">return</span> suspendCancellableCoroutine&lt;User&gt; &#123; cont -&gt;</span><br><span class="line">requestUser &#123; resp -&gt;</span><br><span class="line"><span class="keyword">if</span> (resp.isSuccessful) &#123;</span><br><span class="line">cont.resume(resp.<span class="keyword">data</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">val</span> e = ApiException(</span><br><span class="line">resp.code,</span><br><span class="line">resp.message</span><br><span class="line">)</span><br><span class="line">cont.resumeWithException(e)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">requestNews</span><span class="params">()</span></span>: News &#123;</span><br><span class="line"><span class="keyword">return</span> suspendCancellableCoroutine&lt;News&gt; &#123; cont -&gt;</span><br><span class="line">requestNews(</span><br><span class="line">onSuccess = &#123; news -&gt; cont.resume(news) &#125;,</span><br><span class="line">onError = &#123; e -&gt; cont.resumeWithException(e) &#125;</span><br><span class="line">)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="함수가-아닌-코루틴을-일시정지하는-것"><a href="#함수가-아닌-코루틴을-일시정지하는-것" class="headerlink" title="함수가 아닌 코루틴을 일시정지하는 것"></a><strong>함수가 아닌 코루틴을 일시정지하는 것</strong></h3><p>하나 강조할 것은 함수가 아닌 코루틴을 일시정지 시킨다는 것이다. 함수를 일시정지할 수 있는 것은 코루틴이 아니라 코루틴을 일시정지할 수 있는 함수이다. 어떤 변수에 함수를 저장하는 상상를 해보아라. 그리고 함수 호출 후 다시 시작시켜라.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 정말 이렇게 짜지 마세요</span></span><br><span class="line"><span class="keyword">var</span> continuation: Continuation&lt;<span class="built_in">Unit</span>&gt;? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">suspendAndSetContinuation</span><span class="params">()</span></span> &#123;</span><br><span class="line">suspendCancellableCotouine&lt;<span class="built_in">Unit</span>&gt; &#123; cont -&gt;</span><br><span class="line">continuation = cont</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">println(<span class="string">&quot;Before&quot;</span>)</span><br><span class="line"></span><br><span class="line">suspendAndSetContinuation()</span><br><span class="line">continuation?.resume(<span class="built_in">Unit</span>)</span><br><span class="line"></span><br><span class="line">println(<span class="string">&quot;After&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Before</span></span><br></pre></td></tr></table></figure><p>이건 좀 이해가 안 된다. 이건 게임을 멈추고 이전 지점에서 재시작하는 프로세스와 동일한데도 resume이 전혀 호출되지 않는다. 출력결과에는 오직 “Before”만 보인다. 그리고 다른 스레드나 코루틴에서 resume을 호출하지 않으면 이 프로그램은 영원히 끝나지 않는다. 이를 위해 1초 후 reusme하는 다른 코루틴을 배치할 수도 있다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 정말 이렇게 짜지 마세요. 잠재적인 메모리 누수의 원인이 됩니다.</span></span><br><span class="line"><span class="keyword">var</span> continuation: Continuation&lt;<span class="built_in">Unit</span>&gt;? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">suspendAndSetContinuation</span><span class="params">()</span></span> &#123;</span><br><span class="line">suspendCancellableCotouine&lt;<span class="built_in">Unit</span>&gt; &#123; cont -&gt;</span><br><span class="line">continuation = cont</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">println(<span class="string">&quot;Before&quot;</span>)</span><br><span class="line"></span><br><span class="line">launch &#123;</span><br><span class="line">  delay(<span class="number">1000</span>)</span><br><span class="line">  continuation?.resume(<span class="built_in">Unit</span>)</span><br><span class="line">&#125;</span><br><span class="line">suspendAndSetContinuation()</span><br><span class="line">println(<span class="string">&quot;After&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Before</span></span><br><span class="line"><span class="comment">// (1 second delay)</span></span><br><span class="line"><span class="comment">// After</span></span><br></pre></td></tr></table></figure><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-8868044834754772"     crossorigin="anonymous"></script><p><ins class="adsbygoogle"     style="display:block; text-align:center;"     data-ad-layout="in-article"     data-ad-format="fluid"     data-ad-client="ca-pub-8868044834754772"     data-ad-slot="1292114373"></ins></p><script>     (adsbygoogle = window.adsbygoogle || []).push({});</script>]]></content:encoded>
      
      
      <category domain="https://dl137584.github.io/categories/Translation/">Translation</category>
      
      
      
      <comments>https://dl137584.github.io/2024/03/22/030-kotlin-coroutines-deep-dive-02/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[Android/FCM] 토큰 정책</title>
      <link>https://dl137584.github.io/2024/03/14/042-fcm-token-policy/</link>
      <guid>https://dl137584.github.io/2024/03/14/042-fcm-token-policy/</guid>
      <pubDate>Thu, 14 Mar 2024 12:03:10 GMT</pubDate>
      
        
        
      <description>&lt;h3 id=&quot;등록-토큰-변경-조건&quot;&gt;&lt;a href=&quot;#등록-토큰-변경-조건&quot; class=&quot;headerlink&quot; title=&quot;등록 토큰 변경 조건&quot;&gt;&lt;/a&gt;&lt;strong&gt;등록 토큰 변경 조건&lt;/strong&gt;&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;- 새 기기에서 </description>
        
      
      
      
      <content:encoded><![CDATA[<h3 id="등록-토큰-변경-조건"><a href="#등록-토큰-변경-조건" class="headerlink" title="등록 토큰 변경 조건"></a><strong>등록 토큰 변경 조건</strong></h3><pre><code>- 새 기기에서 앱 복원- 사용자가 앱 제거/재설치- 사용자가 앱 데이터 소거- FCM에서 기존 토큰이 만료된 후 앱이 다시 활성화(active)</code></pre><h3 id="비활성-토큰"><a href="#비활성-토큰" class="headerlink" title="비활성 토큰"></a><strong>비활성 토큰</strong></h3><p>FCM에 1개월(30일, const EXPIRATION_TIME = 1000 * 60 * 60 * 24 * 30;) 넘게 연결되지 않은 비활성(inactive) 기기와 연결된 토큰은 비활성(stale, 탁한) 토큰이다.</p><blockquote><p>비활성 등록 토큰은 FCM에 1개월 넘게 연결되지 않은 비활성 기기와 연결된 토큰입니다. 시간이 지날수록 기기가 FCM에 다시 연결될 가능성은 점점 줄어듭니다. 이러한 비활성 토큰의메시지 전송 및 주제 팬아웃은 전송되지 않을 가능성이 높습니다(are unlikely to ever be delivered.).</p></blockquote><p>문서에 이렇게 나와 있는데,</p><ul><li>“FCM에 1개월 넘게 연결되지 않은”은 ‘메세지가 마지막으로 정상전송된 이후로 1개월’을 의미하는 걸로 생각됨.</li><li>“전송되지 않을 가능성이 높다”라는 의미는 사용자가 해당 토큰과 연결된 기기(앱)를 사용하지 않아서 수신이 제대로 되지 않을 수 있음을 의미하며, (만료되었을 때처럼) FCM이 메세지전송을 막아서는 아닌 것으로 보임.</li></ul><p>단, 비활성 토큰이 270일 동안 활동이 없으면 FCM에서 만료된(expired) 토큰으로 간주한다. 이때 만료된 토큰으로는 FCM에서 유효하지 않은 것으로 표시하고 이때, 메세지 전송을거부한다. (FCM은 기기가 다시 연결되고 앱이 열리는 경우에 앱 인스턴스의 새 토큰을 발급한다.)</p><p>따라서 토큰의 유효기간은 마지막 정상전송 후로부터 최대 300일(30일 후 비활성 + 만료 유예기간 270일)로 예상된다.</p><blockquote><p>자세한 내용은 [<a href="https://firebase.google.com/docs/cloud-messaging/manage-tokens?hl=ko&authuser=0&_gl=1*gv51vk*_up*MQ..*_ga*MTg5ODUzMTQ5MS4xNzMwODU1NTU0*_ga_CW55HF8NVT*MTczMDg1NTU1NC4xLjAuMTczMDg1NTU1NC4wLjAuMA..">Firebase 문서 - FCM 등록 토큰 관리를 위한 권장사항</a>] 부문을 통해 확인할 수 있다.</p></blockquote><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-8868044834754772"     crossorigin="anonymous"></script><p><ins class="adsbygoogle"     style="display:block; text-align:center;"     data-ad-layout="in-article"     data-ad-format="fluid"     data-ad-client="ca-pub-8868044834754772"     data-ad-slot="1292114373"></ins></p><script>     (adsbygoogle = window.adsbygoogle || []).push({});</script>]]></content:encoded>
      
      
      <category domain="https://dl137584.github.io/categories/Android/">Android</category>
      
      
      
      <comments>https://dl137584.github.io/2024/03/14/042-fcm-token-policy/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[Kotlin] var / val / const val / companion object 특성</title>
      <link>https://dl137584.github.io/2023/11/20/029-kotlin-var-val-const-companion-object/</link>
      <guid>https://dl137584.github.io/2023/11/20/029-kotlin-var-val-const-companion-object/</guid>
      <pubDate>Sun, 19 Nov 2023 15:35:50 GMT</pubDate>
      
        
        
      <description>&lt;blockquote&gt;
&lt;p&gt;이 포스팅은 아래 Kotlin 공식문서의 일부를 번역(의역) + 의견을 추가한 것입니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://kotlinlang.org/docs/properties.html#compile-</description>
        
      
      
      
      <content:encoded><![CDATA[<blockquote><p>이 포스팅은 아래 Kotlin 공식문서의 일부를 번역(의역) + 의견을 추가한 것입니다.</p><ul><li><a href="https://kotlinlang.org/docs/properties.html#compile-time-constants">Kotlin 공식문서 / Properties</a></li><li><a href="https://kotlinlang.org/docs/object-declarations.html#companion-objects">Kotlin 공식문서 / Companion objects</a></li></ul></blockquote><h3 id="var-val"><a href="#var-val" class="headerlink" title="var / val"></a>var / val</h3><p>변수의 정의가 가변(mutable)하는 경우 var 키워드(variable)를 사용하고, read-only일 경우 val 키워드(value)를 사용한다. 변수의 값이 가변하는 경우가 아니다. 예를 들어, area의 값은 width와 height에 따라 변하지만 정의는 변하지 않는다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> area: <span class="built_in">Int</span> = <span class="keyword">this</span>.width * <span class="keyword">this</span>.height</span><br></pre></td></tr></table></figure><p>코틀린에서 backing field는 단지 메모리에 값을 유지하기 위해서만 사용되는 것에 불과하다. field는 직접 선언될 수 없으며 변수의 setter나 getter 내에서만 사용할 수 있다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> counter = <span class="number">0</span> <span class="comment">// initializer가 field에 직접 값을 할당한다.</span></span><br><span class="line">  <span class="keyword">set</span>(value) &#123;</span><br><span class="line">    <span class="keyword">if</span> (value &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">      field = value</span><br><span class="line">      <span class="comment">/* &#x27;counter&#x27;라는 실제 변수명을 사용하는 건</span></span><br><span class="line"><span class="comment">         setter를 다시 부르는 일이기 때문에 StackOverflow Error가 난다.</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="comment">// counter = value</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>이런 식의 암시적인 field 체계 대신 아래와 같이 backing 변수를 만들 수도 있다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">var</span> _table: Map&lt;String, <span class="built_in">Int</span>&gt;? = <span class="literal">null</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">val</span> table: Map&lt;String, <span class="built_in">Int</span>&gt;</span><br><span class="line">  <span class="keyword">get</span>() &#123;</span><br><span class="line">    <span class="keyword">if</span> (_table == <span class="literal">null</span>) &#123;</span><br><span class="line">      _table = HashMap() <span class="comment">// 여기서 파라미터의 타입이 추론된다.</span></span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">return</span> _table ?: <span class="keyword">throw</span> AssertionError(<span class="string">&quot;Set to null by another thread&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="const-val"><a href="#const-val" class="headerlink" title="const val"></a>const val</h3><p>컴파일 타임 상수이다. 다음 조건을 모두 충족시키는 경우에 해당한다.</p><ul><li>최상위 레벨 속성이거나 object나 companion object의 멤버여야 한다.</li><li>String이나 원시(primitive) 타입으로 초기화되어야 한다.</li><li>커스텀 getter를 사용할 수 없다.</li></ul><p>컴파일 시 inline 형태로 이 변수를 변수 대신 실제 값으로 대치한다. 그러나 필드가 사라지는 건 아니라서 relection으로 상호작용은 여전히 가능하다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">val</span> SUBSYSTEM_DEPRECATED: String = <span class="string">&quot;this subsystem is deprecated&quot;</span></span><br></pre></td></tr></table></figure><h3 id="companion-object-동반-객체"><a href="#companion-object-동반-객체" class="headerlink" title="companion object(동반 객체)"></a>companion object(동반 객체)</h3><p>class 내부에 object 선언은 “companion” 키워드를 써서 할 수 있다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">  <span class="keyword">companion</span> <span class="keyword">object</span> Factory &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">create</span><span class="params">()</span></span>: MyClass = MyClass()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>companion object의 멤버는 단순하게 클래스명을 통해 호출할 수 있다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> instance = MyClass.create()</span><br></pre></td></tr></table></figure><p>companion object의 이름은 빼도 되고, 이때는 Companion으로 접근한다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">  <span class="keyword">companion</span> <span class="keyword">object</span> &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">val</span> x = MyClass.Companion</span><br></pre></td></tr></table></figure><p>클래스 멤버는 companion object 내의 private 멤버에 접근할 수 있다.</p><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-8868044834754772"     crossorigin="anonymous"></script><p><ins class="adsbygoogle"     style="display:block; text-align:center;"     data-ad-layout="in-article"     data-ad-format="fluid"     data-ad-client="ca-pub-8868044834754772"     data-ad-slot="1292114373"></ins></p><script>     (adsbygoogle = window.adsbygoogle || []).push({});</script><p>-</p>]]></content:encoded>
      
      
      <category domain="https://dl137584.github.io/categories/Kotlin/">Kotlin</category>
      
      
      
      <comments>https://dl137584.github.io/2023/11/20/029-kotlin-var-val-const-companion-object/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[번역: Kotlin Coroutines: Deep Dive] (1) Kotlin Coroutines를 사용하는 이유</title>
      <link>https://dl137584.github.io/2023/11/19/028-kotlin-coroutines-deep-dive-01/</link>
      <guid>https://dl137584.github.io/2023/11/19/028-kotlin-coroutines-deep-dive-01/</guid>
      <pubDate>Sat, 18 Nov 2023 18:04:29 GMT</pubDate>
      
        
        
      <description>&lt;blockquote&gt;
&lt;p&gt;이 포스팅은 &lt;a href=&quot;https://kt.academy/book/coroutines&quot;&gt;Kotlin Coroutines: Deep Dive&lt;/a&gt;의 글을 번역한 것입니다. 오역, 많은 의역, 생략이 있으니 감안하여 읽</description>
        
      
      
      
      <content:encoded><![CDATA[<blockquote><p>이 포스팅은 <a href="https://kt.academy/book/coroutines">Kotlin Coroutines: Deep Dive</a>의 글을 번역한 것입니다. 오역, 많은 의역, 생략이 있으니 감안하여 읽어주십시오.</p></blockquote><p>우리가 Kotlin Coroutines을 배우는 이유가 무엇인가? RxJava, Reactor과 같이 이미 잘 만들어진 JVM 라이브러리가 있는데도 말이다. 더욱이 자바는 멀티스레딩을 지원한다. 즉 이미 비동기를 구현하기 위한 다양한 방법이 있다.</p><p>Kotlin Coroutines는 그것보다도 더 많은 것을 제공한다. 그 중 하나는 멀티플랫폼을 제공한다는 것이다. 즉슨 코틀린 플랫폼 사이에서 코루틴을 사용할 수 있음을 의미한다.</p><p>연습해보자. 코루틴과 다른 방법들 사이에 얼마나 차이가 있는지 보라. 아래에서는 안드로이드와 백엔드 비즈니스 로직의 두 가지 전형적인 예시를 보여줄 것이다.</p><h2 id="안드로이드-와-다른-프론트엔드-플랫폼-에서-사용하는-코루틴"><a href="#안드로이드-와-다른-프론트엔드-플랫폼-에서-사용하는-코루틴" class="headerlink" title="안드로이드(와 다른 프론트엔드 플랫폼)에서 사용하는 코루틴"></a>안드로이드(와 다른 프론트엔드 플랫폼)에서 사용하는 코루틴</h2><p>앱 로직을 수행할 때 가장 자주 진행되는 과정은 다음과 같다.</p><ul><li>API, 데이터베이스 등과 같은 소스의 데이터 가져오기</li><li>데이터 가공하기</li><li>그 데이터로 뷰에 보여주는 등의 작업 수행하기</li></ul><p>더 잘 이해하기 위해 앱을 개발하는 중이라고 가정해보자. API를 통해 뉴스 “정보를 받아와서” 이를 “정렬”하고, “화면에 보여주는” 서비스를 만들 것이다. 원하는 기능을 그대로 넣은 게 다음과 같다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">val</span> news = getNewsFromApi()</span><br><span class="line">  <span class="keyword">val</span> sortedNew = news.sortedByDescending &#123; it.publishedAt &#125;</span><br><span class="line">  view.showNews(sortedNew)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>슬프지만 이대로 끝나선 안 된다. 안드로이드에서 각 애플리케이션은 뷰를 업데이트하는 데에 단 하나의 스레드를 가지고 사용한다. 이 스레드(Main Thread)는 매우 중요하여 절대 block(차단)되어서는 안 된다. 그런데 위 코드는 이 점을 만족시키지 못한다. 만약 메인 스레드에서 실행되었다면 getNewsFromApi 는 이 스레드를 block할 것이고, 앱은 죽을 것이다. 만약 다른 스레드였다면 앱은 showNews가 호출될 때 죽을 것이다. 이 작업은 메인 스레드에서 수행되어야 하는 작업이기 때문이다.</p><h2 id="스레드-변경-switching"><a href="#스레드-변경-switching" class="headerlink" title="스레드 변경(switching)"></a>스레드 변경(switching)</h2><p>이 문제는 스레드를 변경함으로써 해결할 수 있다. 우선 block할 수 있는 스레드에서 메인 스레드로 변경하자.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">()</span></span> &#123;</span><br><span class="line">  thread &#123;</span><br><span class="line">    <span class="keyword">val</span> news = getNewsFromApi()</span><br><span class="line">    <span class="keyword">val</span> sortedNew = news.sortedByDescending &#123; it.publishedAt &#125;</span><br><span class="line">    runOnUiThread &#123;</span><br><span class="line">      view.showNews(sortedNew)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이러한 스레드 변경은 어떤 앱에서는 여전히 사용하는 방식이긴하다. 그러나 이 방식은 몇가지 문제를 안고 있다.</p><ul><li>이 스레드들을 cancel할 수 있는 방도가 없어서 종종 메모리 누수(memory leak) 상태에 직면한다.</li><li>스레드 비용이 많이 든다.</li><li>빈번한 스레드 변경은 혼란스럽고 관리를 어렵게 만든다.</li><li>이 코드는 불필요하게 크고 복잡하다.</li></ul><p>당신이 뷰를 연 후 빠르게 닫는 걸 상상해보라. 열 때 몇 개의 스레드들이 시작하며 데이터를 처리한다. 뷰를 닫았음에도 존재하지 않는 뷰를 업데이트하기 위해 이 작업을 cancel하지 않고 계속 진행하게 된다. 불필요하다는 것이다.</p><p>이러한 문제에 대해 생각해보며 더 좋은 해결책을 보도록 하자.</p><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-8868044834754772"     crossorigin="anonymous"></script><p><ins class="adsbygoogle"     style="display:block; text-align:center;"     data-ad-layout="in-article"     data-ad-format="fluid"     data-ad-client="ca-pub-8868044834754772"     data-ad-slot="1292114373"></ins></p><script>     (adsbygoogle = window.adsbygoogle || []).push({});</script><h2 id="콜백-Callbacks"><a href="#콜백-Callbacks" class="headerlink" title="콜백(Callbacks)"></a>콜백(Callbacks)</h2><p>콜백은 이 문제를 해결하는 방법 중 하나이다. 이 방식은 기능이 non-blocking하게 만든다. 그러나 콜백 함수가 끝나야만이 시작할 수 있는 작업을 수행할 때만 적용할 수 있다. 코드에 적용하면 이렇다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">()</span></span> &#123;</span><br><span class="line">  getNewsFromApi &#123; news -&gt;</span><br><span class="line">    <span class="keyword">val</span> sortedNew = news.sortedByDescending &#123; it.publishedAt &#125;</span><br><span class="line">    view.showNews(sortedNew)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>여기서 작업을 cancel 할 수 없음에 주목하라. 취소할 수 있는 콜백 함수를 만들 수도 있을 것이다. 그러나 쉽지 않다. cancel을 위해 각 콜백 함수를 커스텀해야 할 뿐만 아니라 cancel을 할 가능성이 있는 모든 객체를 별도로 수집해야 한다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">()</span></span> &#123;</span><br><span class="line">  startedCallbacks += getNewsFromApi &#123; news -&gt;</span><br><span class="line">    <span class="keyword">val</span> sortedNew = news.sortedByDescending &#123; it.publishedAt &#125;</span><br><span class="line">    view.showNews(sortedNew)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이러한 콜백 구조는 단점이 있다. 이걸 이해하기 위해 더 복잡한 예시를 보자. 세 개의 엔드포인트로부터 데이터를 가져오는 경우이다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">showNews</span><span class="params">()</span></span> &#123;</span><br><span class="line">  getConfigFromApi &#123; config -&gt;</span><br><span class="line">    getNewsFromApi(config) &#123; news -&gt;</span><br><span class="line">      getUserFromApi &#123; user -&gt;</span><br><span class="line">        view.showNews(user, news)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이 코드는 아래와 같은 이유로 완벽과는 거리가 멀다.</p><ul><li>news와 user 데이터는 사실 동시에 받아와도 된다. 그런데 지금 콜백 구조로는 그럴 수 없다.</li><li>전에 말한대로, 다른 더 많은 데이터를 불러오려고 할 때 cancel할 필요가 있다.</li><li>요구하는 게 점점 많아질수록 이 코드는 읽기 어려워질 것이다. 그러한 상황을 콜백 지옥(callback hell)이라고 부른다.</li><li>콜백을 사용할 때 작업의 순서를 제어하기 힘들다. 인디케이터를 다음과 같이 사용해도 진행도가 제대로 나타나지 않는다.  <figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">()</span></span> &#123;</span><br><span class="line">  showProgressBar()</span><br><span class="line">  showNews &#123;</span><br><span class="line">    hideProgressBar()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>이게 콜백 구조가 어떤 면에서는 완벽하지 않은 이유이다. 다른 접근방식으로 RxJava를 사용한 예를 보자.</p><h2 id="RxJava와-그밖의-reactive-streams"><a href="#RxJava와-그밖의-reactive-streams" class="headerlink" title="RxJava와 그밖의 reactive streams"></a>RxJava와 그밖의 reactive streams</h2><p>Java에서 유명한 이 대체방식은 reactive streams(또는 Reactive Extensions)를 사용한다. 즉, RxJava 또는 successor Reactor를 말한다. 이 방식으로 말할 것 같으면, 모든 동작은 시작하여(started) 진행된(processed) 관찰되어지는(observed) 데이터 스트림(일련의 작업) 내에서 일어난다. 그래서 종종 앱에서는 동시에 진행되곤 한다.</p><p>다음 코드가 RxJava를 사용한 문제 해결 방식이다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">()</span></span> &#123;</span><br><span class="line">  disposables += getNewsFromApi()</span><br><span class="line">      .subscribeOn(Schedulers.io())</span><br><span class="line">      .observeOn(AndroidSchedulers.mainThread())</span><br><span class="line">      .map &#123; news -&gt;</span><br><span class="line">        news.sortedByDescending &#123; it. publishedAt &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      .subscribe &#123; sortedNews -&gt;</span><br><span class="line">        view.showNews(sortedNews)</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위 예제에서 disposables은 사용자가 화면을 벗어났을 때 이 스트림을 cancel하기 위한 요소이다.</p><p>이는 분명 콜백보다 더 괜찮은 해결책이다. 메모리 누수가 없고, 작업 취소(cancel)를 할 수 있으며 스레드를 사용하는 데도 적절하다. 유일한 문제는 복잡하다는 것이다. 만약 맨처음 코드인 “이상적인” 코드와 비교한다면 공통점이 거의 없음을 알 수 있을 것이다.</p><p>subscribeOn, observeOn, map 그리고 subscribe라는 함수들을 모두 알아야지만 코드를 이해할 수 있다. cancelling(cancel할 수 있는 기능)은 분명 필요하다. 함수는 Observable이나 Single 클래스 안에 있는 객체를 반환해야 한다. 실제로 RxJava를 소개할 때 흔히 우리 코드를 아래와 같이 바꾼다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">getNewsFromApi</span><span class="params">()</span></span>: Single&lt;List&lt;News&gt;&gt;</span><br></pre></td></tr></table></figure><p>두 번째 문제를 생각해보자. 데이터를 화면에 보여주기 전에 세 개의 엔드포인트를 호출해야 한다. 이건 RxJava에서는 사실 풀 수 있는 문제다. 그러나 코드가 지금보다 훨씬 더 복잡해진다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">showNews</span><span class="params">()</span></span> &#123;</span><br><span class="line">  disposables += Observable.zip(</span><br><span class="line">          getNewsFromApi()</span><br><span class="line">            .flatMap &#123; getNewFromApi(it) &#125;</span><br><span class="line">            .subscribeOn(Schedulers.io()),</span><br><span class="line">          getUserFromApi()</span><br><span class="line">            .subscribeOn(Schedulers.io())</span><br><span class="line">      ) &#123; news: News, user: User -&gt;</span><br><span class="line">          Pair(news, user)</span><br><span class="line">      &#125;</span><br><span class="line">      .subscribeOn(Schedulers.io())</span><br><span class="line">      .observeOn(AndroidSchedulers.mainThread())</span><br><span class="line">      .subscribe &#123; (news, user) -&gt;</span><br><span class="line">        view.showNews((news, user))</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이 코드는 정말 메모리 누수가 없고, concurrent하다. 그러나 zip, flatMap과 같은 RxJava 함수를 넣어야 하고, Pair로 값을 묶어야 하며, 이 구조를 해제해야 한다. 이 옳은 구현은 정말 복잡하다. 그래서 이번에야말로 코루틴으로 짠 코드를 보도록 하자.</p><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-8868044834754772"     crossorigin="anonymous"></script><p><ins class="adsbygoogle"     style="display:block; text-align:center;"     data-ad-layout="in-article"     data-ad-format="fluid"     data-ad-client="ca-pub-8868044834754772"     data-ad-slot="1292114373"></ins></p><script>     (adsbygoogle = window.adsbygoogle || []).push({});</script><h2 id="코틀린-코루틴-사용하기"><a href="#코틀린-코루틴-사용하기" class="headerlink" title="코틀린 코루틴 사용하기"></a>코틀린 코루틴 사용하기</h2><p>코루틴이 소개하는 핵심 기능은 어떤 지점에서 코루틴을 suspend(일시 정지)하고 후에 다시 resume(재시작) 할 수 있다는 것이다. 이 덕분에 메인 스레드에서 코드를 run(실행)하다가 API 데이터를 요청했을 때 suspend 할 수 있다. 코루틴이 suspend 되었을 때 스레드는 block(차단)되지 않고 뷰를 바꾸거나 다른 코루틴을 진행하는 등에 계속 사용할 수 있다. 데이터가 준비되면 코루틴은 메인 스레드를 기다린다. 드문 상황이지만 코루틴 대기열이 있을 수도 있다. 기다리던 스레드를 사용할 수 있게 되면 중지된 지점부터 계속 진행한다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">updateNews</span><span class="params">()</span></span> &#123;</span><br><span class="line">  showProgressBar()</span><br><span class="line">  <span class="keyword">val</span> news = getNewsFromApi()</span><br><span class="line">  <span class="keyword">val</span> sortedNews = news.sortedByDescending &#123; it.publishedAt &#125;</span><br><span class="line">  view.showNews(sortedNews)</span><br><span class="line">  hideProgressBar()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">updateProfile</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">val</span> user = getUserData()</span><br><span class="line">  view.showUser(user)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> scope = CoroutineScope(Dispatchers.Main)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">()</span></span> &#123;</span><br><span class="line">  scope.launch &#123; updateNews() &#125;</span><br><span class="line">  scope.launch &#123; updateProfile() &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2023/11/19/028-kotlin-coroutines-deep-dive-01/028-01.jpg" alt="Kotlin Coroutine Example"></p><p>그림에서 메인 스레드에서 분리된 코루틴으로 실행되는 updateNews와 updateProfile 함수를 보자. 두 함수(또는 코루틴)는 순서가 바뀌어도 된다. 스레드를 block하지 않고 코루틴을 suspend하기 때문이다. updateNews 함수가 네트워크 응답을 기다리고 있을 때 메인 스레드는 updateProfile이 사용한다. 여기서는 사용자 데이터는 이미 캐싱되었기 때문에 getUserData에서 suspend하지 않았다고 가정한다. 그러므로 작업을 완료할 수 있다. 네트워크 응답 시간이 충분하지 않아서 데이터를 받아오는 게 늦어지면 메인 스레드는 그 시간동안 사용되지 않는다(다른 함수가 사용할 수 있다). 데이터를 받으면 메인 스레드를 가져와 getNewsFromApi() 바로 다음 지점부터 시작하여 updateNews를 resume(재개)한다.</p><p>정의에 따르면 코루틴은 suspend와 resume이 가능한 컴포넌트다. JavaScript나 Rust, Python과 같은 언어에서 볼 수 있는 async/await나 generators와 같은 개념도 코루틴을 사용하지만 그 기능은 매우 제한적이다.</p><p>그래서 첫 번째 문제점은 다음 방식으로 해결한다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">()</span></span> &#123;</span><br><span class="line">  viewModelScope.launch &#123;</span><br><span class="line">    <span class="keyword">val</span> news = getNewsFromApi()</span><br><span class="line">    <span class="keyword">val</span> sortedNews = news.sortedByDescending &#123; it.publishedAt &#125;</span><br><span class="line">    view.showNews(sortedNews)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위 코드에서 현재 안드로이드에서 가장 흔한 viewModelScope를 사용했다. 이걸 대신해서 커스텀 scope를 사용할 수도 있다.</p><p>이 코드는 우리가 원하는 것에 거의 가깝다! 이 해결책에서 코드는 메인 스레드에서 run하지만 절대 block 하진 않는다. suspend 기법 덕에 데이터를 기다릴 필요가 있을 때 해당 코루틴을 block 대신 suspend 한다. 코루틴이 일시 정지했을 때 메인 스레드는 진행도를 예쁘게 보여주는 등의 다른 일을 할 수 있다. 그리고 데이터가 준비되면 코루틴은 메인 스레드를 다시 받아 멈췄던 부분부터 다시 시작한다.</p><p>그렇다면 어떻게 세 개의 API를 호출할까? 이 또한 유사한 방식으로 만들 수 있다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">showNews</span><span class="params">()</span></span> &#123;</span><br><span class="line">  viewModelScope.launch &#123;</span><br><span class="line">    <span class="keyword">val</span> config = getCondfigFromApi()</span><br><span class="line">    <span class="keyword">val</span> news = getNewsFromApi(config)</span><br><span class="line">    <span class="keyword">val</span> user = getUserFromApi()</span><br><span class="line">    view.showNews(user, news)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이 해법은 제법 괜찮아보인다. 그러나 최선은 아니다. API 호출들을 하나가 끝나면 다음 호출을 부르듯, 순서대로 진행되고 있다. 그래서 각 작업이 1초 걸린다고 하면, 전체 함수는 2초가 아닌 3초가 걸린다. 여기서 코틀린 코루틴 라이브러리는 async와 같은 기능을 지원한다. 즉 일부 요청으로 다른 코루틴을 즉시 시작하고 (await 함수로)그 결과가 나중에 도착할 때까지 기다리는 데에 사용할 수 있다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">showNews</span><span class="params">()</span></span> &#123;</span><br><span class="line">  viewModelScope.launch &#123;</span><br><span class="line">    <span class="keyword">val</span> config = async &#123; getCondfigFromApi() &#125;</span><br><span class="line">    <span class="keyword">val</span> news = async &#123; getNewsFromApi(config.await()) &#125;</span><br><span class="line">    <span class="keyword">val</span> user = async &#123; getUserFromApi() &#125;</span><br><span class="line">    view.showNews(user.await(), news.await())</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>코드는 여전히 단순하고 가독성 있다. 이는 JavaScript나 C#에서 잘 사용되는 async/await 패턴을 이용한다. 효과적이고 메모리 누수도 없다. 단순한데다가 잘 구성되어있기까지 하다.</p><h2 id="다른-예제"><a href="#다른-예제" class="headerlink" title="다른 예제"></a>다른 예제</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 모든 페이지를 동시에 로드하기</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">showAllNews</span><span class="params">()</span></span> &#123;</span><br><span class="line">  viewModelScope.launch &#123;</span><br><span class="line">  <span class="keyword">val</span> allNews = (<span class="number">0</span> until getNumberOfPages())</span><br><span class="line">    .map &#123; page -&gt; async &#123; getNewsFromApi(page) &#125;</span><br><span class="line">    .flatMap &#123; it.await() &#125;</span><br><span class="line">  view.showAllNews(allNews)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 다름 페이지를 차례로 로드하기</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">showPagesFromFirst</span><span class="params">()</span></span> &#123;</span><br><span class="line">  viewModelScope.launch &#123;</span><br><span class="line">  <span class="keyword">for</span> (page <span class="keyword">in</span> <span class="number">0</span> until getNumberOfPages()) &#123;</span><br><span class="line">    <span class="keyword">val</span> news = getNewsFromApi(page)</span><br><span class="line">    view.showNextPage(news)</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-8868044834754772"     crossorigin="anonymous"></script><p><ins class="adsbygoogle"     style="display:block; text-align:center;"     data-ad-layout="in-article"     data-ad-format="fluid"     data-ad-client="ca-pub-8868044834754772"     data-ad-slot="1292114373"></ins></p><script>     (adsbygoogle = window.adsbygoogle || []).push({});</script>]]></content:encoded>
      
      
      <category domain="https://dl137584.github.io/categories/Translation/">Translation</category>
      
      
      
      <comments>https://dl137584.github.io/2023/11/19/028-kotlin-coroutines-deep-dive-01/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[후기] 안드로이드 뜻밖의 역사</title>
      <link>https://dl137584.github.io/2022/09/28/027-androids-the-team-that-built-the-android-operating-system/</link>
      <guid>https://dl137584.github.io/2022/09/28/027-androids-the-team-that-built-the-android-operating-system/</guid>
      <pubDate>Tue, 27 Sep 2022 16:37:54 GMT</pubDate>
      
        
        
      <description>&lt;blockquote&gt;
&lt;p&gt;이 책은 &lt;a href=&quot;https://read.amazon.com/kp/kshare?asin=B09C6RYHQ4&amp;id=mrj4eo62hvfclbvra5qanqtueq&amp;reshareId=V2N2XP2AM1ZVJH51S5SG</description>
        
      
      
      
      <content:encoded><![CDATA[<blockquote><p>이 책은 <a href="https://read.amazon.com/kp/kshare?asin=B09C6RYHQ4&id=mrj4eo62hvfclbvra5qanqtueq&reshareId=V2N2XP2AM1ZVJH51S5SG&reshareChannel=system">Androids: The Team that Built the Android Operating System</a> 전문을 번역한 책이며, 영문으로는 해당 링크에서 무료로 볼 수 있다.</p></blockquote><ul><li>Read started from 2022.08.26</li><li>출간일: 2022.08.19</li><li>저자: 쳇 하스</li><li>출판사: 인사이트</li></ul><p>-</p><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-8868044834754772"     crossorigin="anonymous"></script><p><ins class="adsbygoogle"     style="display:block; text-align:center;"     data-ad-layout="in-article"     data-ad-format="fluid"     data-ad-client="ca-pub-8868044834754772"     data-ad-slot="1292114373"></ins></p><script>     (adsbygoogle = window.adsbygoogle || []).push({});</script><blockquote><p>나는 이 책을 기술적인 세부 내용을 아는 소프트웨어/하드웨어 엔지니어 말고도 누구나 읽기를 바란다._1부 中</p></blockquote><p>책을 읽기 전 팔락팔락 넘기다가 SCSI 단어가 나오길래 비관련 종사자는 읽기 힘들거라고 생각했는데, 책을 처음부터 읽는다면 미리 설명한 사람들이 나와서 알만한 이야기를 한다. 이 책에서 나는,</p><ol><li>안드로이드 1.0을 릴리즈하기 위한 열정</li><li>안드로이드 내부 기능 각각이 탑재된 배경</li><li>안드로이드 OS가 시장에 나오기까지의 과정</li></ol><p>세 가지를 중점적으로 봤기 때문에 이런 부분을 기대한다면 읽기 불편할 것 같진 않다고 생각했다.</p><h3 id="첫-번째-열정"><a href="#첫-번째-열정" class="headerlink" title="첫 번째, 열정."></a><strong>첫 번째, 열정.</strong></h3><p>다 읽고 나면 안드로이드라는 새로운 운영 체제를 위해 함께 토론하고 결정하며 달려온 기분을 맛볼 수 있다.</p><blockquote><p>역사를 공유하고 있다는 확고한 느낌이 있었죠._1장 中</p></blockquote><p>이 책을 읽은 시기가 마침 회사에서 안드로이드 개발자로 일하면서 두 가지를 고민하던 때였다.</p><!-- 내가 여기서 '뭘 하고' 있는 거지? --><p><strong>내가 ‘왜’ 여기 있는 거지?</strong></p><p>물론 안드로이드 개발을 하고 있었으나 나는 내가 좋아해서 고른 이 직무에 관해 의구심이 생겼다.</p><!-- '안드로이드를 계속 하는 게 맞을까?' --><p><strong>‘나는 왜 안드로이드를 좋아했던 거지?’</strong></p><p>지금도 좋아하지 않는 게 아니었다. 그런데 처음 이끌렸던 이유가 기억나지 않았다. 분명히 있을 거라고 생각했고, 나는 지금까지 인생을 회고하면서 그걸 찾아보고자 했다. 그런데 이 책은 표지처럼 안드로이드의 골대를 세우고, 내부 톱니바퀴를 채우고, 외피를 덮는 공정을 밟는다. 그게 뜻밖에도 나에게 도움을 주었다.</p><p>자세한 건 여기에 적지 않겠으나, 첫 직장에서 C#을 했었고, 거기서 마음에 들었던 부분이 안드로이드에 있었다는 걸 이 책에서 안드로이드의 내부를 하나하나 짚어주는 걸 따라가면서 발견해냈던 것이다.</p><p>그런 점에서 나는 이 책을 읽기 잘했다는 마음이 들었고, 끝까지 재미있게 읽을 수 있었다.</p><h3 id="두-번째-배경"><a href="#두-번째-배경" class="headerlink" title="두 번째, 배경."></a><strong>두 번째, 배경.</strong></h3><p>안드로이드의 각 내부기능, 예를 들면 알람, 지도, 웹뷰는 물론이고 선택된 언어, 저장장치 구성, 이미지 렌더링에 관하여 코드로써 다뤄본 적이 있다면 더욱 빠져들 수 있을 것이다.</p><p>참고로, 현재 Android Developer의 <a href="https://developer.android.com/guide/platform?hl=ko">플랫폼 아키텍처</a>에서는 소프트웨어 스택(흔히 말하길 ‘안드로이드 운영체제 구조’)을 아래와 같이 그림으로 나타내고 있다.</p><p><img src="/2022/09/28/027-androids-the-team-that-built-the-android-operating-system/027-01.png" alt="Android 소프트웨어 스택"></p><p>그러나 이건 런타임이 ART(<a href="https://developer.android.com/guide/practices/verifying-apps-art.html?hl=ko">Android 5.0(API 레벨 21) 이상이 실행되는 기기의 기본 런타임</a>)로 바뀐 2022년 버전 구조이고, 이 책에서는 1.0이하를 중점적으로 다루고 있으므로 아래와 같이 런타임에 Dalvik을 사용하는 구조에 가깝다고 볼 수 있겠다.</p><p>현업 종사자라면 두 사진을 비교해보는 것도 소소한 즐거움이 되지 않을까.</p><p><img src="/2022/09/28/027-androids-the-team-that-built-the-android-operating-system/027-02.png" alt="Android 운영체제 구조"></p><p>그림 출처: <a href="https://sites.google.com/site/io/anatomy--physiology-of-an-android">Anatomy Physiology of an Android (Google IO 2008)</a></p><blockquote><p>“누군가 그걸 좋아했기 때문이 아니라 플랫폼이 성공하려면 타당했기 때문이고 팀이 거기에 적응한 거예요.”_8장 中</p></blockquote><p>의사결정 과정에 대해 다이앤이 한 말이다. 기능의 세부사항들은 모두 당시에 타당한 기준으로 선별되었고, 구성하였음을 알 수 있다.</p><p>책에서 재미있게 읽고 기억에 남았던 게 몇 가지 있다.</p><ul><li>GPU없이 렌더링되던 시절의 이야기</li><li>초기 운영체제 모델로 오른 액티비티와 main() 함수</li><li>ART 런타임으로 바뀌기 이전의 초기 런타임 형태</li><li>View의 스레드 측면 작동 방식</li></ul><p>포트 5228에 대한 내용도 잠깐 있었고 내용이 정말 알찼다. 안드로이드의 기능이나 구조를 한 번씩 언급해준다. 개인적으로 웹뷰에 대한 이야기가 길게 이어져서 좋았고, 업데이트 중 메모리 확보 및 보안을 신경쓴 부분도 자세하게 나와서 읽는 재미가 있었다.</p><p>1.0 릴리즈까지 타이트한 일정이었으나 결국 제품을 완성하여 최고의 타이밍에 출시한 안드로이드. &lt;세상을 빛낸 Geek&gt;에서는 맥의 화려함을 강조한 모양이나, 나는 &lt;안드로이드 뜻밖의 역사&gt;가 좋다.</p><p>안드로이드가 오픈 소스인 점, 앱스토어에서 사용자를 가리지 않은 점. 모두에게 열려있다는 인상, 그리고 개발자 친화적이라는 생각도 들었다.</p><p>나는 Android가 좋다:)</p><p>다음은 1부에 나오는 에번 밀러의 말을 옮긴 것이다. 이를 마지막으로 후기를 마무리하고자 한다.</p><blockquote><p>“처음부터 필연 같은 건 없었어요.<br>안드로이드가 성공하지 못할 이유는 많았죠.<br>똑같은 일을 다시 이뤄 내고 싶다고 해도 할 수 없을 거예요.<br>뭔가 마법이 벌어진 거죠.”</p></blockquote><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-8868044834754772"     crossorigin="anonymous"></script><p><ins class="adsbygoogle"     style="display:block; text-align:center;"     data-ad-layout="in-article"     data-ad-format="fluid"     data-ad-client="ca-pub-8868044834754772"     data-ad-slot="1292114373"></ins></p><script>     (adsbygoogle = window.adsbygoogle || []).push({});</script><p>-</p>]]></content:encoded>
      
      
      <category domain="https://dl137584.github.io/categories/BOOK/">/BOOK</category>
      
      
      
      <comments>https://dl137584.github.io/2022/09/28/027-androids-the-team-that-built-the-android-operating-system/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Android</title>
      <link>https://dl137584.github.io/2022/06/14/026-reading-any-awesome-article/</link>
      <guid>https://dl137584.github.io/2022/06/14/026-reading-any-awesome-article/</guid>
      <pubDate>Tue, 14 Jun 2022 14:34:05 GMT</pubDate>
      
        
        
      <description>&lt;h3 id=&quot;Microsoft-Java-11-이상으로-이동하는-이유&quot;&gt;&lt;a href=&quot;#Microsoft-Java-11-이상으로-이동하는-이유&quot; class=&quot;headerlink&quot; title=&quot;[Microsoft] Java 11 이상으로 이동하는 이유</description>
        
      
      
      
      <content:encoded><![CDATA[<h3 id="Microsoft-Java-11-이상으로-이동하는-이유"><a href="#Microsoft-Java-11-이상으로-이동하는-이유" class="headerlink" title="[Microsoft] Java 11 이상으로 이동하는 이유"></a><strong><a href="https://docs.microsoft.com/ko-kr/java/openjdk/reasons-to-move-to-java-11?toc=/azure/developer/java/fundamentals/toc.json&bc=/azure/developer/breadcrumb/toc.json">[Microsoft] Java 11 이상으로 이동하는 이유</a></strong></h3><ul><li>2022.05.20 작성됨</li></ul><p>Java 8에 대한 업데이트가 유료로 전환되어 Microsoft에서는 빠른 시일 내에 11 버전으로 옮기길 권장하고 있다.</p><p>Java 11로 업그레이드할 경우 장점으로는</p><ul><li>모듈: 메모리를 더 적게 쓰고, 클래스 로딩이 빨라진다.</li><li>GC: Java 8에서는 여러 스레드를 사용하는 병렬 GC를 사용해 속도를 높인 반면, Java 11에서는 G1 가비지 수집기를 사용해 처리량을 높였다.</li></ul><h3 id="Android-Studio-Arctic-Fox-2020-3-1"><a href="#Android-Studio-Arctic-Fox-2020-3-1" class="headerlink" title="Android Studio Arctic Fox(2020.3.1)"></a><strong>Android Studio Arctic Fox(2020.3.1)</strong></h3><ul><li>2021.07.28 <a href="https://developer.android.com/studio/archive">Download</a></li><li><a href="https://cliearl.github.io/posts/android/android-gradle-java-11/">Android Studio Arctic Fox와 JDK 11의 도입</a></li></ul><blockquote><p>An exception occurred applying plugin request [id: ‘com.android.library’]<br>Failed to apply plugin ‘com.android.internal.library’.<br>   Android Gradle plugin requires Java 11 to run. You are currently using Java 1.8.</p></blockquote><p>Arctic Fox는 JDK 11 기반으로 되어있어 Gradle도 7.0.x 버전으로 올라갔다. (기존 Android Studio 4.x는 JDK 1.8 기반) 이에 따라 에러 메세지에서는 ‘com.android.library’ 플러그인을 사용하는 데 문제가 있다고 명시해주고 있다.</p><h3 id="2022-2023년-Kotlin-팀의-계획-주요-프로젝트-및-생산성-기능"><a href="#2022-2023년-Kotlin-팀의-계획-주요-프로젝트-및-생산성-기능" class="headerlink" title="2022~2023년 Kotlin 팀의 계획: 주요 프로젝트 및 생산성 기능"></a><strong>2022~2023년 Kotlin 팀의 계획: 주요 프로젝트 및 생산성 기능</strong></h3><ul><li>2022.06.13</li><li><a href="https://blog.jetbrains.com/ko/kotlin/2022/06/what-to-expect-from-the-kotlin-team-in-202223/">JetBrains</a></li></ul><blockquote><p>2022~2023년 핵심 프로젝트는 다음과 같습니다.</p><ul><li>Kotlin 릴리스의 품질과 안정성 개선</li><li><strong>K2 컴파일러의 베타 버전</strong> 출시</li><li>Kotlin Multiplatform Mobile의 안정화 버전 출시</li><li>K2 지원 플러그인을 포함한 Kotlin IntelliJ IDEA 플러그인의 알파 버전 출시</li><li>Kotlin/JS IR 백엔드의 안정화 버전 출시</li></ul></blockquote><h3 id="2022-구글-I-O"><a href="#2022-구글-I-O" class="headerlink" title="2022 구글 I/O"></a><strong>2022 구글 I/O</strong></h3><ul><li>2022.05.12</li><li><a href="https://byline.network/2022/05/12-167/">바이라인 네트워크 - 2022 구글 I/O 키노트 총정리, 안드로이드 13, 픽셀 6a, 픽셀 워치, 픽셀 버즈 프로, 보안, 검색</a></li></ul><h3 id="안드로이드-로드맵-2022"><a href="#안드로이드-로드맵-2022" class="headerlink" title="안드로이드 로드맵 2022"></a><strong>안드로이드 로드맵 2022</strong></h3><ul><li>2022.01.21</li><li><a href="https://github.com/skydoves/android-developer-roadmap">Android Developer Roadmap 2022</a></li><li><a href="https://getstream.io/blog/android-developer-roadmap/">The 2022 Android Developer Roadmap</a></li></ul><h3 id="안드로이드-버전-점유율-statistics"><a href="#안드로이드-버전-점유율-statistics" class="headerlink" title="안드로이드 버전 점유율(statistics)"></a><strong>안드로이드 버전 점유율(statistics)</strong></h3><ul><li>2021.11.21</li><li><a href="https://9to5google.com/2021/11/22/android-2021-distribution-numbers/">android-2021-distribution-numbers</a></li><li><a href="https://developer.android.com/about/dashboards">[Android Developer] 배포 대시보드</a></li></ul><p><img src="/2022/06/14/026-reading-any-awesome-article/026-01.PNG" alt="Android Studio &gt; Create New Project"></p><h3 id="Airbnb의-Server-Driven-UI-시스템"><a href="#Airbnb의-Server-Driven-UI-시스템" class="headerlink" title="Airbnb의 Server-Driven UI 시스템"></a><strong>Airbnb의 Server-Driven UI 시스템</strong></h3><ul><li>2021.06.30</li><li><a href="https://medium.com/airbnb-engineering/a-deep-dive-into-airbnbs-server-driven-ui-system-842244c5f5">Airbnb - A Deep Dive into Airbnb’s Server-Driven UI System(en)</a></li><li><a href="https://brunch.co.kr/@advisor/37">Airbnb의 Server-Driven UI(2021.07.21)(ko)</a></li></ul><p>Ghost Platform(GP)로 안드로이드의 업데이트가 느리다는 단점을 상쇄하기 위해 UI를 SDUI로 만드는 데에 도움을 주는 플랫폼을 AirBnb에서 만들어 사용하고 있다.</p>]]></content:encoded>
      
      
      <category domain="https://dl137584.github.io/categories/ARTICLE/">/ARTICLE</category>
      
      
      
      <comments>https://dl137584.github.io/2022/06/14/026-reading-any-awesome-article/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>I&#39;m eating a book</title>
      <link>https://dl137584.github.io/2022/06/14/025-reading-a-delicious-book/</link>
      <guid>https://dl137584.github.io/2022/06/14/025-reading-a-delicious-book/</guid>
      <pubDate>Tue, 14 Jun 2022 14:28:09 GMT</pubDate>
      
        
        
      <description>&lt;h3 id=&quot;안드로이드-프로그래밍-Next-Step&quot;&gt;&lt;a href=&quot;#안드로이드-프로그래밍-Next-Step&quot; class=&quot;headerlink&quot; title=&quot;안드로이드 프로그래밍 Next Step&quot;&gt;&lt;/a&gt;&lt;strong&gt;안드로이드 프로그래밍 Nex</description>
        
      
      
      
      <content:encoded><![CDATA[<h3 id="안드로이드-프로그래밍-Next-Step"><a href="#안드로이드-프로그래밍-Next-Step" class="headerlink" title="안드로이드 프로그래밍 Next Step"></a><strong>안드로이드 프로그래밍 Next Step</strong></h3><ul><li>Read started from 2022.06.18</li><li>종이책 출간일: 2017.06.05</li><li>저자: 노재춘</li></ul><p>이게 2017년 책이라 오래 됐지만, dumpsys를 사용하는 예시를 좀 더 알고 싶어서 관련 책을 찾다가 서점에서 파라락 보고 훌쩍 사왔다. 그런데 생각지도 못하게 4, 5장에서 Context와 Task에 관해 좀 더 자세히 알게 되었다.</p><p><strong>4장 Context</strong></p><p><img src="/2022/06/14/025-reading-a-delicious-book/025-02.jpg"></p><ul><li>ContextWrapper/ContextImpl와 Activity/Service/Application에 관한 관계성</li><li>사용 가능한 Context의 차이점: Activity, getBaseContext(), getApplicationContext()</li></ul><p><strong>5장 Task 및 dumsys</strong></p><ul><li>Task에 관한 설명은 기본적인 dumpsys 사용법 설명에서 얻어걸렸다. <code>adb shell dumpsys activity a</code>라는 명령어의 매우 기다란 결과 로그 중 기본적인 키워드를 설명해준다.</li><li>Task 속성: singleTop, singleTask 등 Manifest의 launchMode 속성 및 Intent 플러그 설명이 태스크에 관한 설명과 콜라보되어 동작이 자세히 나와 있다.</li></ul><p><strong>그 외 장</strong></p><ul><li>위 명령어 말고도 dumpsys의 다양한 옵션에 대한 예시가 있어 어떤 경우에 어떤 옵션으로 명령어를 사용하면 될지 감을 잡는 데에 개인적으로 도움이 됐다.</li></ul><h3 id="실무에-바로-적용하는-안드로이드-프로그래밍"><a href="#실무에-바로-적용하는-안드로이드-프로그래밍" class="headerlink" title="실무에 바로 적용하는 안드로이드 프로그래밍"></a><strong>실무에 바로 적용하는 안드로이드 프로그래밍</strong></h3><ul><li>Read started from 2022.05.03</li><li>종이책 출간일: 2021.03.25</li><li>저자: 크리스틴 마시케노, 브라이언 가드너, 빌 필립스, 크리스 스튜어트</li></ul><p>액티비티의 생명주기를 State를 기준으로 표현한 다이어그램은 기존 <a href="https://developer.android.com/guide/components/activities/activity-lifecycle?hl=ko#alc">Android Developer</a>에 있는 것보다 훨씬 보기 좋더라.</p><p><img src="/2022/06/14/025-reading-a-delicious-book/025-01.png"></p><p>전체적으로 약간 딥한 부분까지 설명이 잘 되어있다.<br>예를 들어, onSaveInstanceState를 액티비티 레코드와 같이 설명해주거나, MVVM 뷰모델 vs Jetpack ViewModel의 차이를 설명해주는 등 상세하고 최신 내용이 잘 반영되어있다. 예제 코드가 모두 코틀린으로 되어있는 점도 그렇다.</p><p>안드로이드를 공부하는 사람이라면 기본서 다음 두 번째 책으로 적절할 것 같다. 안드로이드/자바/코틀린의 기초 문법을 설명해주지는 않아서.</p><p>이 책에는 외부 라이브러리를 사용한 예제는 테스팅 코드를 제외하고는 없다. 의존성 주입을 위한 Dagger2나 Lint 예제는 &lt;아키텍처를 알아야 앱 개발이 보인다&gt;(옥수환)에 있으니 참고 하시기.</p><h3 id="코틀린-완벽-가이드"><a href="#코틀린-완벽-가이드" class="headerlink" title="코틀린 완벽 가이드"></a><strong>코틀린 완벽 가이드</strong></h3><ul><li>Read started from 2022.04.01</li><li>종이책 출간일: 2022.03.18</li><li>저자: 알렉세이 세두노프</li></ul><p>코틀린에 대해 하나부터 열까지 상세한 코드 예제와 함께 설명이 수록되어있어 읽는데 막힘 없이 읽을 수 있어 코틀린 입문에 좋을 것으로 보인다.</p><p>구체적으로는 아래 항목이 있다.</p><ol><li>데이터 타입 다루는 법</li><li>각종 클래스의 특징</li><li>제네릭</li><li><strong>자바와의 상호 운용성</strong> (아주 친절한 설명!)</li><li>동시성</li><li>테스팅</li></ol><p>기본을 탄탄히 하는 데는 <a href="https://kotlinlang.org/docs/home.html">Kotlin Guide</a>보다 한국어라는 점에서 책을 보는 게 더 나을 것 같다. 코틀린에 관해 원하는 것은 대부분 이 책에서 얻을 수 있으리라..</p><p>덧붙여 이 책은 Kotlin 1.6을 기준으로 쓰였으며 어느 하위 버전에서 어떤 업데이트가 있었는지도 중요한 부분은 설명이 되어있다.</p>]]></content:encoded>
      
      
      <category domain="https://dl137584.github.io/categories/BOOK/">/BOOK</category>
      
      
      
      <comments>https://dl137584.github.io/2022/06/14/025-reading-a-delicious-book/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[Android / Glide] Glide 이미지 로딩 중 다른 scaleType 적용하기</title>
      <link>https://dl137584.github.io/2022/05/02/024-allow-the-different-scaletype-when-loading-image-in-glide/</link>
      <guid>https://dl137584.github.io/2022/05/02/024-allow-the-different-scaletype-when-loading-image-in-glide/</guid>
      <pubDate>Mon, 02 May 2022 12:41:14 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;Glide 동작을 테스트하면서 아래와 같은 상황이 발생하였다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;기존에 사용하던 로딩이미지의 ScaleType은 CENTER를 사용해야 한다.&lt;/li&gt;
&lt;li&gt;Glide로 로드한 이미지는 로딩이미지와는 다른 각자의 Scale</description>
        
      
      
      
      <content:encoded><![CDATA[<p>Glide 동작을 테스트하면서 아래와 같은 상황이 발생하였다.</p><ol><li>기존에 사용하던 로딩이미지의 ScaleType은 CENTER를 사용해야 한다.</li><li>Glide로 로드한 이미지는 로딩이미지와는 다른 각자의 ScaleType을 가지고 있다.</li></ol><p>따라서 loadingImage와 loadedImage의 ScaleType을 외부에서 설정만 해주면 내부에서 자동으로 바꿔서 보여주도록 만들고자 했다.</p><p>이 작업을 위해 Glide에서는 이미지 로딩 중 placeholder 노출, 리소스 로드 등의 동작을 확장 구현할 수 있도록 Target을 제공한다는 점을 먼저 말해두겠다. 이 Target은 into()를 통해 전달할 수 있다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Target&lt;Drawable&gt; target =</span><br><span class="line">  Glide.with(fragment)</span><br><span class="line">    .load(url)</span><br><span class="line">    .into(<span class="keyword">new</span> Target&lt;Drawable&gt;() &#123;</span><br><span class="line">      ...</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><p>이러한 Target를 상속받는 클래스를 만들어서 placeholder는 onLoadStarted, error는 onLoadFailed에 각각 정의하려고 한다. 이때 로딩이미지는 drawable 리소스로 앱에 저장되어있기 때문에 DrawableImageViewTarget을 상속받아 만든 게 아래와 같다.</p><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-8868044834754772"     crossorigin="anonymous"></script><p><ins class="adsbygoogle"     style="display:block; text-align:center;"     data-ad-layout="in-article"     data-ad-format="fluid"     data-ad-client="ca-pub-8868044834754772"     data-ad-slot="1292114373"></ins></p><script>     (adsbygoogle = window.adsbygoogle || []).push({});</script><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ScaleLoadingImageViewTarget</span> <span class="keyword">extends</span> <span class="title">DrawableImageViewTarget</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ImageView.ScaleType mLoadingScaleType;</span><br><span class="line">    <span class="keyword">private</span> ImageView.ScaleType mReadyScaleType;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// RequestOptions에서 정의해둔 scale은 fitCenter</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ScaleLoadingImageViewTarget</span><span class="params">(ImageView view, ImageView.ScaleType scaleType)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(view);</span><br><span class="line">        <span class="comment">// loadingCenter()에서 받아온 scale</span></span><br><span class="line">        mLoadingScaleType = scaleType;</span><br><span class="line">        <span class="comment">// xml에서 정의해둔 scale</span></span><br><span class="line">        <span class="comment">// (따로 정의되지 않았다면 여기에 RequestOptions scaleType인 fitCenter가 들어옴</span></span><br><span class="line">        mReadyScaleType = view.getScaleType();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onLoadStarted</span><span class="params">(<span class="meta">@Nullable</span> Drawable placeholder)</span> </span>&#123;</span><br><span class="line">        ImageView imageView = getView();</span><br><span class="line">        imageView.setScaleType(mLoadingScaleType);</span><br><span class="line">        <span class="keyword">super</span>.onLoadStarted(placeholder);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onLoadFailed</span><span class="params">(<span class="meta">@Nullable</span> Drawable errorDrawable)</span> </span>&#123;</span><br><span class="line">        ImageView imageView = getView();</span><br><span class="line">        imageView.setScaleType(mLoadingScaleType);</span><br><span class="line">        <span class="keyword">super</span>.onLoadFailed(errorDrawable);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResourceReady</span><span class="params">(<span class="meta">@NonNull</span> Drawable resource, <span class="meta">@Nullable</span> Transition&lt;? <span class="keyword">super</span> Drawable&gt; transition)</span> </span>&#123;</span><br><span class="line">        ImageView imageView = getView();</span><br><span class="line">imageView.setImageResource(<span class="number">0</span>); <span class="comment">// 로딩 이미지가 보여지고 있을 때 scaleType이 바뀌면서 이미지가 덜그럭 거리는 이슈 방어</span></span><br><span class="line">        imageView.setScaleType(mReadyScaleType);</span><br><span class="line">        <span class="keyword">super</span>.onResourceReady(resource, transition);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScaleLoadingImageViewTarget <span class="title">loadingCenter</span><span class="params">(ImageView imageView)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ScaleLoadingImageViewTarget(imageView, ImageView.ScaleType.CENTER);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>loadingCenter</code> 메소드를 통해 위에 새롭게 정의된 Target에 접근할 수 있도록 한다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Glide.with(context)</span><br><span class="line">    .load(url)</span><br><span class="line">    .listener(listener)</span><br><span class="line">    .apply(options)</span><br><span class="line">    .into(ScaleLoadingImageViewTarget.loadingCenter(imageView));</span><br></pre></td></tr></table></figure><blockquote><p><strong>참고링크</strong></p><ul><li><a href="https://github.com/bumptech/glide/issues/368">Allow a different scale type for placeholder images · Issue #368 · bumptech/glide</a></li></ul></blockquote><p>그러나 이 방식을 적용한 ImageView가 담긴 RecyclerView를 구현하게 되면, RecyclerView 각 아이템이 재사용되면서 ScaleLoadingImageViewTarget의 생성자에서 호출하는 <code>view.getScaleType()</code>의 값이 기대한 대로 나오지 않는 경우가 있어 문제가 될 수 있다.</p><p>따라서 이를 아래와 같이 view의 ScaleType을 명시적으로 받도록 변경하였다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Glide.with(context)</span><br><span class="line">    .load(url)</span><br><span class="line">    .listener(listener)</span><br><span class="line">    .apply(options)</span><br><span class="line">    .into(ScaleLoadingImageViewTarget.loadingCenter(imageView, ScaleType.FIT_CENTER));</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ScaleLoadingImageViewTarget</span><span class="params">(ImageView view, ImageView.ScaleType originScaleType, ImageView.ScaleType loadingScaleType)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">super</span>(view);</span><br><span class="line">  mLoadingScaleType = loadingScaleType;</span><br><span class="line">  mReadyScaleType = originScaleType;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@NonNull</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScaleLoadingImageViewTarget <span class="title">loadingCenter</span><span class="params">(ImageView imageView, ImageView.ScaleType originScaleType)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> ScaleLoadingImageViewTarget(imageView, originScaleType, ImageView.ScaleType.CENTER);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-8868044834754772"     crossorigin="anonymous"></script><p><ins class="adsbygoogle"     style="display:block; text-align:center;"     data-ad-layout="in-article"     data-ad-format="fluid"     data-ad-client="ca-pub-8868044834754772"     data-ad-slot="1292114373"></ins></p><script>     (adsbygoogle = window.adsbygoogle || []).push({});</script>]]></content:encoded>
      
      
      <category domain="https://dl137584.github.io/categories/Android/">Android</category>
      
      
      
      <comments>https://dl137584.github.io/2022/05/02/024-allow-the-different-scaletype-when-loading-image-in-glide/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[Kotlin] Ticker(티커) 모드 차이(TickerMode.FIXED_PERIOD, FIXED_DELAY)</title>
      <link>https://dl137584.github.io/2022/04/30/023-ticker-in-coroutines-library/</link>
      <guid>https://dl137584.github.io/2022/04/30/023-ticker-in-coroutines-library/</guid>
      <pubDate>Sat, 30 Apr 2022 08:12:06 GMT</pubDate>
      
        
        
      <description>&lt;blockquote&gt;
&lt;p&gt;개발 환경: Kotlin 1.6&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;coroutines 라이브러리에는 **티커(ticker)**라고 하는 특별한 랑데부 채널이 있다. 이 채널은 &lt;strong&gt;Unit 값을 계속 발생시키되</description>
        
      
      
      
      <content:encoded><![CDATA[<blockquote><p>개발 환경: Kotlin 1.6</p></blockquote><p>coroutines 라이브러리에는 **티커(ticker)**라고 하는 특별한 랑데부 채널이 있다. 이 채널은 <strong>Unit 값을 계속 발생시키되 한 원소와 다음 원소의 발생 시점이 주어진 지연 시간만큼 떨어져 있는 스트림</strong>을 만든다.</p><p>여기서 <strong>랑데부 채널</strong>이란 내부 버퍼가 없어 이 채널에서의 send() 호출은 다른 어떤 코루틴이 receive()를 호출할 때까지 항상 <strong>일시 중단</strong>된다. 마찬가지로 receive() 호출은 다른 어떤 코루틴이 send()를 호출할 때까지 일시 중단되는 특성을 가진다.<br>즉, 랑데부 채널은 생산자와 소비자 코루틴이 교대로 활성화되도록 보장한다.</p><p>티커 채널을 만들려면 ticker()라는 함수를 사용한다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> kotlinx.coroutines.*</span><br><span class="line"><span class="keyword">import</span> kotlinx.coroutines.channels.*</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line"><span class="keyword">val</span> ticker = ticker(<span class="number">100</span>) <span class="comment">// TickerMode.FIXED_PERIOD</span></span><br><span class="line">println(withTimeoutOrNull(<span class="number">50</span>) &#123; ticker.receive() &#125;)</span><br><span class="line">println(withTimeoutOrNull(<span class="number">60</span>) &#123; ticker.receive() &#125;)</span><br><span class="line">delay(<span class="number">250</span>)</span><br><span class="line">println(withTimeoutOrNull(<span class="number">1</span>) &#123; ticker.receive() &#125;)</span><br><span class="line">println(withTimeoutOrNull(<span class="number">60</span>) &#123; ticker.receive() &#125;)</span><br><span class="line">println(withTimeoutOrNull(<span class="number">60</span>) &#123; ticker.receive() &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">null</span><br><span class="line">kotlin.Unit</span><br><span class="line">kotlin.Unit</span><br><span class="line">kotlin.Unit</span><br><span class="line">null</span><br></pre></td></tr></table></figure><p><img src="/2022/04/30/023-ticker-in-coroutines-library/023-01.PNG" alt="TickerMode.FIXED_PERIOD"></p><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-8868044834754772"     crossorigin="anonymous"></script><p><ins class="adsbygoogle"     style="display:block; text-align:center;"     data-ad-layout="in-article"     data-ad-format="fluid"     data-ad-client="ca-pub-8868044834754772"     data-ad-slot="1292114373"></ins></p><script>     (adsbygoogle = window.adsbygoogle || []).push({});</script><ol><li><p>0ms ~ 50ms(타임아웃): 50ms(밀리초) 내에 티커 신호를 받으려고 시도하나, 티커 지연 시간이 100ms이므로 withTimeoutOtNull()은 신호를 받지 못하고 타임아웃이 걸려 널을 반환한다.</p></li><li><p>50ms ~ 100ms: 타임아웃이 1회 난 후 다음 60ms 안에 신호를 받으려고 시도한다. 그리고 이번에는 50 + 60ms가 100ms 보다 길기 때문에 결괏값을 얻는다. receive()가 호출되면 티커가 재개된다.</p><p> 2_1. 100ms ~ 350ms: 이때 소비자 코루틴이 약 250ms 동안 일시 중단된다. 일시 중단으로부터 <strong>100ms 후에 티커는 다른 신호를 보내고 신호가 수신될 때까지 일시 중단된다.</strong> 그리고 소비자 코루틴과 티커 코루틴 모두 150ms 동안 일시 중단 상태로 남는다.</p></li><li><p>350ms: 소비자 코루틴이 재개되고 신호를 요청하려고 시도한다. 신호가 이미 보내졌기 때문에 receive()는 즉시 결과를 반환한다.</p><p> 3_1. 이제 티커는 마지막 신호를 보내고 나서 얼마나 시간이 지났는지 검사하고(250ms), <strong>지연 시간을 50ms로 줄인다.</strong></p></li><li><p>350ms ~ 400ms: 소비자는 50ms 타임아웃 안에 신호를 받으려고 시도한다. 다음 신호가 50ms 이전에 보내졌기 때문에 이 시도는 거의 확실히 성공할 것이다.</p></li><li><p>400ms ~ 460ms(타임아웃): 마지막으로, 신호를 받으려는 receive() 호출이 거의 즉시 일어난다. 따라서 티커는 전체 지연 시간(100ms)를 다시 기다린다. 그 결과, 마지막 receive() 호출은 60ms 타임아웃 안에 티커로부터 신호를 받지 못하기 때문에 널을 받는다.</p></li></ol><p>티커 모드를 FIXED_DELAY로 고정하면 결과가 다음과 같이 바뀐다.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">null</span><br><span class="line">kotlin.Unit</span><br><span class="line">kotlin.Unit</span><br><span class="line">null</span><br><span class="line">kotlin.Unit</span><br></pre></td></tr></table></figure><p><img src="/2022/04/30/023-ticker-in-coroutines-library/023-02.PNG" alt="TickerMode.FIXED_DELAY"></p><p>초반부는 앞의 예제와 비슷하게 진행된다. 하지만 250밀리초의 긴 지연 이후 소비자 코루틴이 재개될 때부터는 동작이 달라진다.</p><ol start="3"><li><p>350ms: 소비자 코루틴이 재개되고 신호를 요청하려고 시도한다. 신호가 이미 보내졌기 때문에 receive()는 즉시 결과를 반환한다.</p><p> 3_1. receive()로 결과를 넘긴 시점에서 티커는 <strong>현재시간을 고려하지 않고 여기서부터 100ms를 다시 기다린다.</strong></p></li><li><p>350ms ~ 410ms(타임아웃): 티커가 신호를 보내려면 40ms 남았으므로 널을 받는다.</p></li><li><p>410ms ~ 450ms: 3_1에서 티커가 재개된 시간으로부터 100ms가 지났으므로 결과를 무사히 반환받는다.</p></li></ol><blockquote><p><b>참고</b><br>알렉세이 세두노프 &lt;코틀린 완벽 가이드&gt;</p></blockquote><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-8868044834754772"     crossorigin="anonymous"></script><p><ins class="adsbygoogle"     style="display:block; text-align:center;"     data-ad-layout="in-article"     data-ad-format="fluid"     data-ad-client="ca-pub-8868044834754772"     data-ad-slot="1292114373"></ins></p><script>     (adsbygoogle = window.adsbygoogle || []).push({});</script>]]></content:encoded>
      
      
      <category domain="https://dl137584.github.io/categories/Kotlin/">Kotlin</category>
      
      
      
      <comments>https://dl137584.github.io/2022/04/30/023-ticker-in-coroutines-library/#disqus_thread</comments>
      
    </item>
    
  </channel>
</rss>
