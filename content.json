{"pages":[],"posts":[{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2022/01/31/hello-world/"},{"title":"[And] JCenter 지원종료","text":"현재 상황(2021년 후반)[Gradle] JCenter shutdown impact on Gradle builds에 따르면 JFrog에서 아래와 같이 공지했다고 한다. JCenter는 read-only로 계속 제공될 것이나 더이상 새로운 버전의 패키지는 받을 수 없다. 모든 Bintray 서비스(JCenter에 배포하기 위한 플랫폼는 중지되었다. JCenter 지원중단 시 상황(2021년 초중반) 지원종료공지요약 (공지원문) JFrog에서 운영하는 JCenter, GoCenter 및 ChartCenter가 운영을 중지할 예정이다. 2021년 2월 28일 : GoCenter, ChartCenter에 라이브러리 등록 서비스 중지 2021년 3월 31일 : JCenter에 라이브러리 등록 서비스 중지 2021년 5월 1일 : GoCenter, ChartCenter에서 라이브러리 다운로드 서비스 중지 2022년 2월 1일 : JCenter에서 라이브러리 다운로드 서비스 중지 이유는 위의 요약링크에서 토론에서 말하기를 ExoPlayer의 issue에서 언급되기를, JCenter에서 악성코드가 포함된 라이브러리 패키지가 등록된 사고가 있었다고 하며, 이러한 사고방지 대책을 세우지 못하고 서비스를 닫는 것으로 보인다. 안드로이드 라이브러리는 JCenter에 의존한 게 많은데 따라서 대책을 세워야 한다. JCenter는 아래와 같이 레포지토리에 등록되어있다. 123456repositories { google() mavenCentral() jcenter() maven { url 'https://maven.fabric.io/public' }} 또한 이 JCenter 지원 종료에 대한 안드로이드 공식 입장은 다음과 같다. 2022년 2월 1일까지 JCenter에서 기존 아티팩트를 다운로드할 수 있습니다. - 공식 문서 이에 관하여 추후에 또다른 공지가 올라올 예정이다.","link":"/2022/01/31/002-JCenter-%EC%A7%80%EC%9B%90%EC%A2%85%EB%A3%8C/"},{"title":"[And] 웹뷰에서 동작하는 페이스북 로그인이 deprecated됨","text":"1. 공지 전문 (1) 관련 문의 및 공식답변 링크 안녕하세요 철구 님, 자세한 내용에 감사드립니다.로그 파일에서 ‘PLATFORM__LOGIN_DISABLED_FROM_WEBVIEW_OLD_SDK_VERSION’ 오류 코드를 확인할 수 있습니다. Android 웹뷰를 통한 Facebook 로그인(https://developers.facebook.com/blog/post/2021/06/28/deprecating-support-fb-login-authentication-android-embedded-browsers/)이 중단되었기 때문에 발생한 것으로 보입니다.대신 이 링크를 통해 사용자 지정 탭을 적용하는 자세한 지침을 확인할 수 있습니다.만약 문제가 지속된다면 사용 중인 SDK 버전과 영어로 표시된 오류 메시지 스크린숏과 함께 오류를 재현할 수 있도록 샘플 프로젝트를 제공 부탁드립니다.감사합니다. 2. 공식 해결 가이드(1) 페이스북 SDK 버전이 8.2 이상인지 확인1implementation 'com.facebook.android:facebook-android=sdk:8.2.0' (2) 수정사항앱 내부 웹뷰가 아닌 외부 브라우저를 통해 페이스북 로그인 진행하도록 변경 2021년 10월 5일부터 Facebook 로그인은 사용자 로그인에 Android 내장 브라우저(WebView) 사용을 더 이상 지원하지 않습니다. 사용자 경험이 중단되지 않도록 하려면 다음 체크리스트를 사용하여 대신 사용자 지정 탭을 사용하십시오. 3. 결론웹뷰를 통해 페이스북 로그인 페이지에 접근하면 안 되며, 외부 브라우저를 띄워 페이스북 로그인 페이지에 접근하도록 수정해야 한다.","link":"/2022/02/01/003-%EC%9B%B9%EB%B7%B0%EC%97%90%EC%84%9C-%EB%8F%99%EC%9E%91%ED%95%98%EB%8A%94-%ED%8E%98%EC%9D%B4%EC%8A%A4%EB%B6%81-%EB%A1%9C%EA%B7%B8%EC%9D%B8%EC%9D%B4-deprecated%EB%90%A8/"},{"title":"[And] Glide에서 비트맵 이미지가 GC되는 과정","text":"개요위의 공식 문서에서 나와있는 바와 같이 기본적으로 Glide로 비트맵을 관리하는 걸 추천하고 있다. 이를 관리해줘야 하는 이유는 다음과 같다. 앱에서 대량의 비트맵 데이터를 표시하면 OutOfMemoryError 오류가 발생할 수 있습니다. OutOfMemory 오류를 방지하기 위하여 안드로이드에서는 recycle() 기능을 제공하는데, 이 메소드를 실행하면 비트맵에 사용한 메모리를 회수할 수 있다. 즉, 이 메소드를 호출함으로써 해당 비트맵은 GC의 대상이 된다. 당연히 해당 비트맵을 더이상 사용하지 않을 거라고 확정된 시점에 호출해야한다. Glide는 비트맵의 메모리를 어떻게 관리하고 있는가?위와 같은 방법으로 오류를 해결하긴 했으나 정확히 Glide에서 Bitmap의 메모리 관리를 어떻게 하는지 감이 안 잡혔더랬다. 그래서 참고삼아 다음 내용을 같이 살펴보면 좋을 것 같다. 잘 살펴보면 위의 오류 내용을 담은 스샷에서 LruResourceCache 와 같은 단어를 볼 수 있다. 메모리 캐시 vs 디스크 캐시 의 내용에 따르면 비트맵 캐싱은 LruCache를 사용하는 대표적인 예다. 여기서 힌트를 얻어서 Glide를 적용하면서 설정했던 BitmapPool 사이즈 디폴트값을 보자. 관련 코드는 다음과 같다. 123// 비트맵 풀: The default size is based on the screen size and density of the deviceint bitmapPoolSizeBytes = 1024 * 1024 * 30; // 30mbbuilder.setBitmapPool(new LruBitmapPool(bitmapPoolSizeBytes)); BitmapPool 사이즈는 단말의 스크린사이즈와 density 값에 따라 달라진다고 나와있다. Glide에서 Bitmap의 라이프사이클 링크Glide에서 비트맵을 관리하는 데에 있어 일반적인 생명주기는 다음과 같다. InputStream -&gt; Bitmap -&gt; View -&gt; Memory Cache -&gt; Bitmap Pool -&gt; Recycle 해당 링크 해석본비트맵은 메모리 캐시 또는 BitmapPool에서 View(또는 target) 및 Loop로 이동할 수도 있습니다. 디코딩 파이프 라인 (예 : 변환을 통해) 중에 리소스를 수동으로 재활용하는 경우 비트맵이 표시되지 않고 recycled state가 될 수도 있습니다. 그렇지 않으면 비트맵이 크기 제약으로 인해 제거될 때 메모리 캐시에서 BitmapPool로, BitmapPool에서 recycled state로 이동합니다. “Cannot obtain size for recycled Bitmap” 오류는 Recycle state에 도달한 비트맵을 그리려고 할 때 발생합니다. 결코 발생해서는 안되지만 다음과 같은 몇 가지 시나리오에서 발생할 수 있습니다. 변환 중에 디코딩 프로세스 중에 비트맵을 수동으로 recycle할 경우 이 원인은 일반적이지 않은 브랜치에서 커스텀 변환을 하지 않는 한 이런 상황을 꽤 자주 볼 수 있습니다. 디코딩 프로세스 중, 변환 중에 두 번 이상 Pool에 비트맵을 반환한 경우 이 경우 문제의 원인을 파악하기 쉽습니다. 비트맵이 Pool에서 제거되지 않고 Pool에 여러 번 추가되면 다른 이미지가 동시에 표시되어, 두 개의 이미지 중 하나는 올바르게 표시되고 다른 하나는 잘못 표시 될 수 있습니다. 게다가 다른 뷰에서 참조하는 동안 동시에 recycle 될 수도 있습니다. onLoadCleared가 호출된 후에도 계속 리소스를 참조하거나, 또는 해당 Target이 지워진 후 Target에 로드된 리소스를 참조한 경우 커스텀 target을 사용하는 경우 발생할 수 있습니다. 안타깝게도 비트맵을 추적하기 위해 수동 참조 계산을 수행해야하므로 이러한 종류의 버그를 추적하는 것이 매우 어려울 수 있습니다.BitmapPool의 크기를 크게 줄이거나 BitmapPoolAdapter를 사용하여 충돌이 더 자주 발생하는지 확인하십시오. 메모리 캐시의 크기를 줄일 수도 있습니다. 두 경우 모두 파이프 라인의 길이를 줄입니다. 이는 Bitmap이 Recycled state에 더 빨리 도달하여 오류가 더 자주 발생할 수 있음을 의미합니다. 또한 비트맵 렌더링 오류, 기록 된 GL 경고 또는 다른 이미지 대신 잘못된 이미지가 나타나는지 주시하십시오. 이 모든 것은 버그를 재현한 신호입니다. 결론따라서 Glide는 변환된 Bitmap을 내부적으로 recycle하기 때문에 imageView.setRecycler()하지 않아도 된다.","link":"/2022/02/01/004-Glide%EC%97%90%EC%84%9C-%EB%B9%84%ED%8A%B8%EB%A7%B5-%EC%9D%B4%EB%AF%B8%EC%A7%80%EA%B0%80-GC%EB%90%98%EB%8A%94-%EA%B3%BC%EC%A0%95/"}],"tags":[],"categories":[{"name":"Android","slug":"Android","link":"/categories/Android/"}]}