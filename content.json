{"pages":[{"title":"About LEEJS","text":"Email: dl137584@gmail.com 룰루랄라","link":"/about/index.html"}],"posts":[{"title":"[Android] 웹뷰에서 동작하는 페이스북 로그인이 deprecated됨","text":"1. 공지 전문 (1) 관련 문의 및 공식답변 링크 안녕하세요 철구 님, 자세한 내용에 감사드립니다.로그 파일에서 ‘PLATFORM__LOGIN_DISABLED_FROM_WEBVIEW_OLD_SDK_VERSION’ 오류 코드를 확인할 수 있습니다. Android 웹뷰를 통한 Facebook 로그인(https://developers.facebook.com/blog/post/2021/06/28/deprecating-support-fb-login-authentication-android-embedded-browsers/)이 중단되었기 때문에 발생한 것으로 보입니다.대신 이 링크를 통해 사용자 지정 탭을 적용하는 자세한 지침을 확인할 수 있습니다.만약 문제가 지속된다면 사용 중인 SDK 버전과 영어로 표시된 오류 메시지 스크린숏과 함께 오류를 재현할 수 있도록 샘플 프로젝트를 제공 부탁드립니다.감사합니다. 2. 공식 해결 가이드(1) 페이스북 SDK 버전이 8.2 이상인지 확인1implementation 'com.facebook.android:facebook-android=sdk:8.2.0' (2) 수정사항앱 내부 웹뷰가 아닌 외부 브라우저를 통해 페이스북 로그인 진행하도록 변경 2021년 10월 5일부터 Facebook 로그인은 사용자 로그인에 Android 내장 브라우저(WebView) 사용을 더 이상 지원하지 않습니다. 사용자 경험이 중단되지 않도록 하려면 다음 체크리스트를 사용하여 대신 사용자 지정 탭을 사용하십시오. 3. 결론웹뷰를 통해 페이스북 로그인 페이지에 접근하면 안 되며, 외부 브라우저를 띄워 페이스북 로그인 페이지에 접근하도록 수정해야 한다. (adsbygoogle = window.adsbygoogle || []).push({});","link":"/2022/02/01/003-deprecated-facebook-login-in-android/"},{"title":"[Android] JCenter 지원종료","text":"현재 상황(2021년 후반)[Gradle] JCenter shutdown impact on Gradle builds에 따르면 JFrog에서 아래와 같이 공지했다고 한다. JCenter는 read-only로 계속 제공될 것이나 더이상 새로운 버전의 패키지는 받을 수 없다. 모든 Bintray 서비스(JCenter에 배포하기 위한 플랫폼)는 중지되었다. 따라서 JCenter에서 기존에 있던 외부 라이브러리에 대한 정보는 계속 제공되기 때문에 현재 상황에서 바로 대응할 부분은 없을 것이다. 다만, 안드로이드 앱의 경우 build.gradle에 의존성을 추가한 외부 라이브러리의 버전 업데이트를 할 때 그 상위 버전이 JCenter에 업데이트 되어있지 않을테니 그때 해당 라이브러리 버전에 맞는 classpath를 추가하면 될 것으로 보인다. (adsbygoogle = window.adsbygoogle || []).push({}); JCenter 지원중단 시 상황(2021년 초중반) 지원종료공지요약 (공지원문) JFrog에서 운영하는 JCenter, GoCenter 및 ChartCenter가 운영을 중지할 예정이다. 2021년 2월 28일 : GoCenter, ChartCenter에 라이브러리 등록 서비스 중지 2021년 3월 31일 : JCenter에 라이브러리 등록 서비스 중지 2021년 5월 1일 : GoCenter, ChartCenter에서 라이브러리 다운로드 서비스 중지 2022년 2월 1일 : JCenter에서 라이브러리 다운로드 서비스 중지 이유는 위의 요약링크에서 토론에서 말하기를 ExoPlayer의 issue에서 언급되기를, JCenter에서 악성코드가 포함된 라이브러리 패키지가 등록된 사고가 있었다고 하며, 이러한 사고방지 대책을 세우지 못하고 서비스를 닫는 것으로 보인다. 안드로이드 라이브러리는 JCenter에 의존한 게 많은데 따라서 대책을 세워야 한다. JCenter는 아래와 같이 레포지토리에 등록되어있다. 123456repositories { google() mavenCentral() jcenter() maven { url 'https://maven.fabric.io/public' }} 또한 이 JCenter 지원 종료에 대한 안드로이드 공식 입장은 다음과 같다. 2022년 2월 1일까지 JCenter에서 기존 아티팩트를 다운로드할 수 있습니다. - 공식 문서 이에 관하여 추후에 또다른 공지가 올라올 예정이다.","link":"/2022/01/31/002-jcenter-shutdown/"},{"title":"[Android] Glide에서 비트맵 이미지가 GC되는 과정","text":"개요위의 공식 문서에서 나와있는 바와 같이 기본적으로 Glide로 비트맵을 관리하는 걸 추천하고 있다. 이를 관리해줘야 하는 이유는 다음과 같다. 앱에서 대량의 비트맵 데이터를 표시하면 OutOfMemoryError 오류가 발생할 수 있습니다. OutOfMemory 오류를 방지하기 위하여 안드로이드에서는 recycle() 기능을 제공하는데, 이 메소드를 실행하면 비트맵에 사용한 메모리를 회수할 수 있다. 즉, 이 메소드를 호출함으로써 해당 비트맵은 GC의 대상이 된다. 당연히 해당 비트맵을 더이상 사용하지 않을 거라고 확정된 시점에 호출해야한다. (adsbygoogle = window.adsbygoogle || []).push({}); Glide는 비트맵의 메모리를 어떻게 관리하고 있는가?메모리 캐시 vs 디스크 캐시 의 내용에 따르면 비트맵 캐싱은 LruCache를 사용하는 대표적인 예다. 여기서 힌트를 얻어서 Glide를 적용하면서 설정했던 BitmapPool 사이즈 디폴트값을 보자. 관련 코드는 다음과 같다. 123// 비트맵 풀: The default size is based on the screen size and density of the deviceint bitmapPoolSizeBytes = 1024 * 1024 * 30; // 30mbbuilder.setBitmapPool(new LruBitmapPool(bitmapPoolSizeBytes)); BitmapPool 사이즈는 단말의 스크린사이즈와 density 값에 따라 달라진다고 나와있다. Glide에서 비트맵의 라이프사이클 링크Glide에서 비트맵을 관리하는 데에 있어 일반적인 생명주기는 다음과 같다. InputStream -&gt; Bitmap -&gt; View -&gt; Memory Cache -&gt; Bitmap Pool -&gt; Recycle 해당 링크 해석본비트맵은 메모리 캐시 또는 BitmapPool에서 View(또는 target) 및 Loop로 이동할 수도 있습니다. 디코딩 파이프 라인 (예 : 변환을 통해) 중에 리소스를 수동으로 재활용하는 경우 비트맵이 표시되지 않고 recycled state가 될 수도 있습니다. 그렇지 않으면 비트맵이 크기 제약으로 인해 제거될 때 메모리 캐시에서 BitmapPool로, BitmapPool에서 recycled state로 이동합니다. “Cannot obtain size for recycled Bitmap” 오류는 Recycle state에 도달한 비트맵을 그리려고 할 때 발생합니다. 결코 발생해서는 안되지만 다음과 같은 몇 가지 시나리오에서 발생할 수 있습니다. 변환 중에 디코딩 프로세스 중에 비트맵을 수동으로 recycle할 경우 이 원인은 일반적이지 않은 브랜치에서 커스텀 변환을 하지 않는 한 이런 상황을 꽤 자주 볼 수 있습니다. 디코딩 프로세스 중, 변환 중에 두 번 이상 Pool에 비트맵을 반환한 경우 이 경우 문제의 원인을 파악하기 쉽습니다. 비트맵이 Pool에서 제거되지 않고 Pool에 여러 번 추가되면 다른 이미지가 동시에 표시되어, 두 개의 이미지 중 하나는 올바르게 표시되고 다른 하나는 잘못 표시 될 수 있습니다. 게다가 다른 뷰에서 참조하는 동안 동시에 recycle 될 수도 있습니다. onLoadCleared가 호출된 후에도 계속 리소스를 참조하거나, 또는 해당 Target이 지워진 후 Target에 로드된 리소스를 참조한 경우 커스텀 target을 사용하는 경우 발생할 수 있습니다. 안타깝게도 비트맵을 추적하기 위해 수동 참조 계산을 수행해야하므로 이러한 종류의 버그를 추적하는 것이 매우 어려울 수 있습니다.BitmapPool의 크기를 크게 줄이거나 BitmapPoolAdapter를 사용하여 충돌이 더 자주 발생하는지 확인하십시오. 메모리 캐시의 크기를 줄일 수도 있습니다. 두 경우 모두 파이프 라인의 길이를 줄입니다. 이는 Bitmap이 Recycled state에 더 빨리 도달하여 오류가 더 자주 발생할 수 있음을 의미합니다. 또한 비트맵 렌더링 오류, 기록 된 GL 경고 또는 다른 이미지 대신 잘못된 이미지가 나타나는지 주시하십시오. 이 모든 것은 버그를 재현한 신호입니다. 결론따라서 Glide는 변환된 Bitmap을 내부적으로 recycle하기 때문에 imageView.setRecycler()하지 않아도 된다.","link":"/2022/02/01/004-the-way-bitmap-gc-in-glide/"},{"title":"기술 블로그 만들기 - Github-pages, Hexo","text":"1. 노션을 사용하는 것에 대한 불편함 참고: 링크 (1) 노션의 단점 읽기 어려운 URL + 제목을 수정하면 같이 변경되는 URL → 해보니 Hexo도 비슷한 이슈가 있음. 하지만 노션이 공유하기 어려운 것도 사실임.. 블로그로서 만들기가 어려움. 페이지 로딩이 느림 → Hexo는 기본적으로 정적사이트를 생성해주기 때문에 이 부분은 해결이 됨. 정적 웹사이트란, 서버에서 배포하기 전까지는 이미 올려진 데이터만을 보여주기 때문에 페이지 내에서 글 수정이 불가능하며 그렇기 때문에 가볍다는 장점이 있다. 페이지를 로드한 후에는 서버와 통신할 필요가 없으니까. 덧붙여, 목차를 한 눈에 볼 수 없음. → Hexo(이카루스 테마)로 해보니 목차(toc)를 노출시킬 수 있게됨. 사이드바에 노출하여 사이드바를 고정(sticky)시켜두니 정말 편해졌다. 목차를 만들었을 때 그 목차 지점으로 가는 URL을 생성할 수 없음. → 목차(toc)를 노출시킬 경우 URL에 앵커(#)으로 어떤 제목으로 가는 링크가 제공됨. https://dl137584.github.io/2022/02/01/004-the-way-bitmap-gc-in-glide/#Glide는-비트맵의-메모리를-어떻게-관리하고-있는가 방문자 통계를 내기 어려움. → Google Analytics 사용하여 통계낼 수 있게 됨. (2) 대체 플랫폼 Notion + Cloudflare Tistory Velog Github-pages → 내가 지금까지 해본 건 Tistory/Notion(오직 노션)/Github(레포지토리를 DB 삼아 md 파일 만듦. 사이트를 따로 생성하지 않음.)/Jekyll(페이지 껍데기만 만듦)/OneNote/EverNote 였다. 그 중 고유한 Url을 생성할 수 있고 디자인을 코드단으로 만질 수 있는 Jekyll이 제일 재밌었는데 그래서 Github-pages를 사용하기로 함. 단, Jekyll은 제외하고.(왠지 한 번 만들고 실패해서 손이 안 감.) (3) Github-pages 적용에 필요한 것 정적 사이트 생성기(Static Site Generator): Jekyll(ruby), Hugo(Go), Hexo(Node.js), Gatsby 등 정적 웹 사이트 생성기: DB 통신 등을 해서 서버에서 HTML 페이지를 실시간으로 만들던 동적 사이트 방식이 아닌, 완성된 HTML 파일을 바로 전달. 고민은 길지 않았다. 서버 문외한인 내가 가장 많이 들어본 Node.js 기반 Hexo를 사용하기로 결정했다. (4) Hexo 적용 후 불편했던 점하는 김에 hexo를 이용하면서 불편했던 점도 적어봄. 위에 나열된 노션의 단점은 모두 커버되었으나 일부 사용하기 어려운 점이 있었다. 페이지를 업데이트하려면 코드를 수정해서 배포해야하기 때문에 바로 수정된 걸 볼 수 없다.(hexo에서 제공하는 draft 기능을 사용하는 데에도 동일한 문제있음) → 노션의 이용을 병행하여 draft(초안)은 노션에 작성하기로 함. (일단 나는 편해짐.) 여러 PC에서 배포를 할 수 있는 수월한 방법을 찾지 못함. 방법(링크)은 찾았는데 기존 .deploy_git을 다른 PC에 동기화해줘야(동일하게 옮겨줘야) 하는 번거로움때문에 시도 안 하는 중.. Github에 올린 코드를 받아서 hexo-cli만 설치하여 올리려고 보니 hexo server 명령어가 기능을 잘 안 하고(기존 작업하던 PC OS는 윈도우, 새로 시도한 PC는 맥), 커밋 안 한 다른 PC에서 수정하던 게 마음에 걸려서 골치아파지더라. 목차 생성 시 h1 아래에 h2가 아닌 h3으로 하위헤더를 바로 생성할 경우, 아래 이미지와 같이 일부가 생략된다. (5) 노션의 장점노션의 이용을 병행하려고 보니 장점을 빼놓을 수가 없다. 접근성이 좋다. 웹, 앱 어디서든 편집할 수 있다. 동기화가 잘 된다. 엄청 잘 된다! 처음 노션을 고른 이유가 동기화였다. 편리한 단축키. ctrl + x로 한 행을 삭제하거나 슬래시(/)로 페이지를 만들 수 있게 하거나 여러가지로 잘 사용중. 편집이 편하고 예쁘다! (잘 쓰진 않지만 수정된 내용은 히스토리로 남아서 혹시모를 상황에 대비가 가능하다.) 드래그앤드랍으로 행 옮기거나 블록처리 가능한 점. 어디서든 특정 부분을 하이라이트 하기 좋음. md는 코드 내에서는 볼드체가 불가능하거나 불편한 점이 있음. 이것도 따로 방법을 찾아봐야 할듯. 폰트가 읽기 좋음. md는 바꾸기 귀찮아서 디폴트로 사용중인데 영어는 거의 잘 나오는데 PC에서 한국어가 픽셀 깨지듯이(예민) 나옴. 헤더를 만들었을 때 딱 읽기 좋은 형태로(상하단 여백, 텍스트 강조) 노출됨. md는 가끔 h1 쓰는데도 읽으면서 가독성 떨어져서 일일이 bold 넣어줘야함. (adsbygoogle = window.adsbygoogle || []).push({}); 2. Hexo 환경설정 Hexo Guide link (1) node.js 및 npm 버전 확인내 경우 React.js 시작하기 에서 node.js와 npm이 설치된 상태여서 Hexo에 필요한 버전만 확인했다. Mac에서 node.js 및 npm설치 homebrew는 Mac에서 패키지 관리를 용이하게 하기 위한 툴이다. 이걸 먼저 설치. 1/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot; 그리고 node.js를 설치하면 npm도 함께 설치되기 때문에 아래 명령어로 node.js를 설치. 1brew install node 1234&gt; node -vv14.15.5&gt; npm -v6.14.11 Hexo를 사용하기 위해서는 node.js는 v12이상을 권하고 있다.(최소 v10.13) (2) Hexo 설치1&gt; npm install -g hexo-cli (3) Hexo 초기화1&gt; hexo init testBlog 위 명령어로 초기화하면 아래와 같은 파일구조로 기본 설정파일들이 생성된다. (4) 파일구조12345678.├── _config.yml├── package.json├── scaffolds├── source| ├── _drafts| └── _posts└── themes _config.yml: 환경설정(사이트 설정;웹사이트 제목, URL 설정, include 설정 등 가능) package.json: 데이터 파일. EJS, Stylus, Markdown 렌더러들은 기본으로 설치됨. scaffolds: 새 포스트/페이지를 생성했을 때 기본으로 만들어질 레이아웃을 정의. (5) 명령어 서버 실행: hexo s (server) 정적파일 생성: hexo g (generate, public/이 생성된다.) 배포: hexo d (deploy) 생성 및 배포: hexo d -g (hexo deploy -generate) 클린: hexo clean (public/이 삭제된다.) 커맨드라인에서 hexo clean을 하게되면 마지막 INFO에 아래와 같이 뜨는 것을 볼 수 있다. 즉, DB와 public 폴더가 초기화된다. 123INFO === Registering Hexo extensions ===INFO Deleted database.INFO Deleted public folder. 3. 커스텀(1) 사이드바_config.icarus.yml 편집 4. 포스팅 - 이카루스 테마(icarus theme) 사용 밍피디 링크 (1) 새 포스트 생성흔히 알고 있는 하나의 포스팅을 쓸 때 사용한다. 1hexo new post &quot;title&quot; (2) 이미지 폴더 생성 주의 1. 파일명은 대소구분을 한다. “png”와 “PNG”는 다르다. 2. 아래 방법으로 하게되면 hexo clean 명령어 사용 시 public/아래의 파일은 날아가므로 여기에 파일을 넣지 않도록 할 것. _config.yml에서 post_asset_folder 속성을 true로 바꾼다. 포스트 생성 시(hexo new post) 포스트의 제목과 같은 폴더가 자동으로 생성될텐데 여기에 이미지 파일을 넣는다. 이렇게 되면 ![](/2022/02/04/006-create-personal-blog-with-githubpages-and-hexo/006-02.png)와 같이 접근할 수 있다. 내 경우 _config.yml에서 permalink를 “:year/:month/:day/:title/“로 해두어 저렇게 나온다. 주의 ![](./image01.png)처럼 상대경로를 사용하게되면 포스팅을 클릭하여 나타난 페이지에서는 정상적으로 이미지가 노출되나 사이드메뉴의 카테고리 중 하나를 클릭했을 때 페이지에서 상대경로가 맞지 않아 이미지가 깨지게 된다. (3) 새 페이지 생성페이지는 생성할 경우 해당 페이지명으로 된 폴더와 하위에 index.html 파일이 생성되며 포스트와 다르게 상단 탭에 연결할 수 있는 것으로 보임. 따라서 category와 tag는 사용할 수 없고 about처럼 상단에 추가할 수 있다. 1hexo new page &quot;page&quot; (4) Scaffolds(머리말) 속성 title 대괄호가 잘 안 들어가서 이스케이프문자를 넣어야하나했는데 그냥 큰따옴표로 묶어서 해결해버림. date 내가 지정해주지 않아도 자동으로 DB에 발행일이 들어가는가 보더라. 딱히 그럴 일이 없어서 이게 수정이 되는지는 확인 안해봄. categories, tags categories, tags는 여러개 지정할 수 있는데, 다음과 같이 두 가지 방법이 있다. 1234categories: - ctg1 - ctg2tags: [tag1, tag2] (5) toc 띄우기이카루스 default 테마에서는 toc 속성이 false로 되어있는지 처음에는 나타나지 않으나 아래와 같이 true로 명시해주면 바로 [카탈로그]라고 뜬다. 사이드에 위치하는데 position 옵션에서 left/right를 지정할 수 있다. 창의 너비가 작아지면 우선적으로 보이는게 left라서 나는 left로 해두고 left sidebar의 sticky 옵션을 true로 바꾸었다. 12345678toc: truewidgets: - position: left type: toc index: true collapsed: true depth: 3 (6) 로컬 테스트http://localhost:4000/에서 확인한다. 로컬 테스트는 배포 전 로컬의 파일 변경만으로 확인할 수 있는데, 아래 케이스에 해당한다. configuration이 변경된 경우 서버를 내렸다가(ctrl + C) 다시 올려야(hexo s) 적용이 된다. 로컬에서 테스트가 끝나면 아래 명령어로 배포 후 1-2분 후 적용되었는지 https://dl137584.github.io/에서 확인할 수 있다. 1hexo d -g (7) about 페이지 생성1hexo new page about (public에 about 폴더를 만들고 별짓을 다했는데 그냥 new page하면 되는 거였어..) page 명이 “about”인 이유는 _config.icarus.yml에서 navbar:menu:About에 설정한 이름을 따라간 것. 123456789# Page top navigation bar configurationsnavbar: # Navigation menu items menu: Home: / Archives: /archives # Categories: /categories # Tags: /tags About: /about (8) 초안 작성1hexo new draft title 이렇게 생성된 포스트는 _posts/가 아닌 _draft/에 위치하게 된다. 작성은 했는데 바로 배포하고 싶을 때 md 파일을 _draft 폴더로 옮기면 배포해도 포스팅이 노출되지 않기 때문에 편하게 쓸 수 있다. 만약 테스트 시 draft 파일도 보이도록 하고자한다면 서버를 올릴 때 –draft 옵션을 붙여주면 된다. 1hexo server --draft 5. 마크다운 활용노션의 callout(설명) 구현인용과 차이를 두면서 노션의 callout UI와 같이 일부영역 강조를 편하게 사용하고 싶어서 마크다운의 테이블 구조를 활용하여 아래와 같이 만들었다. 인용 외에 참고사항 등에 사용할 예정이다. Title Contents1 Contents2 좌우 여백은 위의 경우 제법 넓게 나타나는 편인데, 가운데 영역(Title, Content1, Content2)의 총 너비가 짧아서 그렇다. Title이나 Content의 길이가 길어질 경우 여기에서 사용한 것처럼 여백이 줄어들게 된다. 마크다운 코드는 아래와 같이 사용하였다. 12345 | Title | --- | --- | --- | Contents1 | | Contents2 | | | (adsbygoogle = window.adsbygoogle || []).push({});","link":"/2022/02/04/006-create-personal-blog-with-githubpages-and-hexo/"},{"title":"기술 블로그 - 구글 검색엔진 최적화(SEO;Search Engine Optimization) 적용","text":"이카루스에서 세팅하는 방법 - 링크 구 이카루스에서 ejs를 사용하다가 jsx로 바뀌어 위의 방법이 통하지 않았음.(링크) 링크에 따르면 구버전에 비해 React를 사용해 만든 기존 이카루스에서는 표준링크를 자동으로 생성하기 때문에 hexo-auto-canonical를 따로 설치하지 않아도 된다.(그런데 설치해버려서 npm uninstall 로 삭제.) 1234npm i hexo-autonofollownpm i hexo-generator-feednpm i hexo-generator-seo-friendly-sitemapnpm i hexo-generator-robotstxt 결국 설치하는 건 위의 4개. (adsbygoogle = window.adsbygoogle || []).push({}); [1] 검색 엔진 등록: 구글 서치 콘솔이 단락에서는 [사이트맵 생성]과 [색인 생성]방법을 알아볼 건데, 우선 규모가 작은 웹사이트의 경우 아래와 같이 구글서치콘솔 가이드에서 사이트맵이 필요하지 않을 수도 있다고 나와있다. 나는 아래에도 나와있지만 사이트맵 생성에 오류가 있어 일단 사이트맵 대신 페이지마다 [색인 생성]을 하는 방법으로 각 페이지를 구글검색에 걸리도록 하였다. (현재 페이지가 4개 정도밖에 없음) 그렇다고 사이트맵을 생성하지 말아야하는 것은 아니다. (1) 사이트맵 생성: 아직도 안됨Google Search Console에서 URL 접두어를 이용하여 도메인을 등록한다. [계속]을 눌렀을 때 나오는 파일을 다운로드하여 [프로젝트]/public/ 에 해당 파일을 옮겨 넣는다. 그리고 배포 후 조금 기다리면 아래와 같이 초록색이 뜬다. 소유권이 확인되면 [속성으로 이동] 또는 왼쪽 위 URL 드롭다운을 클릭하여 Search Console을 이용할 수 있다. 지금은 검색 엔진을 사용하기 위해 사이트맵을 rss2.xml과 sitemap.xml을 등록해준다. “가져올 수 없음”에 관한 포스팅 그런데 “가져올 수 없음”이라고 실패/성공도 아닌 것이 뜬다. 사이트맵 입력 시 슬래시를 붙여서 “/sitemap.xml”으로 하면 잘 된다는 말이 있어서 해보았으나 다르지 않음. 아마 현재 설연휴라서 이게 처리가 늦어지는 것으로 보고 일단 보류하고 다른 방법을 찾아보았다. (2) 색인 생성: 1-2일 소요 주의 &gt; 색인 생성은 일일 할당량(10개 아래, 정확하지 않음)이 있어 이를 초과하면 더이상 색인 생성을 요청할 수 없다. 색인 생성 방법은 다음과 같다. 참고: 구글 서치 콘솔에서 색인 생성하는 방법 링크 상단 URL 검사란에 포스팅 주소(https://dl137584.github.io/2022/01/31/JCenter-지원종료/)를 붙여넣고 아래 [색인 생성 요청]을 누른다. 요청이 완료되면 아래와 같은 문구가 뜬다. 기본적으로 1-2일 소요되긴 하나, 1. 구글검색창에 나와도 아래 [색인생성범위]에는 뜨지 않거나 2. 이틀이 지나도 구글검색창이나 [색인생성범위]에 리스팅되지 않아서 다시 URL 검사를 해보면 등록되어있지 않다고 나오는 등의 상황이 있었다. 1번의 경우 7일 이하로 기다리면 나타나거나 하는데 2번의 경우 나는 다시 색인생성을 요청하였다.(sitemap.xml이 계속 “가져올 수 없음”이 떴기 때문에 어쩔 수 없이…) 정상적으로 색인생성요청이 처리가 된 후에는 사이드바 [색인생성범위]에서 아래 [유효]를 클릭하면 초록색으로 변하면서 그래프에도 유효 카운트가 표시되고 그 아래에 상세정보가 뜬다. 색인을 생성한 url을 확인할 수 있으나 여기서 삭제는 할 수 없다.(해당 페이지는 내가 md 파일명을 변경하여 주소가 변경되었는데도 그대로 남아있다. 단, 이것도 7일 이하로 기다리면 [제외됨]으로 옮겨지면서 자동으로 갱신된다. [제외됨]으로 자동으로 옮겨질 경우 검색창에서도 검색되지 않는지는 해보지 않아 알 수 없음.) (3) 색인 생성된 url 삭제: 6시간 내로 됨url이 바뀌어 올렸던 것을 삭제해야 한다면 사이드바의 [삭제]로 이동한다. 그리고[임시 삭제 항목]&gt;[새 요청]에서 삭제하고자하는 url을 기입하여 요청할 수 있다. 요청 처리가 완료되어 삭제되면 더이상 구글 검색창에서 관련 키워드를 입력해도 검색되지 않는다.","link":"/2022/02/04/007-blog-apply-seo/"},{"title":"[번역: Async Basics with Rust] 동시성 VS 병렬성(Concurrent vs Parallel)","text":"이 포스팅은 Async Basics with Rust의 글을 번역한 것입니다. 오역, 의역, 생략이 있으니 감안하여 읽어주십시오. 동시성과 병렬성의 차이는 무엇인가?이 주제에 대해 곧바로 동시성이 무엇인지 정의함으로써 파헤쳐보자. 병렬 상의 동시성과 쉽게 헷갈릴 수 있어서 시작부터 두 가지를 명확히 구분해둘 것이다. 동시 실행(Concurrency)이란 동시에 많은 것을 **처리하는** 걸 말한다. 병행(Parallelism)이란 동시에 많은 일을 **수행하는** 걸 말한다. 우리는 멀티태스킹을 동시에 여러 개의 작업을 진행한다는 개념으로 쓴다. 이러한 다중 작업에는 두 가지 방법이 있다. 하나는 작업을 동시에(;함께; 겸임) 진행하지만, 실제 같은 시간에 하지는 않는 것이며, 또 다른 방법은 병렬적으로 실제 같은 시간에 여러 작업을 진행하는 것이다. 몇 가지를 정의해보자. 리소스(Resource) 작업을 진행하는 데에 필요한 것. 리소스는 제한되어있다. 한 예로 CPU의 시간이나 메모리를 들 수 있다. 작업(Task) 진행하면서 어떤 종류의 리소스를 필요로하는 기능 집합(A set of operations)이다. 하나의 작업은 몇 개의 sub-operations로 구성된다. 병렬성(Parallel) 정확히 같은 시간에 독립적으로 일어나는 일. 동시성(Concurrent) 동시에 진행중(in progress)인 작업들을 말하지만, 반드시 같은 시간에 진행되는 것은 아니다. 이는 중요한 차이점이다. 만약 두 작업이 동시에 실행됐지만 병렬적이지는 않을 때, 그 작업들은 stop(멈춤)하거나 resume(재시작)할 수 있어야 한다. 주석 &gt; 왜냐하면 병렬적이지 않은 것은 위의 [그림2 - Parallel]과 같이 한 작업이 계속해서 CPU를 붙잡고 항상 진행중 상태에 있지 않기 때문이다. 멈추고 재시작하기를 반복한다. 따라서 동시 실행 속성을 가지고 있다면 interruptable(끼어들 수 있는)하다고 말한다. 내가 사용하는 심상모형(mental model)나는 우리가 병렬성이나 동시성을 가진 프로그램을 만들 떄 어려워하는 이유가 일상에서 일어나는 사건들을 모델링하는 방법에서 기인한다고 생각한다. 우리는 대게 잘못된 직관으로 대략적인 정의를 내리는 경향이 있기 때문이다. concurrent의 사전적 정의는 parallel과의 차이를 인지하는 데에 도움을 주지 않는다. 나로 말할 것 같으면, 병렬성과 동시성의 차이점이 왜 필요한지를 떠올린 게 시작이었다. 이들이 필요한 이유는 리소스의 활용도와 효율성과 관련된 모든 것에 있다. 효율성이란 어떤 일을 하면서, 또는 바라는 결과를 내는 데에 쓰이는 자원, 에너지, 노력, 돈, 그리고 시간을 낭비하지 않는 (대게 측정할 수 있는) 능력을 말한다. 병행(Parallelism) 작업을 수행하면서 리소스를 계속해서 늘린다. 이는 효율성을 고려하지 않는다. 동시 실행(Concurrency) 효율성과 리소스 활용도 모두를 고려한다. 동시 진행은 절대 단 하나의 작업을 더 빠르게 만들 수는 없다. 대신 리소스를 더 효율적으로 운용하고, 그럼으로써 작업들의 집합(a set of tasks)이 더 빠르게 끝나도록 한다. 경제학에서 몇 가지 유사점을 찾아보자.상품 제조 사업에서는 린(LEAN)이 대표적이다. 린 이라는 기술을 사용함에 있어 가장 이점은 기다리는 시간과 가치없는 작업을 제거하는 것이다. 프로그래밍에서 말할 것 같으면, blocking과 polling을 피한다고 말할 수 있다. 동시성 및 I/O와의 관계지금까지 말한 걸 보면, 비동기 코드를 작성하는 데 리소스를 최적으로 사용할 때야 비로소 의미가 있다. 프로그램을 짤 때 동시성이 도움이 되지 않는 경우도 있다. 병렬로 작업할 파트들로 나눌 수 있다면 더 많은 리소스를 할당하는 식으로 문제를 해결할 수 있다. 동시성에 관한 두 가지 주요 이용 사례가 있다: 입출력이 수행되는 중에 일부 외부 이벤트가 발생할 때까지 기다리는 상황. 여러 가지에 집중해야할 때 한 가지에만 너무 오래 기다리는 걸 방지해야하는 상황. 첫 번째는 기본적인 입출력 예제이다: 당신이 한 가지 작업을 진행하기 전에 네트워크 호출이나 DB 쿼리 등이 발생할 때까지 기다려야하는 상황이다. 그러나 지금 다른 할 일도 많기 때문에 다른 작업을 계속하다가 작업(네트워크 호출 등)이 준비가 됐는지 정기적으로 확인하거나 준비가 됐을 떄 알림을 받아야 한다. 두 번째는 UI 단에서 자주 일어나는 일이다. 당신이 한 개의 코어만 가지고 있다고 하자. 그럼 CPU에서 집중적으로 작업을 수행하고 있는데 대체 어떤 UI가 무반응을 피할 수 있을까? 음, 당신이 지금 하고 있는 작업이 뭐든간에 멈추고, “UI 갱신”을 하고, 그 후에 하려고 했던 일을 재시작할 수도 있다. 이렇게하면 작업을 1초에 60번 중지/재시작 해야한다. 그러면 당신은 결국 대략 60Hz의 새로고침 빈도를 반응하는 UI를 가지게 될 것이다. OS에서 제공하는 스레드에 관하여I/O 처리 전략에 관해 이야기하면서 스레드에 대해 좀 더 다룰 거지만 여기서도 언급하겠다. OS 스레드를 사용할 때 한 가지 문제는 코어에 매핑되는 것처럼 보인다는 것이다. 대부분의 운영 체제가 스레드 수가 코어 수와 같을 때까지 하나의 스레드를 하나의 코어에 매핑하려고 시도하더라도 이게 반드시 올바른 심상 모델은 아니다. 코어보다 많은 스레드를 생성하면, OS는 스레드간에 스위치를 수행하고 각 스레드에 실행시간을 제공하는 스케줄러를 사용하여 각 스레드를 동시에 진행하도록 할 것이다. 그리고 시스템에서 프로그램은 겨우 하나만 실행되지 않는다는 걸 명심해야한다. 다른 프로그램도 여러 개의 스레드를 생성할 수 있고, 이는 CPU에 있는 코어보다 더 많은 스레드가 있음을 의미한다. 그러므로, 스레드는 병렬적으로 작업을 수행하도록 하는 수단이 된다. 이는 동시성을 달성하는 수단이기도 하다. 이건 동시성에 관한 마지막 파트로 이어진다. 이제 일종의 참조 프레임을 정의해야 한다. 참조 프레임 바꾸기당신의 관점에서 봤을 때 완벽하게 동기적인 코드를 짰다고 하자. 잠시 멈춰서 운영 체제 관점에서 이게 어떻게 보일지 생각해봐라. 운영 체제는 당신의 코드를 처음부터 끝까지 실행하지 않을 수 있다. 매순간 프로세스를 멈추고 다시 시작하길 반복할 것이다. CPU는 당신이 보기에 이 작업에만 집중하고 있다고 생각하는 동안에도 멈추고 일부 입력을 처리하고 있을지도 모른다. 그러니 동기적 실행은 그저 환상이다. 하지만 프로그래머로서 당신의 관점에서, 그렇지만도 않다. 이게 요점이다: 다른 맥락 없이 동시성을 말할 때, 당신은 프로그래머이며 당신의 코드는 참조 프레임이 된다. 만약 이를 염두에 두지 않고 동시성에 대해 이해하려한다면 혼란스러울 수 있다. 즉, 참조 프레임을 염두에 둬야 한다. 아직 복잡하게 들릴 수 있다. 이후 비동기 코드와 함께 작업하면서 이를 계속 상기해낸다면 복잡함은 점점 덜게 될 것이라 약속한다. (adsbygoogle = window.adsbygoogle || []).push({});","link":"/2022/02/04/005-the-difference-between-concurrency-and-parallelism-in-rust/"},{"title":"[Android] 메모리 캐시와 디스크 캐시","text":"브라우저에서의 메모리/디스크 캐시메모리 캐시 vs 디스크 캐시 :: 마이구미 (정리잘되어있음) 아래는 해당 링크의 요약본이다. 브라우저 측면이 아닌 하드웨어 측면에서 보면, 관련설명 잘 되어있는 추천영상: [bRd 3D] CPU는 어떻게 작동할까? 유투브링크 디스크 캐시는 하드디스크에 접근하는 시간을 개선하기 위해 RAM에 저장하는 기법이다. 캐시 메모리는 램에 접근하지 않고 더 빠른 시간으로 접근할 수 있는 CPU 칩 안에 있는 작지만 빠른 메모리이다.(L1, L2, L3) 브라우저 측면에서 보면,기본적으로 캐시 데이터는 하드디스크에 저장되는데(즉, 디스크 캐시), 재사용 및 I/O 최소화 등의 이점이 있으나 더 빠른 처리를 위해 I/O 없이 웹코어 내부로 바로 접근하여 데이터를 가져오는 메모리 캐시가 존재한다. (adsbygoogle = window.adsbygoogle || []).push({}); 앱, 비트맵 캐싱 참고 문서 안드로이드 공식 문서 - 비트맵 캐싱 찰스의 안드로이드 - 안드로이드에서 LruCache를 파헤치기 비트맵 캐싱은 LruCache를 사용하는 대표적인 예다. 디스크 캐시 및 메모리 캐시에 대해 구분하고자 한 계기는 Glide다. Glide에서는 비트맵 풀 설정을 재정의할 때 다음과 같이 사용한다. 12int bitmapPoolSizeBytes = 1024 * 1024 * 30; // 30mbbuilder.setBitmapPool(new LruBitmapPool(bitmapPoolSizeBytes)); (참고로 기존에 사용하던 UIL의 설정 중 하나는 .memoryCache(new LruMemoryCache(2 * 1024 * 1024))였다.) 또한, 메모리 캐시를 사용하지 않거나 디스크 캐시를 어떻게 사용할지 Strategy(전략)을 설정할 수 있도록 하였다. 12.skipMemoryCache(true) // default is false.diskCacheStrategy(DiskCacheStrategy.NONE) // default is AUTO 그렇다면 왜 이 둘은 나뉘어져 있고, 왜 Lru를 사용할까. 비트맵 캐싱 측면에서 보는 메모리 캐시와 디스크 캐시 메모리 캐시는 “중요한 애플리케이션 메모리”를 사용하는 대신 비트맵에 빠르게 액세스할 수 있다. (인용 출처: 공식문서) 주석 &gt; 링크 “중요한 애플리케이션 메모리”는 View &gt; Tool Windows &gt; Device File Explorer 로 들어가서 data/data 하위 폴더에서 확인할 수 있다. 하지만 애플리케이션이 종료되면 메모리 캐시는 사라지기 때문에, 일부 데이터는 “유지”될 필요가 있다. 이러한 경우 디스크 캐시를 사용하여 처리된 비트맵을 “유지”하고 메모리 캐시에서 이미지가 더 이상 사용 가능하지 않을 때 로드 시간을 줄일 수 있습니다. 결론즉, 메모리 캐시는 빠르다. 앱 자체에서 가장 빠르게 도달할 수 있는 메모리에 저장되기 때문이다. 하지만 그 용량이 작아 이미지 로딩이 많은 경우 문제가 될 수 있으므로 디스크 캐시를 함께 사용하게된다. 디스크 캐시는 메모리 캐시에 비해서는 느리다. 따라서 여기에서 이미지를 불러올 경우 백그라운드에서 로딩이 되도록 비동기 처리를 함께 해줘야하는 대신 용량이 크다.","link":"/2022/02/05/010-memory-cache-and-disk-cache/"},{"title":"[Android &#x2F; Glide] Glide v4 적용","text":"1. 시작하기 Glide v4 공식 문서(영어) 찰스의 안드로이드 - Glide v4 한글 번역 *(주: 2016년 자료) 장범석님의 개발일지 - Glide 사용법* (feat. 메모리/디스크 캐시 설명) 안드로이드 SDK 요구사항 최소 SDK 버전 - Ice Cream Sandwich, 14 이상 컴파일 SDK 버전 - Oreo MR1, 27 이상 권한12345&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt;// Glide가 연결 상태를 감시하고 실패한 요청을 재시작하는 것을 허용&lt;uses-permission android:name=&quot;android.permission.ACCESS_NETWORK_STATE&quot; /&gt;// ExternalPreferredCacheDiskCacheFactory를 사용하여 Glide의 캐시를 공개 sdcard에 저장하기 위해&lt;uses-permission android:name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot; /&gt; 의존성123dependencies { kapt 'com.github.bumptech.glide:glide:4.11.0' // 코틀린을 쓸 경우 kapt여야함.} dependencies의 implementation, api 차이점에 관하여 (adsbygoogle = window.adsbygoogle || []).push({}); 2. 기본 형태123456789RequestOptions options = new RequestOptions() .bitmapTransform(new RoundedCorners(20)) //radius .placeholder(R.drawable.loading) // 이미지 로딩 중 .error(R.drawable.loading); // 이미지를 불러오지 못할 경우Glide.with(context) // RequestManager 형태로 반환 .load(&quot;url&quot;) // RequestBuilder&lt;Drawable&gt; 형태로 반환 (이하 apply, into 동일하게 반환) .apply(options) .into(imageView); ImageView의 setDrawableResource(resource)를 부르는 것으로 보임. apply에 if문을 적용한 사례 12345678Glide.with(this) .load(url) .transition(DrawableTransitionOptions.withCrossFade(factory)) .diskCacheStrategy(DiskCacheStrategy.ALL) .apply { if (corner = 0) transfoem(CenterInside(), RoundedCorners(corner.fromDpToPx())) } .into(this) 3. Glide 커스텀을 위한(=GlideApp 사용을 위한) AppGlideModule 관련 링크 Glide 공식 API 문서 - AppGildeModule API Glide Builder 옵션 설명 Header에 User-Agent property 삽입GlideApp 생성절차 링크를 따를 것. 4. 비트맵 관련 설정 - RequestOptions Glide 공식 API 문서 - RequestOptions API (1) 주요 옵션 placeholder(resourceId): 이미지 로딩하는 중에 보여지는 대체 이미지. error(resourceId): 이미지를 불러오지 못할 경우 대체 이미지. skipMemoryCache(boolean): true 설정 시 캐시를 통하지 않고 이미지 로드. override(int width, int height): target의 너비, 높이를 세팅. 이미지 리사이징. centerCrop: default type. 외에 FitCenter, CircleCrop도 있음. Glide에서 RequestOptions를 Glide.apply()했을 때와 안 했을 때의 이미지 transformation default 값이 다르다. (아래 예시: v4 공식문서 발췌) → RequestOptions을 적용하지 않았을 경우 default 값 Glide.with(context) .load(url) .fitCenter() // default .into(imageView); → RequestOptions을 적용 시 default 값 Glide.with(context) .load(url) .apply(new RequestOptions().centerCrop()) .into(imageView); → xml에서 scaleType지정하면 그걸로 적용될 것 같은데, 만약 ImageView인데 scaleType을 지정하지 않았을 경우 AUIL와 Glide(RequestOptions적용한 것), Glide(RO 적용 안 한 것) 세 개의 작동이 다를 수 있음. (2) 참고 옵션 diskCacheStrategy: 디스크 캐시 전략. 이미지 로드에 사용할 캐시 설정 ALL - DATA와 RESOURCE를 사용하여 원격 데이터를 캐시하고 RESOURCE만 사용하여 로컬 데이터를 캐싱 AUTO - defualt value. NONE - 디스크캐시 사용안함. priority: 로드되는 이미지의 우선순위 결정 HIGH, IMMEDIATE, LOW, NORMAL fallback: load할 url이 null일 경우 보여줄 대체 이미지. 이게 정의되어있지 않으면 error 이미지를, error 이미지도 없다면 placeholder 이미지로 대체됨. (3) 예제. DisplayImageOptions와 대응되는 RequestOptions123456789private DisplayImageOptions mPlaceHolderOption = new DisplayImageOptions.Builder() .resetViewBeforeLoading(true) // default .cacheInMemory(true) // default .cacheOnDisk(true) // default .imageScaleType(ImageScaleType.EXACTLY) // default .bitmapConfig(Bitmap.Config.RGB_565) // default .showImageOnLoading(R.drawable.ic_loading) // loading place holder resource .showImageOnFail(R.drawable.ic_loading) // failed place holder resource .build(); resetViewBeforeLoading(true) cacheInMemory(true) → RequestOptions.skipMemoryCache(false) cacheOnDisk → RequestOptions.diskCacheStrategy imageScaleType.EXACTLY: 뷰 사이즈에 맞춰서 이미지가 작아짐. bitmapConfig → RequestOptions.format(DecodeFormat.PREFER_RGB_565) RequestOptions.format(DecodeFormat.PREFER_ARGB_8888) Glide’s default: RGB_565 showImageOnLoading / showImageOnFail → RequestOptions.placeholder(drawable) / RequestOptions.error(drawable) (adsbygoogle = window.adsbygoogle || []).push({}); 5. Clear(1) memory 캐시 삭제12// 이 메소드는 메인 스레드에서 호출되어야 한다.Glide.get(context).clearMemory(); Glide의 캐시 메모리 영역과 BitmapPool을 정리한다. 단, 모든 메모리를 삭제하는 것은 특히 효율적이지 않으며 버벅거림과 로드 시간 증가를 방지하기 위해 가능한 한 피해야 한다. (2) disk 캐시 삭제12345678val isMainThread = Looper.myLooper() == Looper.getMainLooper()just&lt;String&gt;(&quot;&quot;) .subscribeOn(if (isMainThread) Schedulers.io() else Schedulers.immediate()) .subscribe { // 이는 background 스레드에서 실행되어야 한다. Glide.get(this@SomethingActivity).clearDiskCache() Log.d(&quot;Deleted image memory cache and disk cache.&quot;)} 디스크 캐시의 모든 항목을 지운다. 앱에서 실제로 테스트 해보니 캐시메모리의 디폴트 사이즈인 250MB를 채운 후 clearDiskCache()를 호출했을 때 변화는 다음과 같았다. (Glide 외의 다른 캐시 데이터로 인해 왼쪽 before 사진에서는 250MB보다 약간 오버된 상태이다.) 6. 전환 - Transitions123456import static com.bumptech.glide.load.resource.drawable.DrawableTransitionOptions.withCrossFade;Glide.with(context) .load(url) .transition(withCrossFade()) // optional .into(view); Glide v4 does NOT apply a cross fade or any other transition by default. Glide v4 부터는 어떤 transitions 이벤트도 기본값으로 들어가있지 않으므로 필요할 떄 추가할 수 있다. (v3에서는 기본값이 cross fade였음) 7. 리스너 - RequestListener Glide 공식 API 문서 -RequestListener API 12345678910111213141516171819202122232425262728Glide.with(context) .load(url) .listener(new RequestListener&lt;Drawable&gt;() { // load() 다음에 추가할 것 @Override boolean onLoadFailed(@Nullable GlideException e, Object model, Target&lt;Drawable&gt; target, boolean isFirstResource) { // 여기서 GlideException 로그 출력 Log.e(TAG, &quot;Load failed: &quot; + e.printBlrBlr()); return false; // Target에서 onLoadFailed가 호출되는 것을 허용한다. } /* resource: 로드된 이미지. model: 이미지를 로드하는 데 사용된 모델. dataSource: 이미지 출처. DATA_DISK_CACHE, LOCAL, MEMORY_CACHE, REMOTE와 같은 값. */ @Override boolean onResourceReady( Drawable resource, Object model, Target&lt;Drawable&gt; target, DataSource dataSource, boolean isFirstResource) { // 성공 로그를 출력하거나 DataSource를 사용해 캐시적중을 추적할 수 있다. return false; // Target에서 onResourceReady가 호출되는 것을 허용한다. } }) .into(imageView); 만약 Bitmap으로 로딩된 이미지를 얻고자 한다면,12345678910111213141516171819Bitmap loadedImage = Glide.with(context) .asBitmap() .load(url) .listener(new RequestListener&lt;Bitmap&gt;() { @Override public boolean onLoadFailed(@Nullable GlideException e, Object o, Target&lt;Bitmap&gt; target, boolean b) { return false; } @Override public boolean onResourceReady(**Bitmap bitmap**, Object o, Target&lt;Bitmap&gt; target, DataSource dataSource, boolean b) { image.setImage(ImageSource.bitmap(bitmap)); return false; } }) .submit(100, 100) // width, height: RequestBuilder API 참조 .get(); 관련링크 Glide 이미지 로딩 중 다른 scaleType 적용하기","link":"/2022/02/05/008-glide-v4/"},{"title":"탐욕법(Greedy Algorithm)","text":"탐욕법(Greedy Algorithm)이란?미래를 고려하지 않고 각 단계에서 최적의 해를 찾아 모든 단계를 진행할 경우 최선의 결과에 도달한다고 생각하는 알고리즘. 참고: Greedy Algorithms | Brilliant Math &amp; Science Wiki 특징 전체적인 최적해를 보장할 수 없다. 선택한 것을 번복하지 않는다. 직관적 예시, 최소 신장 트리 참고: 14. 탐욕 알고리즘 (Greedy Algorithm) - 1 예시, 거스름돈 최소 개수 반환거슬러줄 돈(w)에서 동전(10, 50, 100, 500)을 뺐을 때 그 값이 가장 작은 경우의 동전을 우선 반환한다. 여기서 “뺀 값이 가장 작은 경우가 최적의 해”라는 게 이 문제에서 가장 근본적인 명제이다. 12345678910111213141516// 거스름돈 최소 개수 반환int change = w; //입력: 거슬러줄 돈int n500, n100, n50, n10 = 0;while(change &gt;= 500) { change -= 500; n500++;}while(change &gt;= 100) { change -= 100; n100++;}while(change &gt;= 50) { change -= 50; n50++;}while(change &gt;= 10) { change -= 10; n10++;}return n500 + n100 + n50 + n10; 단, 200원에 대해 동전이 위의 네 가지 밖에 없다면 최종해는 100*2로 “2”겠지만, 160원짜리 동전이 만들어진다면 160*1 + 10*4로 “5”가 나오기 때문에 탐욕법으로 최적해를 찾을 수 없게 된다. 이처럼 모든 상황에서 최적해를 찾을 수 있는 유연한 방법이 아니다. (adsbygoogle = window.adsbygoogle || []).push({}); 동적 계획법과 비교된다. 동적 계획법(Dynamic Programming)이란, 전체를 바라보고 그것을 여러 개의 하위 문제들로 나누어 각 하위 문제들의 답을 이용해 최종 답을 내는 것이다.(복잡한 문제를 간단한 여러 개의 문제로 나누어 푸는 방법) 동적 계획법 특징 큰 문제 안에 작은 문제가 중첩되어 있는 문제를 해결하는 데 사용. 예를 들어, 피보나치 수열. 중첩되는 데이터라면 저장하고, 지속적으로 데이터를 참조한다. 피보나치 수열을 간단하게 코드화하면 아래와 같다. 12345public void fib(int n) { if (n == 0) return 0; else if (n == 1) return 1; else return fib(n-1) + fib(n-2);} 이때, fib(5)를 구하려고 하면 fib(2)의 계산은 여러번 중복된다. 이로 인한 계산 속도의 저하를 막기 위해 fib(2)와 같이 중복되는 값은 배열에 저장하여 필요할 때 배열에 접근해서 값을 가져오는 방식이다. 중복계산이 줄어들기 때문에 시간 복잡도는 O(n)가 된다.","link":"/2022/02/05/012-greedy-algorithm/"},{"title":"[Android &#x2F; Glide] GlideApp 생성절차","text":"아래 방식은 4.x.x 버전에서 유효하다. 3.x.x 버전의 Glide에서는 Manifest.xml에 meta-data를 추가하는 방식으로 진행된다.참고) 3.x.x는 아래 링크가 더 도움이 될 것 같다. 3.x.x에서는 AppGlideModule이 아닌 GlideModule을 상속받는 클래스를 만들어야 한다.https://medium.com/@PaulinaSadowska/adding-headers-to-image-request-in-glide-dc9640ca9b12 1. app/build.gradle에 dependencies 추가123456789apply plugin: 'kotlin-android'apply plugin: 'kotlin-kapt'...dependencies { ... implementation 'com.github.bumptech.glide:glide:4.11.0' implementation &quot;com.github.bumptech.glide:okhttp3-integration:4.11.0&quot; kapt 'com.github.bumptech.glide:compiler:4.11.0'} 코틀린을 쓰고 있다면, glide:compiler dependencies를 kapt로 추가해줘야한다.이를 위해 선행작업으로 gradle.build의 최상단에 kotlin-kapt 도 필요하다. glide:glide는 기본적으로 Glide 라이브러리를 사용하기 위해 추가됨. okhttp3-integration는 CustomGlideModule에서 사용하기 위함. glide:compiler는 GeneratedAppGlideModuleImpl를 생성하기 위함.이후 proguard-rules.pro에서 GeneratedAppGlideModuleImpl를 keep 해주는데 이는 GlideApp을 사용하기 위해 CustomGlideModule과 같은 패키지(net.common.utils.GlideApp)에 만들어진다.(4번 절차 참조) (adsbygoogle = window.adsbygoogle || []).push({}); 2. UserAgentInterceptor 생성 참조 문서 Using OkHttp Interceptor: Redundant User Agents · Issue #3692 · bumptech/glide 123456789101112131415161718192021import java.io.IOException;import okhttp3.Interceptor;import okhttp3.Request;import okhttp3.Response;public class UserAgentInterceptor implements Interceptor { private Context mContext; public UserAgentInterceptor(Context context) { mContext = context; } @Override public Response intercept(Chain chain) throws IOException { Request request = chain.request() .newBuilder() .header(&quot;User-Agent&quot;, getUserAgent(mContext)) .build(); return chain.proceed(request); }} 3. CustomGlideModule 생성12345678910111213141516171819202122232425262728293031package net.common.utils;import com.bumptech.glide.Glide;import com.bumptech.glide.GlideBuilder;import com.bumptech.glide.Registry;import com.bumptech.glide.annotation.GlideModule;import com.bumptech.glide.load.model.GlideUrl;import com.bumptech.glide.module.AppGlideModule;import com.bumptech.glide.integration.okhttp3.OkHttpUrlLoader.Factory;import java.io.InputStream;import okhttp3.OkHttpClient;@GlideModulepublic final class CustomGlideModule extends AppGlideModule { @Override public void applyOptions(@NonNull Context context, @NonNull GlideBuilder builder) { // 아무 것도 수정하지 않지만 오버라이드 해줘야함 super.applyOptions(context, builder); } @Override public void registerComponents(@NonNull Context context, @NonNull Glide glide, @NonNull Registry registry) { OkHttpClient client = new OkHttpClient.Builder() .addInterceptor(new UserAgentInterceptor(context)) .build(); registry.replace(GlideUrl.class, InputStream.class, new Factory(client)); }} @GlideModule 어노테이션 선언 꼭 잊지 말 것. 3.x.x와는 다르게 AppGlideModule을 상속받아 커스텀 클래스를 만들어준다. registerComponents에서 OkHttpClient를 통해 커스텀 인터셉터를 추가해준다. AppGlideModule과 LibraryGlideModuleAppGlideModule(을 상속받은 CustomAppGM)은 애플리케이션 단에, LibraryGlideModule(을 상속받은 ~ 생략)은 공통 라이브러리 단에 구현하면 된다. 이때 GlideModule을 커스텀할 경우, CustomAppGM의 구현은 필수적이나 CustomLibraryGM의 구현은 선택적이어서, CustomLibraryGM만 구현해선 안 된다. 그리고 공통 라이브러리에 정의한 모든 CustomLibraryGM은 CustomAppGM에서 통합적으로 추가된다. 4. 재빌드 참고 문서 GeneratedAppGlideModuleImpl location How to use Glide 4 generated API correctly both in app module and library module? · Issue #2393 · bumptech/glide cannot resolve symbol ‘GlideApp’ (GlideApp was not generated) · Issue #1945 · bumptech/glide 3번까지 진행 후 재빌드(Build&gt;Make Project) 하자. app/build/generated/source/kapt/appDebug/com.bumptech.glide.GeneratedAppGlideModuleImpl app/build/generated/source/kapt/appDebug/net.common.utils.GlideApp 위와 같은 로케이션에 GeneratedAppGlideModuleImpl와 GlideApp이 생성되는 것을 확인할 수 있다. 이렇게 되면 이제 GlideApp을 사용할 준비가 된 것. GlideApp은 CustomGlideModule을 정의한 패키지 내에 만들어진다. 위의 두 파일이 만약 생성되지 않는다면 build.gradle의 kapt를 확인할 것 @GlideModule 어노테이션 넣었는지 확인할 것 5. app/proguard-rules.pro 편집12-keep public class * extends com.bumptech.glide.module.AppGlideModule-keep class com.bumptech.glide.GeneratedAppGlideModuleImpl 위와 같은 keep을 추가해줘야한다. 첫번째 라인(* extends AppGlideModule)은 CustomAppGlideModule을 위해서 쓰임. 두번째 라인(GeneratedAppGlideModuleImpl)은 빨간줄로 오류표시가 날 수 있는데, 4번에서 말한 것처럼 kapt로 추가된 의존성에 의해 빌드 후 생성되는 파일이라서이다. 빌드 후 generated에 생성되는 게 GeneratedAppGM과 GlideApp인 것으로 보아 GlideApp을 사용하기 위해서 쓰이는 걸로 보인다. (참고로 app/proguard-rules.pro 파일에서 #으로 시작되는 라인은 주석에 해당함.) 6. GlideApp 사용예1234GlideApp.with(context) .load(&quot;url&quot;) .apply(options) .into(imageView); GlideApp을 통해 이미지를 로드해야지만이 CustomGlideModule에서 정의한 설정을 따른다. 기본적으로 Glide와 사용에 지장이 있을 정도로 방식이 다르지 않다. 단, GlideApp은 Glide와는 다르게 일부 RequestOptions를 통해서만 호출할 수 있었던 속성들을 다이렉트로 컨트롤할 수 있게 된다. 이는 공식문서에서 일부 예제들을 통해 비교할 수 있다.","link":"/2022/02/05/009-the-way-to-create-glideapp/"},{"title":"[Android &#x2F; Glide] 이미지 URL을 읽어 JPG 포맷파일로 변환하기","text":"1. remote url의 이미지를 비트맵 형식으로 가져온다.1234567fun loadBitmapImage(context: Context, url: String?, listener: RequestListener&lt;Bitmap?&gt;?) { GlideApp.with(context) .asBitmap() .load(url) .listener(listener) .preload() //submit()으로 하면 Activity destroy 시점에서 오류} Glide를 사용해 listener를 통해 onResourceReady에서 비트맵 리소스를 받아 처리한다. Glide를 쓰지 않고 가령, 갤러리에 저장된 이미지를 가져와 3번으로 넘어갈 경우, imageView에 비트맵을 저장하게 되는데, 이때 Bitmap의 recycle state를 관리해줘야할 수 있다. (참고: Glide에서 비트맵 이미지가 GC되는 과정)이런 이유로 Android Developer 공식 문서에서는 대부분의 경우 Glide 라이브러리를 사용하여 앱에서 비트맵을 가져오고 디코딩하고 표시하는 것을 추천한다고 나와있다. (adsbygoogle = window.adsbygoogle || []).push({}); 2. 비트맵을 JPG 포맷으로 압축, 저장한다. Bitmap.compress 명세 참고 Bitmap 컨트롤하기 이제 받아온 비트맵을 remoteTemp.jpg 라는 이름의 파일에 JPG 포맷으로 저장할 것이다. 123456789101112131415mRemoteImageUri = Uri.fromFile(getReviewTempImageFile(context , &quot;remoteTemp.jpg&quot;));File bitmapFile = new File(mRemoteImageUri.getPath());try { FileOutputStream outputStream = new FileOutputStream(bitmapFile); bitmap.compress(Bitmap.CompressFormat.JPEG, 100, outputStream); outputStream.flush(); outputStream.close(); setPickedImage(mRemoteImageUri);} catch (Exception e) { e.printStackTrace();} 먼저 저장할 파일의 Uri를 만들었다. Uri를 생성하는 이유는 3번에서 파일의 사이즈를 얻어오기 위함이다. 자세히는 해당 번호 참조. compress의 두 번째 인자값은 CompressFormat에 대한 압축률이며 0(minimum) ~ 100(maximum)으로 설정할 수 있다. bitmap.compress(CompressFormat.PNG, 0, filestream)위와 같이 PNG로 압축하여 출력할 경우 두 번째 인자값은 무시한다. PNG 파일의 특성이 손실률 없는 포맷에 해당하기 때문이다. 위의 코드에서는 FileOutputStream 객체를 사용하여 JPG로 압축한 비트맵이 파일에 저장되었으나 이를 파일로 저장하지 않고 처리하려면 ByteArrayOutputStream를 사용할 수 있다. 코드 세부사항 파일에 저장하는 코드 상에서 사용한 getReviewTempImageFile 메소드는 아래와 같다. 여기서 ‣ 주의할 것. 123456789101112131415161718192021public static File getReviewTempImageFile(Context context, String imageName) { String imgDirName = &quot;/TestDir&quot;; String dirPath = context.getExternalFilesDir(null) + imgDirName; File saveDir = new File(dirPath); if (!saveDir.exists()) { saveDir.mkdir(); } String nomediaFilePath = dirPath + &quot;/.nomedia&quot;; File nomediaFile = new File(nomediaFilePath); if (!nomediaFile.exists()) { try { nomediaFile.createNewFile(); } catch (IOException e) { e.printStackTrace(); } } String filePath = dirPath + &quot;/&quot; + imageName; return new File(filePath);} getExternalFilesDir()을 사용하기 때문에 미리 WRITE_EXTERNAL_STORAGE 퍼미션 처리를 해주어야 한다. crop을 수행하는 Activity에 진입하기 전에 체크해주는 게 가장 좋다. 해당 퍼미션을 체크하는 코드는 다음과 같다. 12345678910111213141516171819202122232425262728private void doImageSearch() { if (permissionCheck(this, Manifest.permission.WRITE_EXTERNAL_STORAGE)) { // start CropActivity } else { mRequestPermission = Manifest.permission.WRITE_EXTERNAL_STORAGE; requestPermission(this, PermissionConstants.REQUEST_STORAGE_CODE, Manifest.permission.WRITE_EXTERNAL_STORAGE); }}public static boolean permissionCheck(Context context, String permission) { return Build.VERSION.SDK_INT &lt; Build.VERSION_CODES.M || (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.M &amp;&amp; ActivityCompat.checkSelfPermission(context, permission) == PackageManager.PERMISSION_GRANTED);}public static void requestPermission(Context context, int requestCode, String permission) { //shouldShowRequestPermissionRationale - 사용자가 권한 요청을 한번 거절 했을 경우 True if (ActivityCompat.shouldShowRequestPermissionRationale((Activity) context, permission)) { try { Intent intent = new Intent(Settings.ACTION_APPLICATION_DETAILS_SETTINGS) .setData(Uri.parse(&quot;package:&quot; + context.getPackageName())); ((Activity) context).startActivityForResult(intent, PermissionConstants.REQ_CODE_REQUEST_SETTING); } catch (ActivityNotFoundException e) {} } else { // 처음 권한 요청 및 다시 보지 않기를 선택하였을 경우 false ActivityCompat.requestPermissions((Activity) context, new String[]{permission}, requestCode); }} 3. 이미지 파일을 적절한 사이즈로 변경하여 재저장crop을 준비하기 위해서는 디바이스의 한 화면에 적절한 크기로 이미지를 노출해야한다. 위의 코드에서 setPickedImage 메소드가 이 기능을 담당한다. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849private void setPickedImage(@Nullable Uri rawBitmap) { mImageCaptureUri = Uri.fromFile(getReviewTempImageFile(context, &quot;originTemp.jpg&quot;)); File bitmapFile = new File(mImageCaptureUri.getPath()); try { Uri bitmapUri = mImageCaptureUri; if(rawBitmap != null) bitmapUri = rawBitmap; BitmapFactory.Options options = new BitmapFactory.Options(); options.inSampleSize = calculateBitmapSampleSize(this, bitmapUri); options.inJustDecodeBounds = false; InputStream is = getContentResolver().openInputStream(bitmapUri); Bitmap bitmap = BitmapFactory.decodeStream(is, null, options); if (bitmap == null) return; String uriPath = getRealPathFromURI(context, bitmapUri); if(TextUtils.isEmpty(uriPath)) uriPath = bitmapUri.getPath(); ExifInterface exif = new ExifInterface(uriPath); int exifOrientation = exif.getAttributeInt(ExifInterface.TAG_ORIENTATION, ExifInterface.ORIENTATION_NORMAL); int exifDegree = exifOrientationToDegrees(exifOrientation); bitmap = rotate(bitmap, exifDegree); FileOutputStream outputStream = new FileOutputStream(bitmapFile); bitmap.compress(Bitmap.CompressFormat.JPEG, 100, outputStream); outputStream.flush(); outputStream.close(); startCrop(bitmap); } catch (Exception e) { e.printStackTrace(); finish(); }}@Overridepublic void finish() { if(mImageCaptureUri != null) deleteTempImageFile(mImageCaptureUri); if(mRemoteImageUri != null) deleteTempImageFile(mRemoteImageUri); mCropImage.setImageBitmap(null); // clear bitmap in imageView super.finish(); overridePendingTransition(0,0);}","link":"/2022/02/05/011-convert-remote-url-to-jpg-file/"},{"title":"[Android] 다른 앱 위에 그리기 권한: TYPE_APPLICATION_OVERLAY","text":"[다른 앱 위의 그리기]는 폰 설정 &gt; 애플리케이션 &gt; 앱 &gt; 고급 [다른 앱 위에 표시되는 앱]에서 권한 설정할 수 있다. 퍼미션[다른 앱 위에 그리기] 설정을 추가하려면 Manifest에 이를 사용하겠다고 퍼미션을 추가해야하는데, 1&lt;uses-permission android:name=&quot;android.permission.SYSTEM_ALERT_WINDOW&quot;/&gt; 권한: 다른 앱 위에 그리기(Draw over other apps / Appear on top)위 퍼미션을 추가하면 앱 설정(설정&gt;애플리케이션&gt;해당 앱)에 [다른 앱 위에 그리기] 정보가 뜬다. (안드로이드 버전마다 언어:영어일 때의 표시나 노출 위치는 다를 수 있다.) 중요한 것은 [다른 앱 위에 그리기]의 기본값이 버전마다 다르다는 건데, API level 23(Android 6.0 Marshmallow) 미만에서는 true 그 이상에서는 false 앱스토어에서 설치할 경우 기본적으로 위와 같이 설정되어 유저의 단말에 설치됨을 숙지하여 기능구현 프로세스를 짜야한다. (adsbygoogle = window.adsbygoogle || []).push({}); 버전 체크 방법 [다른 앱 위에 그리기] 기능이 필요할 경우 API level 23 이상에서는 버전 체크 처리를 해주어야한다. 1234567/* REQ_CODE_OVERLAY_PERMISSION는 임의로 정한 상수 onActivityResult(int requestCode, int resultCode, Intent data)에서 requestCode로 받을 때 사용함 */@TargetApi(Build.VERSION_CODES.M)private static void onObtainingPermissionOverlayWindow(Context context) { Intent intent = new Intent(Settings.ACTION_MANAGE_OVERLAY_PERMISSION, Uri.parse(&quot;package:&quot; + context.getPackageName()); ((Activity) context).startActivityForResult(intent, REQ_CODE_OVERLAY_PERMISSION);} 덧붙여 [다른 앱 위에 그리기] 설정값이 true인지 확인하는 방법은 다음과 같다. 1234public static boolean alertPermissionCheck(Context context) { return Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.M &amp;&amp; !Settings.canDrawOverlays(context);} 주의: deprecated 된 WindowManager.LayoutParams의 플래그 TYPE_PHONE TYPE_PRIORITY_PHONE TYPE_SYSTEM_ALERT TYPE_SYSTEM_ERROR TYPE_SYSTEM_OVERLAY TYPE_TOAST 위에 나열된 타입은 API level 26(Android 8.0 Oreo)에 deprecated 되어 아래와 같이 Android Developer 에서는 이것들 대신 TYPE_APPLICATION_OVERLAY를 쓰도록 가이드 하고 있다. 1234567val param: WindowManager.LayoutParamsval flag = if (Build.VERSION.SDK_INT &gt;= Build.Version_CODES.O) { WindowManager.LayoutParams.TYPE_APPLICATION_OVERLAY}param = WindowManager.LayoutParams(width, WindowManager.LayoutParams.WRAP_CONTENT, flag, ...);","link":"/2022/02/09/013-type-application-overlay/"},{"title":"[Android] Parcelable: Java와 Kotlin 구현 차이","text":"Parcelable을 상속받아 클래스 생성할 경우 CREATOR의 정의 Parcelable protocol requires a Parcelable.Creator object called CREATOR 1234567891011public static final Creator&lt;DataClass&gt; CREATOR = new Creator&lt;DataClass&gt;() { @Override public SearchInfo createFromParcel(Parcel parcel) { return new DataClass(parcel); } @Override public DataClass[] newArray(int i) { return new DataClass[i]; }}; 이걸 코틀린 코드로 변환하면 다음과 같이 만들 수 있으나- 12345678910@JvmField // 프로젝트에 자바 클래스도 존재하는 경우 JvmField 어노테이션 누락에 주의할 것 val CREATOR: Parcelable.Creator&lt;DataClass&gt; = object : Parcelable.Creator&lt;DataClass&gt; { override fun createFromParcel(parcel: Parcel): DataClass { return DataClass(parcel) } override fun newArray(i: Int): Array&lt;DataClass?&gt; { return arrayOfNulls&lt;DataClass?&gt;(i) }} (adsbygoogle = window.adsbygoogle || []).push({}); [코틀린] Parcelable 구현-그러나 코틀린에서는 Parcelable 구현을 위해 @Parcelize 어노테이션을 제공하고 있기 때문에 꼭 필요한 경우가 아니면 자바와 같이 CREATOR를 만들 필요는 없다. 코틀린에서 구현한 Parcelable을 상속받은 Data Class는 다음과 같다. 이 코드는 이 자체만으로도 내부에서 CREATOR 기능을 수행한다. 12345678import android.os.Parcelableimport com.google.gson.annotations.SerializedNameimport kotlinx.android.parcel.Parcelize@Parcelizedata class ParcelData(@SerializedName(&quot;A&quot;) var a: String? = &quot;&quot;, @SerializedName(&quot;B&quot;) var b: String? = &quot;&quot;, @SerializedName(&quot;C&quot;) var c: ArrayList&lt;AnyData&gt;? = arrayListOf()): Parcelable 참고를 위해 Parcelize 어노테이션에 작성된 주석의 일부를 가져왔다. Instructs the Kotlin compiler to generate writeToParcel(), describeContents()[android.os.Parcelable] methods, as well as a CREATOR factory class automatically. 이는 자바 코드(또는 코틀린 코드) 상에서 putExtra를 통해 전달할 수 있다. 12ParcelData p = new ParcelData();intent.putExtra(&quot;extra&quot;, p); 그리고 intent를 통해 이동한 액티비티에서는 getParcelableExtra로 데이터를 받아올 수 있다.","link":"/2022/02/10/014-parcelable-in-java-and-kotlin/"},{"title":"[Android] ViewPager.addOnPageChangeListener","text":"onScrollStateChanged 123456789101112131415161718loopViewPager.addOnPageChangeListener(object : ViewPager.OnPageChangeListener { override fun onPageSelected(position: Int) { loopViewPager.currentItem = position } override fun onPageScrolled(position: Int, positionOffset: Float, positionOffsetPixels: Int) { } override fun onPageScrollStateChanged(state: Int) { if (state == RecyclerView.SCROLL_STATE_DRAGGING) { // 수동으로 스크롤 시에만 터치했을 때 } else if (state == RecyclerView.SCROLL_STATE_SETTLING){ // 스크롤이 움직인 후 픽스되는 순간 } else if (state == RecyclerView.SCROLL_STATE_IDLE) { // 아무것도 수행하지 않을 때 // (즉, 스크롤이 움직이지 않고, 스크롤을 수동으로 잡고 있지 않음.) } }}) (adsbygoogle = window.adsbygoogle || []).push({}); onPageSelected 페이지 인덱스가 변경되지 않는다면 이 메소드는 호출되지 않는다. (수동으로 스크롤 하다가 뗐을 때 재현가능) position: 스크롤 시 선택된 페이지의 인덱스 onPageScrolled 사용자의 터치 스크롤 &amp; smooth 스크롤 시에 호출된다. position: 링크에 따르면, “SETTLE 상태에서는 대상 페이지가 넘어오고, DRAGGING 상태에서는 출발 페이지가 넘어온다”고 한다. 따라서 이를 활용하기는 어려울 것 같아 사용하지 않음. positionOffset: 0.0 ~ 1 사이의 값. 왼쪽으로 스크롤 시 1 -&gt; 0.0으로 감소하며, 오른쪽으로 스크롤 시 0.0 -&gt; 1로 증가한다. onPageScrollStateChanged 페이지 인덱스가 변경될 경우, 변경되지 않을 경우 포함 상태가 변경될 경우 한 번씩 호출된다. 이벤트 전달 순서 수동으로 스크롤 시 페이지를 변경했을 때 순서 SCROLL_STATE_DRAGGING -&gt; SCROLL_STATE_SETTLING -&gt; onPageSelected SCROLL_STATE_IDLE loopViewPager.setCurrentItem으로 스크롤될 경우 순서 SCROLL_STATE_SETTLING -&gt; onPageSelected -&gt; SCROLL_STATE_IDLE 수동으로 스크롤 시 페이지를 변경하지 않았을 경우 순서 SCROLL_STATE_DRAGGING -&gt; SCROLL_STATE_SETTLING -&gt; SCROLL_STATE_IDLE","link":"/2022/02/11/015-viewpager-addonpagechangelistener/"},{"title":"기술 블로그 - AdSense 광고 적용","text":"광고 게재 승인을 기다리는 와중에 기존에 사용하던 티스토리 블로그를 정리하려고 갔는데 우연치않게 [수익]란을 보게 되었다. 현재 운영중이진 않아서 3개월 내 공개 발행글이 없는데 AdSense의 승인이 지연되는 이유가 발행글이 10 아래여서 인 것 같아서 포스팅을 늘리면서 기다려보기로 함. 20개 포스팅이 넘으면 다시 확인해볼 예정. Google AdSense: 15일 소요(2022.02.01 - 02.15 중 포스팅 16개 작성)이카루스 테마에서는 사이드바에 광고를 넣을 수 있도록 제공되는데, 여기에 광고를 넣으려면 _config.icarus.yml에서 client_id와 slot_id를 기입해주면 된다. 아래 작업을 하려면 우선 Google AdSense 내에서 계정을 검토하는 과정을 거쳐야하는데, 이게 2주까지 걸릴 수도 있다고 하더니 내 경우 15일 걸렸다. 막 만든 사이트고(2월 1일 신청당시 포스팅 3개), 검토 요청을 한 2월 1-2일이 설연휴라 더 늦어졌을지도 모르겠다. 승인이 나면 승인되었다는 메일이 오고, Adsense 페이지에 들어가면 다음과 같이 [준비됨]이라고 바뀌어있다. (1) ads.txt 삽입아래 나오는대로 ads.txt 파일을 다운받아 루트(source/)에 넣고 hexo clean 후 hexo g 하면 public/ 하위에 생성된 것을 볼 수 있을 것이다. 이 문제는 확인되어 해결되는 데까지 며칠 걸리는 것 같지만 광고 노출 자체는 승인 후 하루 지나서 바로 되어 문제삼지 않았다. (저 빨간 “수익 손실 위험” 팝업은 광고가 노출 되어도 계속 떠있었다.) (2) 신규 광고 단위 만들기: 사이드 메뉴에 광고 넣기우선 AdSense 사이드 메뉴의 [개요]에서 상단 탭의 [광고 단위 기준]으로 이동하면 디스플레이/인피드/콘텐츠 내 광고 중 타입을 골라서 단위를 생성할 수 있다. 이카루스 테마에서는 _config.icarus.yml 설정파일에서 위젯으로 제공하기 때문에 여기에 넣을 client ID와 unit ID만 만들어주면 된다. 123456789widgets: - # Where should the widget be placed, left sidebar or right sidebar position: left type: adsense # AdSense client ID client_id: 'ca-pub-0' # AdSense AD unit ID slot_id: '0000000000' 내 경우 디스플레이 타입으로 생성하여 만들어진 코드에서 data-ad-client, data-ad-slot 속성값을 각각 client_id, slot_id로 붙여넣었다. (3) 콘텐츠 내에 광고 삽입콘텐츠 내에 광고는 포스팅 내에 광고 삽입을 말한다. 이 경우 [광고 단위 기준]의 콘텐츠 내 타입으로 생성하였는데 사이드 메뉴에 넣을 디스플레이 타입과는 다르게 아래와 같이 생성된 스크립트 코드를 직접 포스팅 내에 삽입해주어야 한다. 광고 단위가 처음 만들어져 게시되는 경우 1시간 내외로 시간이 걸릴 수 있다. 콘텐츠 내 타입 광고는 아래와 같이 나타나게 된다! (adsbygoogle = window.adsbygoogle || []).push({}); -","link":"/2022/02/19/019-blog-apply-adsense/"},{"title":"자바와 코틀린에서의 동등성 비교(&#x3D;&#x3D;, &#x3D;&#x3D;&#x3D;, equals())","text":"동일성(Identity): 참조 주소를 비교 동등성(Equality): 내용 기반 비교 자바에서의 참조타입 동작==와 != 연산자는 참조 동등성을 뜻하며, 내용을 기반으로 하는 동등성은 equals() 호출을 통해 구현한다. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import java.util.*;public class Main{ public static void main(String[] args) { String[] arr1 = {&quot;1&quot;, &quot;2&quot;}; String[] arr2 = {&quot;1&quot;, &quot;2&quot;}; System.out.println(&quot;arr1 address: &quot; + arr1 + &quot; / arr2 address: &quot;+ arr2); if (arr1 == arr1) { System.out.println(&quot;array Identity&quot;); } if (arr1.equals(arr2)) { System.out.println(&quot;array Equality&quot;); } Data d1 = new Data(&quot;x&quot;); Data d2 = new Data(&quot;y&quot;); ArrayList&lt;Data&gt; list1 = new ArrayList(); list1.add(d1); list1.add(d2); ArrayList&lt;Data&gt; list2 = new ArrayList(); list2.add(d1); list2.add(d2); System.out.println(&quot;list1 address: &quot; + list1 + &quot; / list2 address: &quot;+ list2); if (list1 == list2) { System.out.println(&quot;list Identity&quot;); } if (list1.equals(list2)) { System.out.println(&quot;list Equality&quot;); } }} class Data{ Data(String a) { this.a = a; } private String a = null;}/** 출력 array Identity list Equality*/ 참고로 new ArrayList()로 리스트 객체를 생성하는 게 아니라 list를 대입하게 되면 주소값이 동일해진다. 1234567891011list1 = list2;if (list1 == list2) { System.out.println(&quot;list Identity&quot;);}if (list1.equals(list2)) { System.out.println(&quot;list Equality&quot;);}/** 출력 list Identity list Equality*/ (adsbygoogle = window.adsbygoogle || []).push({}); 반면, 코틀린에서의 참조타입 동작연산자 형태(== 또는 !=)로 호출하는 경우 equals()를 호출하기 때문에 두 방식은 같은 결과가 나온다.참조 동등성을 비교하려면 === 또는 !== 연산자를 사용하면 된다. 1234567891011121314151617181920212223242526272829fun main() { val dataclass1: DataClass = DataClass() val dataclass2: DataClass = DataClass() val list1: List&lt;DataClass&gt; = listOf(dataclass1, dataclass2) val list2: List&lt;DataClass&gt; = listOf(dataclass1, dataclass2) if (list1 == list2) println(&quot;list used data class == Equality&quot;) if (list1.equals(list2)) println(&quot;list used data class equals() Equality&quot;) if (list1 === list2) println(&quot;list used data class Identity&quot;) val data1: Data = Data() val data2: Data = Data() val list3: List&lt;Data&gt; = listOf(data1, data2) val list4: List&lt;Data&gt; = listOf(data1, data2) if (list3 == list4) println(&quot;list used class == Equality&quot;) if (list3.equals(list4)) println(&quot;list used class equals() Equality&quot;) if (list3 === list4) println(&quot;list used class Identity&quot;)} data class DataClass(val x: String = &quot;x&quot;)class Data(val y: String = &quot;y&quot;)/** 출력 list used data class == Equality list used data class equals() Equality list used class == Equality list used class equals() Equality*/ String 변수의 동작변수 타입은 기본형(Primitive type)과 참조형(Reference type)이 있다. 그 중 String은 참조형이지만 기본형처럼 쓰이는데 위의 예제와 동작이 약간 다르다. 자바에서는 String str1 = &quot;a&quot;와 같이 일반적인 대입 방식으로 값을 초기화하면 String str2 = &quot;a&quot;처럼 같은 값(“a”)을 가진 변수는 같은 주소를 참조하게 된다. 따라서 아래 예제에서 ==와 equals 동작이 동일하게 true로 출력된다.그리고 같은 값이라도 이 참조 주소를 다르게 설정하고자 new String()으로 객체를 생성하게 되는 경우 참조 동등성(==)을 비교하면 false가 반환된다. 1234567891011121314151617String str1 = &quot;a&quot;;String str2 = &quot;a&quot;;if (str1 == str2) System.out.println(&quot;string Identity&quot;);if (str1.equals(str2)) System.out.println(&quot;string Equality&quot;);String strNew1 = new String(&quot;b&quot;);String strNew2 = new String(&quot;b&quot;);if (strNew1 == strNew2) System.out.println(&quot;stringNew Identity&quot;);if (strNew1.equals(strNew2)) System.out.println(&quot;stringNew Equality&quot;);/** 출력 string Identity string Equality stringNew Equality*/ 코틀린에서는 new 키워드가 없어 다음 세 가지를 비교하면 이러하다. 12345678910111213fun main() { val str1: String = &quot;a&quot; val str2: String = &quot;a&quot; if (str1 == str2) println(&quot;string == Equality&quot;) if (str1.equals(str2)) println(&quot;string equals() Equality&quot;) if (str1 === str2) println(&quot;string Identity&quot;)}/** 출력 string == Equality string equals() Equality string Identity*/ Nullable 값자바에서는 NPE를 방지하기 위해 equals()에서도 수신 객체가 널인 경우 악명높은 NPE(Null Point Exception) 오류가 나기 때문에 null이 아님을 보장하기 위해 obj != null과 같이 조건문을 추가해 주어야 한다. 12String obj = null;if (obj.equals(something)) {} // NPE 반면, 코틀린에서는 ==와 != 두 연산자로 비교하는 값이 null이라도 오류가 나지 않는다. 연산자의 왼쪽 피연산자가 null인 경우에는 참조 동등성을 사용해 널과 비교하면 된다. (adsbygoogle = window.adsbygoogle || []).push({}); 참고알렉세이 세두노프 &lt;코틀린 완벽 가이드&gt;","link":"/2022/04/18/021-kotlin-equality-and-identity/"},{"title":"[Android] Android 11 대응 - 2. 범위 지정 저장소 적용","text":"동작 변경사항: Android 11을 타겟팅하는 앱 이 글은 실제로는 2021.01에 작성되어 일부 업데이트된 내용이 누락되었을 수 있음을 미리 밝힙니다. 1. 내부 저장소와 외부 저장소내부 저장소에 저장된 파일은 애플리케이션 전용이며 다른 애플리케이션에서는 액세스 할 수 없다. 내부 저장소는 /data/data/com.example.testapp/ 이와 같은 경로를 말한다. 외부 저장소는 내부 저장소(UT) 또는 이동식 저장소의 어느 위치에나 있을 수 있다. 휴대전화의 OEM 및 Android OS 버전에 따라 달라질 수 있으므로 단말 기종마다 저장되는 위치가 다르다. /sdcard 및 /storage/emulated/0 와 같은 형식의 패스는 외부 저장소를 가리킨다. 그러나 이것들은 /storage/sdcard0 대한 심볼릭 링크이기 때문에 (예전에는 된 것 같지만) 현재는 이와 같은 패스를 하드코딩하여 사용하지 않는 게 좋다. 2. 접근 권한 READ_EXTERNAL_STORAGE WRITE_EXTERNAL_STORAGE 접근 권한은 위와 같이 잘 알려진 두 가지가 있으나 Android 11부터 WRITE_EXTERNAL_STORAGE만 권한허용을 해도 READ_EXTERNAL_STORAGE 권한은 자동으로 부여되도록 변경되었다. Any app that declares the WRITE_EXTERNAL_STORAGE permission is implicitly granted this permission.역&gt; WRITE_EXTERNAL_STORAGE 권한을 허용한 앱은 내재적으로 READ_EXTERNAL_STORAGE 권한도 허용한다. 3. 안드로이드 P이하에서의 저장소 링크 앱 데이터 폴더 : /storage/Android/data/[앱의 package name]/ 공용 폴더(DCIM, Pictures 등): /storage/[폴더 이름] 4. 안드로이드 Q이상에서의 범위 지정 저장소(Scoped Storage) Android 10(API 수준 29) 이상을 타겟팅하는 앱에는 기본적으로 외부 저장소로 범위가 지정된 액세스 권한 또는 범위 지정 저장소가 부여됩니다. - 범위지정 저장소 Android 10에서는 선택적으로 범위지정 저장소를 사용하거나 사용하지 않을 수 있다. Android 11(Q)이상부터는 강제로 바뀌는데, 범위지정 저장소는 아래와 같은 구조로 되어있다. 지칭하는 용어도 위치, 접근하는 방법(코드)도 완전히 바뀌기 때문에 Android 11 업데이트에서 가장 대응하기 난감했던 부분이다. 앱 데이터 폴더(App specific directory) 미디어 파일들(MediaStore) 공용 파일들(Storage Access Framework) (adsbygoogle = window.adsbygoogle || []).push({}); 5. 관련 이슈 java.io.FileNotFoundException: /storage/emulated/0/mediapicker/images/c.png: open failed: ENOENT (No such file or directory) 기존에 사용하던 파일 접근 로직을 사용하는 중이라면 위와 같이 FileNotFoundException ENOENT error를 보게 된다. 원래 읽어오던 파일 또는 파일의 위치에 접근할 수 없어서 “찾을 수 없다”는 에러를 띄우는 것이다. 6. 변경 사항 /sdcard 의 접근이 불가능해진다. 외부 저장소의 최상위 경로를 반환하는 Enviroment.getExternalStorageDirectory()는 Android 10(API 29)부터 deprecated 되었고, 위에서 말한 것처럼 Android 11에서는 더이상 사용할 수 없다. 7. Android 10 호환성을 위해 유지할 것Android 11에서는 해당 속성은 무시된다. 하지만 Android 10 호환성을 위해 requestLegacyExternalStorage=true 값을 유지해야 한다. 8. 문제가 될만 한 호출 메소드다음 두 개의 메소드는 Android 10(API 29)부터 deprecated 되니 Context#getExternalFilesDir() 또는 MediaStore, Intent#ACTION_OPEN_DOCUMENT로 대체해야 한다. (1) getExternalStorageDirectory1public static File Environment#getExternalStorageDirectory() Context#getExternalFilesDir()로 대체한다. 이 방식을 사용하는 건 다음 두 개를 만족하는 경우이다. 앱이 삭제되면 같이 지워져도 된다. 외부에서 사용할 수 있도록 공공 저장소에 저장해도 된다. (2) getExternalStoragePublicDirectory1public static File Environment#getExternalStoragePublicDirectory(String type) 이는 사진 및 영화와 같이 잘 알려진 파일 유형을 저장하기 위한 중앙 집중식 장소이다. 이 디렉토리와 내용은 앱을 제거할 때 삭제되지 않는다.(ex 위치: DCIM) MediaStore 또는 Intent#ACTION_OPEN_DOCUMENT 사용하여 대체 ACTION_OPEN_DOCUMENT는 파일을 선택할 수 있는 파일 탐색기가 뜨도록 유도할 수 있으며, MediaStore를 사용한 예는 아래와 같다. 1234567891011121314151617181920212223242526272829303132333435363738if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.Q) { SimpleDateFormat format1 = new SimpleDateFormat(&quot;yyyy-MM-dd_HH:mm:ss&quot;); String fileName = format1.format(System.currentTimeMillis()) + &quot;.jpg&quot;; ContentValues values = new ContentValues(); // DCIM/ 또는 Pictures/ 이외의 장소에 접근하려고 하면 오류 values.put(MediaStore.Images.Media.RELATIVE_PATH, &quot;DCIM/&quot; + CommConstants.FOLDER_DIRECTORY); values.put(MediaStore.Images.Media.DISPLAY_NAME, fileName); values.put(MediaStore.Images.Media.MIME_TYPE, &quot;image/*&quot;); values.put(MediaStore.Images.Media.IS_PENDING, 1); // 파일을 write중이라면 다른곳에서 데이터요구를 무시 ContentResolver contentResolver = getContentResolver(); Uri collection = MediaStore.Images.Media.getContentUri(MediaStore.VOLUME_EXTERNAL_PRIMARY); Uri item = contentResolver.insert(collection, values); ParcelFileDescriptor imageFile = null; try { // Uri(item)의 위치에 파일을 생성해준다. imageFile = contentResolver.openFileDescriptor(item, &quot;w&quot;, null); if (imageFile != null) { InputStream inputStream = getImageInputStream(bitmap); byte[] strToByte = getBytes(inputStream); FileOutputStream fos = new FileOutputStream(imageFile.getFileDescriptor()); fos.write(strToByte); fos.close(); inputStream.close(); imageFile.close(); contentResolver.update(item, values, null, null); } } catch (IOException e) { e.printStackTrace(); } if (imageFile != null) { values.clear(); values.put(MediaStore.Images.Media.IS_PENDING, 0); // 파일을 모두 write하고 다른곳에서 사용할 수 있도록 0으로 업데이트 contentResolver.update(item, values, null, null); }} (3) MediaStore.MediaColumns.DATA 칼럼 접근 불가 query issue: invalid column latitude MediaStore.MediaColumns.DATA 칼럼이 android 10부터 deprecated되어 접근할 수 없어서 발생하는 이슈이다. 12345678910111213141516public static String getRealPathFromURI(Context context, Uri contentUri) throws SecurityException { String res = null; String[] proj = {MediaStore.MediaColumns.DATA, MediaStore.MediaColumns.DISPLAY_NAME}; Cursor cursor = context.getContentResolver().query(contentUri, proj, null, null, null); if (cursor != null &amp;&amp; cursor.moveToFirst()) { int columnIndex = (contentUri.toString().startsWith(&quot;content://com.google.android.gallery3d&quot;)) ? cursor.getColumnIndexOrThrow(MediaStore.MediaColumns.DISPLAY_NAME) : cursor.getColumnIndexOrThrow(MediaStore.MediaColumns.DATA); res = cursor.getString(columnIndex); cursor.close(); } if (TextUtils.isEmpty(res)) { res = contentUri.getPath(); } return res;} 따라서 이미지는 Q 미만일 때 위의 코드를 그대로 사용하면서, 비디오를 업로드할 경우는 아래의 코드를 통해 새로 카피본을 만들어 File을 받아 처리하도록 한다. 12345678910111213141516171819202122public static File getVideoFile(Context context, Uri contentUri) throws SecurityException { ContentResolver contentResolver = context.getContentResolver(); String filePath = context.getApplicationInfo().dataDir + &quot;/&quot; + UPLOAD_FILE_NAME_ORIGIN_VIDEO; File file = new File(filePath); if (file.exists()) { return file; } try { InputStream inputStream = contentResolver.openInputStream(contentUri); OutputStream outputStream = new FileOutputStream(file); byte[] buf = new byte[1024]; int len = 0; while((len = inputStream.read(buf)) &gt; 0) { outputStream.write(buf, 0, len); } outputStream.close(); inputStream.close(); } catch (IOException e) { e.printStackTrace(); } return file;} (adsbygoogle = window.adsbygoogle || []).push({}); 9. 파일 저장 위치이미지의 경우, 사진 및 스크린샷을 포함하며 DCIM/ 및 Pictures/ 디렉터리에 저장된다. 시스템은 이러한 파일을 MediaStore.Images 테이블에 추가한다. 즉, 파일 탐색기에서 Images 영역에 가면 저장한 파일을 확인할 수 있다. 만약 DCIM/ 또는 Pictures/ 이외의 장소에 접근하려고 하면 아래와 같은 에러가 뜬다. Caused by: java.lang.IllegalArgumentException: Primary directory TestDir not allowed for content://media/external_primary/images/media; allowed directories are [DCIM, Pictures] 이미지 외의 파일 종류에 관해서는 Android Developer - 공유 저장소의 미디어 파일에 액세스를 참조할 것. 10. Android 10 애뮬레이터 테스트 그런데 이 설정을 하지 않아도 Android 11 애뮬레이터로 처음 실행했을 때 관련 이슈는 바로 재현 가능했으니 참고 하시기. 테스트를 위해 필요한 플래그는 다음의 두 가지이다. DEFAULT_SCOPED_STORAGE(기본적으로 모든 앱에 사용 설정됨) FORCE_ENABLE_SCOPED_STORAGE(기본적으로 모든 앱에 사용 중지됨) FORCE_ENABLE_SCOPED_STORAGE 플래그를 설정하기 위해 시스템 &gt; 고급 &gt; 개발자 옵션 &gt; 앱 호환성 변경사항 &gt; 앱 &gt; 에서 FORCE_ENABLE_SCOPED_STORAGE 항목을 찾아 on 시킨다.","link":"/2022/02/16/017-android11-scoped-storage/"},{"title":"[Android] Android 11 대응 - 1. 패키지 공개 상태","text":"변경사항 확인해보는 방법 문제가 될만 한 호출 메소드 packageManager.getInstalledApplications() 또는 packageManager.getInstalledPackages() packageManager.resolveActivity(intent, 0) packageManager.queryIntentActivities(intent, flags) packageManager.getPackageInfo(&quot;packageName&quot;, flags) packageManager.getLaunchIntentForPackage(packageName) (adsbygoogle = window.adsbygoogle || []).push({}); 방법 1. QUERY_ALL_PACKAGESQUERY_ALL_PACKAGES 권한을 추가하면 모든 앱을 찾거나 실행할 수 있다. 이 퍼미션은 어떤 앱이든 받을 수 있는 Install permission이다. 1&lt;uses-permission android:name=&quot;android.permission.QUERY_ALL_PACKAGES&quot; /&gt; 방법 2. &lt;queries&gt; 태그gradle version 확인하기queries 태그를 사용하기 위한 준비작업이다. 좌측과 같은 버전을 사용하고 있다면 우측 이상에 해당하는 버전이 맞는지 확인해야 한다. queries 태그 사용이제 의존성을 가진 모든 앱의 패키지 정의를 queries 태그에 추가 적용한다. 사용 사례별로 패키지 공개상태 구성 Android11에서는 기본적으로 자신의 앱이 아닌, 다른 패키지를 찾거나 다른 패키지의 액티비티를 실행할 수 없다. 따라서 자신의 앱 동작에 의존적인 패키지가 있다면 AndroidManifest에 &lt;queries&gt; 태그로 필요한 패키지를 정의해야 한다. 다시 말해, 자신의 앱에서 다른 앱을 찾거나(탐색), 다른 앱을 실행하는 동작이 필요할 경우 그 앱의 패키지를 미리 자신의 앱에 정의해두어야 한다. 123456789101112&lt;!-- manifest 태그에 package 속성을 정의하는 것은 optional --&gt;&lt;manifest package=&quot;com.example.game&quot;&gt; &lt;queries&gt; &lt;package android:name=&quot;com.example.store&quot; /&gt; &lt;package android:name=&quot;com.example.services&quot; /&gt; &lt;intent&gt; &lt;action android:name=&quot;android.intent.action.SEND&quot; /&gt; &lt;data android:mimeType=&quot;text/plain&quot; /&gt; &lt;/intent&gt; &lt;/queries&gt; ...&lt;/manifest&gt;","link":"/2022/02/14/016-android11-package/"},{"title":"[Android] Android 12 변경사항 일부 요약","text":"2021.12월 출시예정 Android 12 개발자 프리뷰 (2021.05.18) [바이라인 네트워크] 구글 I/O 2021 키노트 총정리 Google Developer Korea - Android 12 Beta 2 업데이트를 확인하세요 (2021.07.01) 이하는 보편적으로 크게 영향있을 것 같은 것만 추렸다. Android 12 업데이트 관련하여 따로 targetSDK를 바꾸어 대응하지 않았기 때문에 간략하게만 요약하였다. Android Developer - 동작 변경사항: 모든 앱신뢰할 수 없는 터치 이벤트가 차단됨 이 변경사항은 FLAG_NOT_TOUCHABLE 플래그 등을 사용하여 터치가 창을 통과할 수 있도록 하는 앱에 영향을 줍니다. 어떤 오브젝트가 화면을 가리고 있는데 그 아래에 위치된 오브젝트를 터치하고자 할 때 이 터치를 허용할지에 관한 내용이다.. 동작 변경사항: Android 12를 타겟팅하는 앱에만 영향 앱이 Android 12를 타겟팅하고 인텐트 필터를 사용하는 활동이나 서비스, broadcast receiver를 포함하면 이러한 앱 구성요소의 android:exported 속성을 명시적으로 선언해야 합니다. 예를 들자면 아래와 같다. 123456&lt;service android:name=&quot;com.example.app.backgroundService&quot; android:exported=&quot;false&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;com.example.app.START_BACKGROUND&quot; /&gt; &lt;/intent-filter&gt;&lt;/service&gt;","link":"/2022/02/17/018-android12-summary/"},{"title":"[Android] 상하 스크롤 중 내부 RecyclerView의 좌우 스크롤 유지","text":"1. 상황현재 한 Activity가 상하 스크롤이 되는 RecyclerView로 구성되어 있고, 그 아이템 중 하나가 좌우 스크롤 RecyclerView를 가지고 있다. RecyclerView는 View를 재사용하기 때문에 item1, item2, …의 뷰를 그릴 때 item1에서 사용한 뷰를 n번째 item에서 재사용할 수 있다. 따라서 다시 item1을 그릴 때 View를 초기화하게 되므로 item 내의 RecyclerView 스크롤이 초기화된다. 즉, item1의 좌우 스크롤을 움직인 후 아래로 스크롤링하고 item1 위치로 다시 돌아왔을 때 그 좌우 스크롤이 처음으로 되돌아가있는 이슈가 발견되었다. 2. 해결1234val pos = (rv.layoutManager as LinearLayoutManager?)?.findFirstCompletelyVisibleItemPosition() ?: -1if (pos != -1 &amp;&amp; scrollInfo?.scrollPos != pos) { scrollInfo?.scrollPos = pos} 이렇게 하면 일단 현재 보고있는 item의 position을 얻어와 저장할 수 있다. 이 동작을 사용하여 아래와 같이 OnScrollListener에서 scrollPos와 scrollOffset을 저장한다. scrollOffset은 scrollPos만으로는 해당 item의 맨 앞부분으로 스크롤이 움직이기 때문에 이를 현재 스크롤하던 위치로 옮겨주기 위함이다. 12345678910rv.addOnScrollListener(object : RecyclerView.OnScrollListener() { override fun onScrolled(recyclerView: RecyclerView, dx: Int, dy: Int) { super.onScrolled(recyclerView, dx, dy) val pos = (rv.layoutManager as LinearLayoutManager?)?.findFirstCompletelyVisibleItemPosition() ?: -1 if (pos != -1 &amp;&amp; scrollInfo?.scrollPos != pos) { scrollInfo?.scrollPos = pos } scrollInfo?.scrollOffset = rv.computeHorizontalScrollOffset() }}) 그리고 저장한 scrollOffset을 사용하여 스크롤을 유지할 수 있는 함수는 아래와 같이 구성하였다. 12345678910private fun keepScroll(scrollInfo: ScrollInfo) { var offset = 0 if (scrollInfo.scrollPos &lt; goodsList.size - 2) { offset = scrollInfo.scrollOffset while (offset &gt; itemWidth) { offset -= itemWidth } } (rv.layoutManager as LinearLayoutManager).scrollToPositionWithOffset(scrollInfo.scrollPos, offset)} (adsbygoogle = window.adsbygoogle || []).push({}); 3. 번외scrollToPositionWithOffset이 position과 offset 값을 받는 걸 이용하여, position은 0으로 고정하고 offset을 rv.computeHorizontalScrollOffset()을 저장한 값으로 넘겨주면 될 거라고 생각했으나 기대한대로 동작하지 않았다. 1(rv.layoutManager as LinearLayoutManager).scrollToPositionWithOffset(0, offset)","link":"/2022/04/20/022-keep-horizontal-scroll-when-scrolling-vertically-other-recyclerview/"},{"title":"[Kotlin] Ticker(티커) 모드 차이(TickerMode.FIXED_PERIOD, FIXED_DELAY)","text":"개발 환경: Kotlin 1.6 coroutines 라이브러리에는 **티커(ticker)**라고 하는 특별한 랑데부 채널이 있다. 이 채널은 Unit 값을 계속 발생시키되 한 원소와 다음 원소의 발생 시점이 주어진 지연 시간만큼 떨어져 있는 스트림을 만든다. 여기서 랑데부 채널이란 내부 버퍼가 없어 이 채널에서의 send() 호출은 다른 어떤 코루틴이 receive()를 호출할 때까지 항상 일시 중단된다. 마찬가지로 receive() 호출은 다른 어떤 코루틴이 send()를 호출할 때까지 일시 중단되는 특성을 가진다.즉, 랑데부 채널은 생산자와 소비자 코루틴이 교대로 활성화되도록 보장한다. 티커 채널을 만들려면 ticker()라는 함수를 사용한다. 123456789101112import kotlinx.coroutines.*import kotlinx.coroutines.channels.*fun main() = runBlocking { val ticker = ticker(100) // TickerMode.FIXED_PERIOD println(withTimeoutOrNull(50) { ticker.receive() }) println(withTimeoutOrNull(60) { ticker.receive() }) delay(250) println(withTimeoutOrNull(1) { ticker.receive() }) println(withTimeoutOrNull(60) { ticker.receive() }) println(withTimeoutOrNull(60) { ticker.receive() })} 12345nullkotlin.Unitkotlin.Unitkotlin.Unitnull (adsbygoogle = window.adsbygoogle || []).push({}); 0ms ~ 50ms(타임아웃): 50ms(밀리초) 내에 티커 신호를 받으려고 시도하나, 티커 지연 시간이 100ms이므로 withTimeoutOtNull()은 신호를 받지 못하고 타임아웃이 걸려 널을 반환한다. 50ms ~ 100ms: 타임아웃이 1회 난 후 다음 60ms 안에 신호를 받으려고 시도한다. 그리고 이번에는 50 + 60ms가 100ms 보다 길기 때문에 결괏값을 얻는다. receive()가 호출되면 티커가 재개된다. 2_1. 100ms ~ 350ms: 이때 소비자 코루틴이 약 250ms 동안 일시 중단된다. 일시 중단으로부터 100ms 후에 티커는 다른 신호를 보내고 신호가 수신될 때까지 일시 중단된다. 그리고 소비자 코루틴과 티커 코루틴 모두 150ms 동안 일시 중단 상태로 남는다. 350ms: 소비자 코루틴이 재개되고 신호를 요청하려고 시도한다. 신호가 이미 보내졌기 때문에 receive()는 즉시 결과를 반환한다. 3_1. 이제 티커는 마지막 신호를 보내고 나서 얼마나 시간이 지났는지 검사하고(250ms), 지연 시간을 50ms로 줄인다. 350ms ~ 400ms: 소비자는 50ms 타임아웃 안에 신호를 받으려고 시도한다. 다음 신호가 50ms 이전에 보내졌기 때문에 이 시도는 거의 확실히 성공할 것이다. 400ms ~ 460ms(타임아웃): 마지막으로, 신호를 받으려는 receive() 호출이 거의 즉시 일어난다. 따라서 티커는 전체 지연 시간(100ms)를 다시 기다린다. 그 결과, 마지막 receive() 호출은 60ms 타임아웃 안에 티커로부터 신호를 받지 못하기 때문에 널을 받는다. 티커 모드를 FIXED_DELAY로 고정하면 결과가 다음과 같이 바뀐다. 12345nullkotlin.Unitkotlin.Unitnullkotlin.Unit 초반부는 앞의 예제와 비슷하게 진행된다. 하지만 250밀리초의 긴 지연 이후 소비자 코루틴이 재개될 때부터는 동작이 달라진다. 350ms: 소비자 코루틴이 재개되고 신호를 요청하려고 시도한다. 신호가 이미 보내졌기 때문에 receive()는 즉시 결과를 반환한다. 3_1. receive()로 결과를 넘긴 시점에서 티커는 현재시간을 고려하지 않고 여기서부터 100ms를 다시 기다린다. 350ms ~ 410ms(타임아웃): 티커가 신호를 보내려면 40ms 남았으므로 널을 받는다. 410ms ~ 450ms: 3_1에서 티커가 재개된 시간으로부터 100ms가 지났으므로 결과를 무사히 반환받는다. 참고알렉세이 세두노프 &lt;코틀린 완벽 가이드&gt; (adsbygoogle = window.adsbygoogle || []).push({});","link":"/2022/04/30/023-ticker-in-coroutines-library/"},{"title":"[Android &#x2F; Glide] Glide 이미지 로딩 중 다른 scaleType 적용하기","text":"Glide 동작을 테스트하면서 아래와 같은 상황이 발생하였다. 기존에 사용하던 로딩이미지의 ScaleType은 CENTER를 사용해야 한다. Glide로 로드한 이미지는 로딩이미지와는 다른 각자의 ScaleType을 가지고 있다. 따라서 loadingImage와 loadedImage의 ScaleType을 외부에서 설정만 해주면 내부에서 자동으로 바꿔서 보여주도록 만들고자 했다. 이 작업을 위해 Glide에서는 이미지 로딩 중 placeholder 노출, 리소스 로드 등의 동작을 확장 구현할 수 있도록 Target을 제공한다는 점을 먼저 말해두겠다. 이 Target은 into()를 통해 전달할 수 있다. 123456Target&lt;Drawable&gt; target = Glide.with(fragment) .load(url) .into(new Target&lt;Drawable&gt;() { ... }); 이러한 Target를 상속받는 클래스를 만들어서 placeholder는 onLoadStarted, error는 onLoadFailed에 각각 정의하려고 한다. 이때 로딩이미지는 drawable 리소스로 앱에 저장되어있기 때문에 DrawableImageViewTarget을 상속받아 만든 게 아래와 같다. (adsbygoogle = window.adsbygoogle || []).push({}); 1234567891011121314151617181920212223242526272829303132333435363738394041public class ScaleLoadingImageViewTarget extends DrawableImageViewTarget { private ImageView.ScaleType mLoadingScaleType; private ImageView.ScaleType mReadyScaleType; // RequestOptions에서 정의해둔 scale은 fitCenter public ScaleLoadingImageViewTarget(ImageView view, ImageView.ScaleType scaleType) { super(view); // loadingCenter()에서 받아온 scale mLoadingScaleType = scaleType; // xml에서 정의해둔 scale // (따로 정의되지 않았다면 여기에 RequestOptions scaleType인 fitCenter가 들어옴 mReadyScaleType = view.getScaleType(); } @Override public void onLoadStarted(@Nullable Drawable placeholder) { ImageView imageView = getView(); imageView.setScaleType(mLoadingScaleType); super.onLoadStarted(placeholder); } @Override public void onLoadFailed(@Nullable Drawable errorDrawable) { ImageView imageView = getView(); imageView.setScaleType(mLoadingScaleType); super.onLoadFailed(errorDrawable); } @Override public void onResourceReady(@NonNull Drawable resource, @Nullable Transition&lt;? super Drawable&gt; transition) { ImageView imageView = getView(); imageView.setImageResource(0); // 로딩 이미지가 보여지고 있을 때 scaleType이 바뀌면서 이미지가 덜그럭 거리는 이슈 방어 imageView.setScaleType(mReadyScaleType); super.onResourceReady(resource, transition); } @NonNull public static ScaleLoadingImageViewTarget loadingCenter(ImageView imageView) { return new ScaleLoadingImageViewTarget(imageView, ImageView.ScaleType.CENTER); }} loadingCenter 메소드를 통해 위에 새롭게 정의된 Target에 접근할 수 있도록 한다. 12345Glide.with(context) .load(url) .listener(listener) .apply(options) .into(ScaleLoadingImageViewTarget.loadingCenter(imageView)); 참고링크 Allow a different scale type for placeholder images · Issue #368 · bumptech/glide 그러나 이 방식을 적용한 ImageView가 담긴 RecyclerView를 구현하게 되면, RecyclerView 각 아이템이 재사용되면서 ScaleLoadingImageViewTarget의 생성자에서 호출하는 view.getScaleType()의 값이 기대한 대로 나오지 않는 경우가 있어 문제가 될 수 있다. 따라서 이를 아래와 같이 view의 ScaleType을 명시적으로 받도록 변경하였다. 12345Glide.with(context) .load(url) .listener(listener) .apply(options) .into(ScaleLoadingImageViewTarget.loadingCenter(imageView, ScaleType.FIT_CENTER)); 12345678910public ScaleLoadingImageViewTarget(ImageView view, ImageView.ScaleType originScaleType, ImageView.ScaleType loadingScaleType) { super(view); mLoadingScaleType = loadingScaleType; mReadyScaleType = originScaleType;}@NonNullpublic static ScaleLoadingImageViewTarget loadingCenter(ImageView imageView, ImageView.ScaleType originScaleType) { return new ScaleLoadingImageViewTarget(imageView, originScaleType, ImageView.ScaleType.CENTER);} (adsbygoogle = window.adsbygoogle || []).push({});","link":"/2022/05/02/024-allow-the-different-scaletype-when-loading-image-in-glide/"},{"title":"I&#39;m eating a book","text":"안드로이드 프로그래밍 Next Step Read started from 2022.06.18 종이책 출간일: 2017.06.05 저자: 노재춘 이게 2017년 책이라 오래 됐지만, dumpsys를 사용하는 예시를 좀 더 알고 싶어서 관련 책을 찾다가 서점에서 파라락 보고 훌쩍 사왔다. 그런데 생각지도 못하게 4, 5장에서 Context와 Task에 관해 좀 더 자세히 알게 되었다. 4장 Context ContextWrapper/ContextImpl와 Activity/Service/Application에 관한 관계성 사용 가능한 Context의 차이점: Activity, getBaseContext(), getApplicationContext() 5장 Task 및 dumsys Task에 관한 설명은 기본적인 dumpsys 사용법 설명에서 얻어걸렸다. adb shell dumpsys activity a라는 명령어의 매우 기다란 결과 로그 중 기본적인 키워드를 설명해준다. Task 속성: singleTop, singleTask 등 Manifest의 launchMode 속성 및 Intent 플러그 설명이 태스크에 관한 설명과 콜라보되어 동작이 자세히 나와 있다. 그 외 장 위 명령어 말고도 dumpsys의 다양한 옵션에 대한 예시가 있어 어떤 경우에 어떤 옵션으로 명령어를 사용하면 될지 감을 잡는 데에 개인적으로 도움이 됐다. 실무에 바로 적용하는 안드로이드 프로그래밍 Read started from 2022.05.03 종이책 출간일: 2021.03.25 저자: 크리스틴 마시케노, 브라이언 가드너, 빌 필립스, 크리스 스튜어트 액티비티의 생명주기를 State를 기준으로 표현한 다이어그램은 기존 Android Developer에 있는 것보다 훨씬 보기 좋더라. 전체적으로 약간 딥한 부분까지 설명이 잘 되어있다.예를 들어, onSaveInstanceState를 액티비티 레코드와 같이 설명해주거나, MVVM 뷰모델 vs Jetpack ViewModel의 차이를 설명해주는 등 상세하고 최신 내용이 잘 반영되어있다. 예제 코드가 모두 코틀린으로 되어있는 점도 그렇다. 안드로이드를 공부하는 사람이라면 기본서 다음 두 번째 책으로 적절할 것 같다. 안드로이드/자바/코틀린의 기초 문법을 설명해주지는 않아서. 이 책에는 외부 라이브러리를 사용한 예제는 테스팅 코드를 제외하고는 없다. 의존성 주입을 위한 Dagger2나 Lint 예제는 &lt;아키텍처를 알아야 앱 개발이 보인다&gt;(옥수환)에 있으니 참고 하시기. 코틀린 완벽 가이드 Read started from 2022.04.01 종이책 출간일: 2022.03.18 저자: 알렉세이 세두노프 코틀린에 대해 하나부터 열까지 상세한 코드 예제와 함께 설명이 수록되어있어 읽는데 막힘 없이 읽을 수 있어 코틀린 입문에 좋을 것으로 보인다. 구체적으로는 아래 항목이 있다. 데이터 타입 다루는 법 각종 클래스의 특징 제네릭 자바와의 상호 운용성 (아주 친절한 설명!) 동시성 테스팅 기본을 탄탄히 하는 데는 Kotlin Guide보다 한국어라는 점에서 책을 보는 게 더 나을 것 같다. 코틀린에 관해 원하는 것은 대부분 이 책에서 얻을 수 있으리라.. 덧붙여 이 책은 Kotlin 1.6을 기준으로 쓰였으며 어느 하위 버전에서 어떤 업데이트가 있었는지도 중요한 부분은 설명이 되어있다.","link":"/2022/06/14/025-reading-a-delicious-book/"},{"title":"[후기] 안드로이드 뜻밖의 역사","text":"이 책은 Androids: The Team that Built the Android Operating System 전문을 번역한 책이며, 영문으로는 해당 링크에서 무료로 볼 수 있다. Read started from 2022.08.26 출간일: 2022.08.19 저자: 쳇 하스 출판사: 인사이트 - (adsbygoogle = window.adsbygoogle || []).push({}); 나는 이 책을 기술적인 세부 내용을 아는 소프트웨어/하드웨어 엔지니어 말고도 누구나 읽기를 바란다._1부 中 책을 읽기 전 팔락팔락 넘기다가 SCSI 단어가 나오길래 비관련 종사자는 읽기 힘들거라고 생각했는데, 책을 처음부터 읽는다면 미리 설명한 사람들이 나와서 알만한 이야기를 한다. 이 책에서 나는, 안드로이드 1.0을 릴리즈하기 위한 열정 안드로이드 내부 기능 각각이 탑재된 배경 안드로이드 OS가 시장에 나오기까지의 과정 세 가지를 중점적으로 봤기 때문에 이런 부분을 기대한다면 읽기 불편할 것 같진 않다고 생각했다. 첫 번째, 열정.다 읽고 나면 안드로이드라는 새로운 운영 체제를 위해 함께 토론하고 결정하며 달려온 기분을 맛볼 수 있다. 역사를 공유하고 있다는 확고한 느낌이 있었죠._1장 中 이 책을 읽은 시기가 마침 회사에서 안드로이드 개발자로 일하면서 두 가지를 고민하던 때였다. 내가 ‘왜’ 여기 있는 거지? 물론 안드로이드 개발을 하고 있었으나 나는 내가 좋아해서 고른 이 직무에 관해 의구심이 생겼다. ‘나는 왜 안드로이드를 좋아했던 거지?’ 지금도 좋아하지 않는 게 아니었다. 그런데 처음 이끌렸던 이유가 기억나지 않았다. 분명히 있을 거라고 생각했고, 나는 지금까지 인생을 회고하면서 그걸 찾아보고자 했다. 그런데 이 책은 표지처럼 안드로이드의 골대를 세우고, 내부 톱니바퀴를 채우고, 외피를 덮는 공정을 밟는다. 그게 뜻밖에도 나에게 도움을 주었다. 자세한 건 여기에 적지 않겠으나, 첫 직장에서 C#을 했었고, 거기서 마음에 들었던 부분이 안드로이드에 있었다는 걸 이 책에서 안드로이드의 내부를 하나하나 짚어주는 걸 따라가면서 발견해냈던 것이다. 그런 점에서 나는 이 책을 읽기 잘했다는 마음이 들었고, 끝까지 재미있게 읽을 수 있었다. 두 번째, 배경.안드로이드의 각 내부기능, 예를 들면 알람, 지도, 웹뷰는 물론이고 선택된 언어, 저장장치 구성, 이미지 렌더링에 관하여 코드로써 다뤄본 적이 있다면 더욱 빠져들 수 있을 것이다. 참고로, 현재 Android Developer의 플랫폼 아키텍처에서는 소프트웨어 스택(흔히 말하길 ‘안드로이드 운영체제 구조’)을 아래와 같이 그림으로 나타내고 있다. 그러나 이건 런타임이 ART(Android 5.0(API 레벨 21) 이상이 실행되는 기기의 기본 런타임)로 바뀐 2022년 버전 구조이고, 이 책에서는 1.0이하를 중점적으로 다루고 있으므로 아래와 같이 런타임에 Dalvik을 사용하는 구조에 가깝다고 볼 수 있겠다. 현업 종사자라면 두 사진을 비교해보는 것도 소소한 즐거움이 되지 않을까. 그림 출처: Anatomy Physiology of an Android (Google IO 2008) “누군가 그걸 좋아했기 때문이 아니라 플랫폼이 성공하려면 타당했기 때문이고 팀이 거기에 적응한 거예요.”_8장 中 의사결정 과정에 대해 다이앤이 한 말이다. 기능의 세부사항들은 모두 당시에 타당한 기준으로 선별되었고, 구성하였음을 알 수 있다. 책에서 재미있게 읽고 기억에 남았던 게 몇 가지 있다. GPU없이 렌더링되던 시절의 이야기 초기 운영체제 모델로 오른 액티비티와 main() 함수 ART 런타임으로 바뀌기 이전의 초기 런타임 형태 View의 스레드 측면 작동 방식 포트 5228에 대한 내용도 잠깐 있었고 내용이 정말 알찼다. 안드로이드의 기능이나 구조를 한 번씩 언급해준다. 개인적으로 웹뷰에 대한 이야기가 길게 이어져서 좋았고, 업데이트 중 메모리 확보 및 보안을 신경쓴 부분도 자세하게 나와서 읽는 재미가 있었다. 1.0 릴리즈까지 타이트한 일정이었으나 결국 제품을 완성하여 최고의 타이밍에 출시한 안드로이드. &lt;세상을 빛낸 Geek&gt;에서는 맥의 화려함을 강조한 모양이나, 나는 &lt;안드로이드 뜻밖의 역사&gt;가 좋다. 안드로이드가 오픈 소스인 점, 앱스토어에서 사용자를 가리지 않은 점. 모두에게 열려있다는 인상, 그리고 개발자 친화적이라는 생각도 들었다. 나는 Android가 좋다:) 다음은 1부에 나오는 에번 밀러의 말을 옮긴 것이다. 이를 마지막으로 후기를 마무리하고자 한다. “처음부터 필연 같은 건 없었어요.안드로이드가 성공하지 못할 이유는 많았죠.똑같은 일을 다시 이뤄 내고 싶다고 해도 할 수 없을 거예요.뭔가 마법이 벌어진 거죠.” (adsbygoogle = window.adsbygoogle || []).push({}); -","link":"/2022/09/28/027-androids-the-team-that-built-the-android-operating-system/"},{"title":"Android","text":"[Microsoft] Java 11 이상으로 이동하는 이유 2022.05.20 작성됨 Java 8에 대한 업데이트가 유료로 전환되어 Microsoft에서는 빠른 시일 내에 11 버전으로 옮기길 권장하고 있다. Java 11로 업그레이드할 경우 장점으로는 모듈: 메모리를 더 적게 쓰고, 클래스 로딩이 빨라진다. GC: Java 8에서는 여러 스레드를 사용하는 병렬 GC를 사용해 속도를 높인 반면, Java 11에서는 G1 가비지 수집기를 사용해 처리량을 높였다. Android Studio Arctic Fox(2020.3.1) 2021.07.28 Download Android Studio Arctic Fox와 JDK 11의 도입 An exception occurred applying plugin request [id: ‘com.android.library’]Failed to apply plugin ‘com.android.internal.library’. Android Gradle plugin requires Java 11 to run. You are currently using Java 1.8. Arctic Fox는 JDK 11 기반으로 되어있어 Gradle도 7.0.x 버전으로 올라갔다. (기존 Android Studio 4.x는 JDK 1.8 기반) 이에 따라 에러 메세지에서는 ‘com.android.library’ 플러그인을 사용하는 데 문제가 있다고 명시해주고 있다. 2022~2023년 Kotlin 팀의 계획: 주요 프로젝트 및 생산성 기능 2022.06.13 JetBrains 2022~2023년 핵심 프로젝트는 다음과 같습니다. Kotlin 릴리스의 품질과 안정성 개선 K2 컴파일러의 베타 버전 출시 Kotlin Multiplatform Mobile의 안정화 버전 출시 K2 지원 플러그인을 포함한 Kotlin IntelliJ IDEA 플러그인의 알파 버전 출시 Kotlin/JS IR 백엔드의 안정화 버전 출시 2022 구글 I/O 2022.05.12 바이라인 네트워크 - 2022 구글 I/O 키노트 총정리, 안드로이드 13, 픽셀 6a, 픽셀 워치, 픽셀 버즈 프로, 보안, 검색 안드로이드 로드맵 2022 2022.01.21 Android Developer Roadmap 2022 The 2022 Android Developer Roadmap 안드로이드 버전 점유율(statistics) 2021.11.21 android-2021-distribution-numbers [Android Developer] 배포 대시보드 Airbnb의 Server-Driven UI 시스템 2021.06.30 Airbnb - A Deep Dive into Airbnb’s Server-Driven UI System(en) Airbnb의 Server-Driven UI(2021.07.21)(ko) Ghost Platform(GP)로 안드로이드의 업데이트가 느리다는 단점을 상쇄하기 위해 UI를 SDUI로 만드는 데에 도움을 주는 플랫폼을 AirBnb에서 만들어 사용하고 있다.","link":"/2022/06/14/026-reading-any-awesome-article/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2022/01/31/hello-world/"},{"title":"[번역: Kotlin Coroutines: Deep Dive] (1) Kotlin Coroutines를 사용하는 이유","text":"이 포스팅은 Kotlin Coroutines: Deep Dive의 글을 번역한 것입니다. 오역, 많은 의역, 생략이 있으니 감안하여 읽어주십시오. 우리가 Kotlin Coroutines을 배우는 이유가 무엇인가? RxJava, Reactor과 같이 이미 잘 만들어진 JVM 라이브러리가 있는데도 말이다. 더욱이 자바는 멀티스레딩을 지원한다. 즉 이미 비동기를 구현하기 위한 다양한 방법이 있다. Kotlin Coroutines는 그것보다도 더 많은 것을 제공한다. 그 중 하나는 멀티플랫폼을 제공한다는 것이다. 즉슨 코틀린 플랫폼 사이에서 코루틴을 사용할 수 있음을 의미한다. 연습해보자. 코루틴과 다른 방법들 사이에 얼마나 차이가 있는지 보라. 아래에서는 안드로이드와 백엔드 비즈니스 로직의 두 가지 전형적인 예시를 보여줄 것이다. 안드로이드(와 다른 프론트엔드 플랫폼)에서 사용하는 코루틴앱 로직을 수행할 때 가장 자주 진행되는 과정은 다음과 같다. API, 데이터베이스 등과 같은 소스의 데이터 가져오기 데이터 가공하기 그 데이터로 뷰에 보여주는 등의 작업 수행하기 더 잘 이해하기 위해 앱을 개발하는 중이라고 가정해보자. API를 통해 뉴스 “정보를 받아와서” 이를 “정렬”하고, “화면에 보여주는” 서비스를 만들 것이다. 원하는 기능을 그대로 넣은 게 다음과 같다. 12345fun onCreate() { val news = getNewsFromApi() val sortedNew = news.sortedByDescending { it.publishedAt } view.showNews(sortedNew)} 슬프지만 이대로 끝나선 안 된다. 안드로이드에서 각 애플리케이션은 뷰를 업데이트하는 데에 단 하나의 스레드를 가지고 사용한다. 이 스레드(Main Thread)는 매우 중요하여 절대 block(차단)되어서는 안 된다. 그런데 위 코드는 이 점을 만족시키지 못한다. 만약 메인 스레드에서 실행되었다면 getNewsFromApi 는 이 스레드를 block할 것이고, 앱은 죽을 것이다. 만약 다른 스레드였다면 앱은 showNews가 호출될 때 죽을 것이다. 이 작업은 메인 스레드에서 수행되어야 하는 작업이기 때문이다. 스레드 변경(switching)이 문제는 스레드를 변경함으로써 해결할 수 있다. 우선 block할 수 있는 스레드에서 메인 스레드로 변경하자. 123456789fun onCreate() { thread { val news = getNewsFromApi() val sortedNew = news.sortedByDescending { it.publishedAt } runOnUiThread { view.showNews(sortedNew) } }} 이러한 스레드 변경은 어떤 앱에서는 여전히 사용하는 방식이긴하다. 그러나 이 방식은 몇가지 문제를 안고 있다. 이 스레드들을 cancel할 수 있는 방도가 없어서 종종 메모리 누수(memory leak) 상태에 직면한다. 스레드 비용이 많이 든다. 빈번한 스레드 변경은 혼란스럽고 관리를 어렵게 만든다. 이 코드는 불필요하게 크고 복잡하다. 당신이 뷰를 연 후 빠르게 닫는 걸 상상해보라. 열 때 몇 개의 스레드들이 시작하며 데이터를 처리한다. 뷰를 닫았음에도 존재하지 않는 뷰를 업데이트하기 위해 이 작업을 cancel하지 않고 계속 진행하게 된다. 불필요하다는 것이다. 이러한 문제에 대해 생각해보며 더 좋은 해결책을 보도록 하자. (adsbygoogle = window.adsbygoogle || []).push({}); 콜백(Callbacks)콜백은 이 문제를 해결하는 방법 중 하나이다. 이 방식은 기능이 non-blocking하게 만든다. 그러나 콜백 함수가 끝나야만이 시작할 수 있는 작업을 수행할 때만 적용할 수 있다. 코드에 적용하면 이렇다. 123456fun onCreate() { getNewsFromApi { news -&gt; val sortedNew = news.sortedByDescending { it.publishedAt } view.showNews(sortedNew) }} 여기서 작업을 cancel 할 수 없음에 주목하라. 취소할 수 있는 콜백 함수를 만들 수도 있을 것이다. 그러나 쉽지 않다. cancel을 위해 각 콜백 함수를 커스텀해야 할 뿐만 아니라 cancel을 할 가능성이 있는 모든 객체를 별도로 수집해야 한다. 123456fun onCreate() { startedCallbacks += getNewsFromApi { news -&gt; val sortedNew = news.sortedByDescending { it.publishedAt } view.showNews(sortedNew) }} 이러한 콜백 구조는 단점이 있다. 이걸 이해하기 위해 더 복잡한 예시를 보자. 세 개의 엔드포인트로부터 데이터를 가져오는 경우이다. 123456789fun showNews() { getConfigFromApi { config -&gt; getNewsFromApi(config) { news -&gt; getUserFromApi { user -&gt; view.showNews(user, news) } } }} 이 코드는 아래와 같은 이유로 완벽과는 거리가 멀다. news와 user 데이터는 사실 동시에 받아와도 된다. 그런데 지금 콜백 구조로는 그럴 수 없다. 전에 말한대로, 다른 더 많은 데이터를 불러오려고 할 때 cancel할 필요가 있다. 요구하는 게 점점 많아질수록 이 코드는 읽기 어려워질 것이다. 그러한 상황을 콜백 지옥(callback hell)이라고 부른다. 콜백을 사용할 때 작업의 순서를 제어하기 힘들다. 인디케이터를 다음과 같이 사용해도 진행도가 제대로 나타나지 않는다. 123456fun onCreate() { showProgressBar() showNews { hideProgressBar() }} 이게 콜백 구조가 어떤 면에서는 완벽하지 않은 이유이다. 다른 접근방식으로 RxJava를 사용한 예를 보자. RxJava와 그밖의 reactive streamsJava에서 유명한 이 대체방식은 reactive streams(또는 Reactive Extensions)를 사용한다. 즉, RxJava 또는 successor Reactor를 말한다. 이 방식으로 말할 것 같으면, 모든 동작은 시작하여(started) 진행된(processed) 관찰되어지는(observed) 데이터 스트림(일련의 작업) 내에서 일어난다. 그래서 종종 앱에서는 동시에 진행되곤 한다. 다음 코드가 RxJava를 사용한 문제 해결 방식이다. 1234567891011fun onCreate() { disposables += getNewsFromApi() .subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .map { news -&gt; news.sortedByDescending { it. publishedAt } } .subscribe { sortedNews -&gt; view.showNews(sortedNews) }} 위 예제에서 disposables은 사용자가 화면을 벗어났을 때 이 스트림을 cancel하기 위한 요소이다. 이는 분명 콜백보다 더 괜찮은 해결책이다. 메모리 누수가 없고, 작업 취소(cancel)를 할 수 있으며 스레드를 사용하는 데도 적절하다. 유일한 문제는 복잡하다는 것이다. 만약 맨처음 코드인 “이상적인” 코드와 비교한다면 공통점이 거의 없음을 알 수 있을 것이다. subscribeOn, observeOn, map 그리고 subscribe라는 함수들을 모두 알아야지만 코드를 이해할 수 있다. cancelling(cancel할 수 있는 기능)은 분명 필요하다. 함수는 Observable이나 Single 클래스 안에 있는 객체를 반환해야 한다. 실제로 RxJava를 소개할 때 흔히 우리 코드를 아래와 같이 바꾼다. 1fun getNewsFromApi(): Single&lt;List&lt;News&gt;&gt; 두 번째 문제를 생각해보자. 데이터를 화면에 보여주기 전에 세 개의 엔드포인트를 호출해야 한다. 이건 RxJava에서는 사실 풀 수 있는 문제다. 그러나 코드가 지금보다 훨씬 더 복잡해진다. 12345678910111213141516fun showNews() { disposables += Observable.zip( getNewsFromApi() .flatMap { getNewFromApi(it) } .subscribeOn(Schedulers.io()), getUserFromApi() .subscribeOn(Schedulers.io()) ) { news: News, user: User -&gt; Pair(news, user) } .subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .subscribe { (news, user) -&gt; view.showNews((news, user)) }} 이 코드는 정말 메모리 누수가 없고, concurrent하다. 그러나 zip, flatMap과 같은 RxJava 함수를 넣어야 하고, Pair로 값을 묶어야 하며, 이 구조를 해제해야 한다. 이 옳은 구현은 정말 복잡하다. 그래서 이번에야말로 코루틴으로 짠 코드를 보도록 하자. (adsbygoogle = window.adsbygoogle || []).push({}); 코틀린 코루틴 사용하기코루틴이 소개하는 핵심 기능은 어떤 지점에서 코루틴을 suspend(일시 정지)하고 후에 다시 resume(재시작) 할 수 있다는 것이다. 이 덕분에 메인 스레드에서 코드를 run(실행)하다가 API 데이터를 요청했을 때 suspend 할 수 있다. 코루틴이 suspend 되었을 때 스레드는 block(차단)되지 않고 뷰를 바꾸거나 다른 코루틴을 진행하는 등에 계속 사용할 수 있다. 데이터가 준비되면 코루틴은 메인 스레드를 기다린다. 드문 상황이지만 코루틴 대기열이 있을 수도 있다. 기다리던 스레드를 사용할 수 있게 되면 중지된 지점부터 계속 진행한다. 123456789101112suspend fun updateNews() { showProgressBar() val news = getNewsFromApi() val sortedNews = news.sortedByDescending { it.publishedAt } view.showNews(sortedNews) hideProgressBar()}suspend fun updateProfile() { val user = getUserData() view.showUser(user)} 123456val scope = CoroutineScope(Dispatchers.Main)fun onCreate() { scope.launch { updateNews() } scope.launch { updateProfile() }} 그림에서 메인 스레드에서 분리된 코루틴으로 실행되는 updateNews와 updateProfile 함수를 보자. 두 함수(또는 코루틴)는 순서가 바뀌어도 된다. 스레드를 block하지 않고 코루틴을 suspend하기 때문이다. updateNews 함수가 네트워크 응답을 기다리고 있을 때 메인 스레드는 updateProfile이 사용한다. 여기서는 사용자 데이터는 이미 캐싱되었기 때문에 getUserData에서 suspend하지 않았다고 가정한다. 그러므로 작업을 완료할 수 있다. 네트워크 응답 시간이 충분하지 않아서 데이터를 받아오는 게 늦어지면 메인 스레드는 그 시간동안 사용되지 않는다(다른 함수가 사용할 수 있다). 데이터를 받으면 메인 스레드를 가져와 getNewsFromApi() 바로 다음 지점부터 시작하여 updateNews를 resume(재개)한다. 정의에 따르면 코루틴은 suspend와 resume이 가능한 컴포넌트다. JavaScript나 Rust, Python과 같은 언어에서 볼 수 있는 async/await나 generators와 같은 개념도 코루틴을 사용하지만 그 기능은 매우 제한적이다. 그래서 첫 번째 문제점은 다음 방식으로 해결한다. 1234567fun onCreate() { viewModelScope.launch { val news = getNewsFromApi() val sortedNews = news.sortedByDescending { it.publishedAt } view.showNews(sortedNews) }} 위 코드에서 현재 안드로이드에서 가장 흔한 viewModelScope를 사용했다. 이걸 대신해서 커스텀 scope를 사용할 수도 있다. 이 코드는 우리가 원하는 것에 거의 가깝다! 이 해결책에서 코드는 메인 스레드에서 run하지만 절대 block 하진 않는다. suspend 기법 덕에 데이터를 기다릴 필요가 있을 때 해당 코루틴을 block 대신 suspend 한다. 코루틴이 일시 정지했을 때 메인 스레드는 진행도를 예쁘게 보여주는 등의 다른 일을 할 수 있다. 그리고 데이터가 준비되면 코루틴은 메인 스레드를 다시 받아 멈췄던 부분부터 다시 시작한다. 그렇다면 어떻게 세 개의 API를 호출할까? 이 또한 유사한 방식으로 만들 수 있다. 12345678fun showNews() { viewModelScope.launch { val config = getCondfigFromApi() val news = getNewsFromApi(config) val user = getUserFromApi() view.showNews(user, news) }} 이 해법은 제법 괜찮아보인다. 그러나 최선은 아니다. API 호출들을 하나가 끝나면 다음 호출을 부르듯, 순서대로 진행되고 있다. 그래서 각 작업이 1초 걸린다고 하면, 전체 함수는 2초가 아닌 3초가 걸린다. 여기서 코틀린 코루틴 라이브러리는 async와 같은 기능을 지원한다. 즉 일부 요청으로 다른 코루틴을 즉시 시작하고 (await 함수로)그 결과가 나중에 도착할 때까지 기다리는 데에 사용할 수 있다. 12345678fun showNews() { viewModelScope.launch { val config = async { getCondfigFromApi() } val news = async { getNewsFromApi(config.await()) } val user = async { getUserFromApi() } view.showNews(user.await(), news.await()) }} 코드는 여전히 단순하고 가독성 있다. 이는 JavaScript나 C#에서 잘 사용되는 async/await 패턴을 이용한다. 효과적이고 메모리 누수도 없다. 단순한데다가 잘 구성되어있기까지 하다. 다른 예제12345678910111213141516171819// 모든 페이지를 동시에 로드하기fun showAllNews() { viewModelScope.launch { val allNews = (0 until getNumberOfPages()) .map { page -&gt; async { getNewsFromApi(page) } .flatMap { it.await() } view.showAllNews(allNews) }}// 다름 페이지를 차례로 로드하기fun showPagesFromFirst() { viewModelScope.launch { for (page in 0 until getNumberOfPages()) { val news = getNewsFromApi(page) view.showNextPage(news) } }} (adsbygoogle = window.adsbygoogle || []).push({});","link":"/2023/11/19/028-kotlin-coroutines-deep-dive-01/"},{"title":"[Kotlin] var &#x2F; val &#x2F; const val &#x2F; companion object 특성","text":"이 포스팅은 아래 Kotlin 공식문서의 일부를 번역(의역) + 의견을 추가한 것입니다. Kotlin 공식문서 / Properties Kotlin 공식문서 / Companion objects var / val변수의 정의가 가변(mutable)하는 경우 var 키워드(variable)를 사용하고, read-only일 경우 val 키워드(value)를 사용한다. 변수의 값이 가변하는 경우가 아니다. 예를 들어, area의 값은 width와 height에 따라 변하지만 정의는 변하지 않는다. 1val area: Int = this.width * this.height 코틀린에서 backing field는 단지 메모리에 값을 유지하기 위해서만 사용되는 것에 불과하다. field는 직접 선언될 수 없으며 변수의 setter나 getter 내에서만 사용할 수 있다. 12345678910var counter = 0 // initializer가 field에 직접 값을 할당한다. set(value) { if (value &gt;= 0) { field = value /* 'counter'라는 실제 변수명을 사용하는 건 setter를 다시 부르는 일이기 때문에 StackOverflow Error가 난다. */ // counter = value } } 이런 식의 암시적인 field 체계 대신 아래와 같이 backing 변수를 만들 수도 있다. 12345678private var _table: Map&lt;String, Int&gt;? = nullpublic val table: Map&lt;String, Int&gt; get() { if (_table == null) { _table = HashMap() // 여기서 파라미터의 타입이 추론된다. } return _table ?: throw AssertionError(&quot;Set to null by another thread&quot;)} const val컴파일 타임 상수이다. 다음 조건을 모두 충족시키는 경우에 해당한다. 최상위 레벨 속성이거나 object나 companion object의 멤버여야 한다. String이나 원시(primitive) 타입으로 초기화되어야 한다. 커스텀 getter를 사용할 수 없다. 컴파일 시 inline 형태로 이 변수를 변수 대신 실제 값으로 대치한다. 그러나 필드가 사라지는 건 아니라서 relection으로 상호작용은 여전히 가능하다. 1const val SUBSYSTEM_DEPRECATED: String = &quot;this subsystem is deprecated&quot; companion object(동반 객체)class 내부에 object 선언은 “companion” 키워드를 써서 할 수 있다. 12345class MyClass { companion object Factory { fun create(): MyClass = MyClass() }} companion object의 멤버는 단순하게 클래스명을 통해 호출할 수 있다. 1val instance = MyClass.create() companion object의 이름은 빼도 되고, 이때는 Companion으로 접근한다. 1234class MyClass { companion object { }}val x = MyClass.Companion 클래스 멤버는 companion object 내의 private 멤버에 접근할 수 있다. (adsbygoogle = window.adsbygoogle || []).push({}); -","link":"/2023/11/20/029-kotlin-var-val-const-companion-object/"},{"title":"[번역: Kotlin Coroutines: Deep Dive] (2) 코틀린 코루틴에서 일시 정지 작업을 하는 방법","text":"이 포스팅은 Kotlin Coroutines: Deep Dive의 글을 번역한 것입니다. 오역, 많은 의역, 생략이 있으니 감안하여 읽어주십시오. 하나의 코루틴을 일시정지하는 것은 중간에 멈추는 것을 의미한다. 이건 세이브한 게임을 멈추고 당신이 다른 일에 집중할 수 있는 상태와 유사하다. 그리고 후에 언제든 세이브포인트에서 게임을 다시 시작할 수 있다. 코루틴은 일시정지하면 Continuation을 반환한다. 이를 사용하여 멈춘 지점에서 다시 시작할 수 있다. 이는 save가 아니라 block하는 스레드와는 매우 다르다는 사실에 주의하라. 코루틴은 매우 강력하다. 일시정지했을 때 어떤 리소스도 사용하지 않는다. 코루틴은 다른 스레드를 다시 시작할 수 있다. (적어도 이론 상으로는) 하나의 continuation은 직렬화, 비직렬화되어있을 수 있고 다시 시작될 수도 있다. 다시 시작12345suspend fun main() { println(&quot;Before&quot;) suspendCoroutine&lt;Unit&gt; { } println(&quot;After&quot;)} 위 코드를 실행하면 “After” 글자를 볼 수 없을 것이다. 그리고 (main 함수는 절대 끝나지 않기 때문에) 코드가 실행을 멈춘 것도 아니다. 우리는 게임을 멈췄지만 다시 시작하지는 않았다. 그렇다면 어떻게 다시 시작할 것인가? 앞서 언급한 Continuation는 어디에 있는가? suspendCoroutine 블록의 람다식을 다시 보자. argument를 받는 이 함수는 일시정지하기 전에 불리워진다. 그때의 매개변수가 continuation이다. 1234567suspend fun main() { println(&quot;Before&quot;) suspendCoroutine&lt;Unit&gt; { continuation -&gt; println(&quot;Before too&quot;) } println(&quot;After&quot;)} 같은 곳에서 다른 함수를 부르는 이러한 함수는 전혀 새로운 것이 아니다. 이는 let이나 apply, useLines와 유사하다. suspendCoroutine 함수는 이와 같은 방식으로 디자인되었다. 즉 일시정지하기 전에 continuation을 사용할 수 있도록 하는 것이다. suspendCoroutine이 호출된 후면 너무 늦을 것이다. 그래서 람다식을 통해 그 전에 부를 수 있도록 한다. 람다는 continuation을 어디서든 저장하거나 이를 다시시작할지 여부를 계획하기도 한다. 즉시 다시 시작하려면 이렿게하면 된다. 123456789suspend fun main() { println(&quot;Before&quot;) suspendCoroutine&lt;Unit&gt; { continuation -&gt; continuation.resume(Unit) } println(&quot;After&quot;)}// Before// After 위에서 “After”가 suspendCoroutine 안에서 resume을 호출했기 때문에 출력되었음에 주의하라. Kotlin 1.3 이후로 Continuation 정의가 바뀌었다. resume과 resumeWithException 대신 하나의 결과값이 있는 resumeWith 함수가 있다. 우리가 사용하고 있는 resume과 resumeWithException 함수는 resumeWith를 사용한 표준 라이브러리에 있는 extension 함수이다. 1234inline fun &lt;T&gt; Continuation&lt;T&gt;.resume(value: T): Unit = resumeWith(Result.success(value))inline fun &lt;T&gt; Continuation&lt;T&gt;.resumeWithException(exception: Throwable): Unit = resumeWith(Result.failure(exception)) 설정된 시간동안 sleep할 다른 스레드를 시작할 수도 있다. 이는 언제든지 다시 시작할 수 있다. 12345678910111213suspend fun main() { print(&quot;Before &quot;) suspendCoroutine&lt;Unit&gt;{ continuation -&gt; thread { print(&quot;Suspended &quot;) Thread.sleep(1000) continuation.resume(Unit) print(&quot;Resumed &quot;) } } print(&quot;After &quot;)}// Before Suspended (1 second delay) After Resumed 중요한 부분이다. 정의된 시간이 끝난 후에 continuation을 다시 시작할 함수를 만들 수 있음에 주목하라. 여기서 continuation은 아래 보이는 것처럼 람다식에 의해 좌우된다. 123456789101112131415fun continueAfterSecond(continuation: Continuation&lt;Unit&gt;) { thread { Thread.sleep(1000) continuation.resume(Unit) }}suspend fun main() { print(&quot;Before &quot;) suspendCoroutine&lt;Unit&gt; { continutaion -&gt; continueAfterSecond(continuation) } print(&quot;After &quot;)}// Before (1 sec) After 이건 오류 없이 작동은 한다. 하지만 단 일 초 동안만 비활성화 상태가 되었다가 끝나는 스레드를 불필요하게 생성한다. 스레드는 비용이 싸지 않은데도 왜 낭비하고 있는가? 더 좋은 방법은 “알람”을 설정하는 것이다. JVM에서 그것을 구현하기 위해 ScheduledExecutorService를 사용했다. 여기서는 정의된 얼마간의 시간 후에 몇 개의 continuation.resume(Unit)을 호출하는 걸로 알람을 설정할 수 있다. 123456789101112131415private val executor = Executor.newSingleThreadScheduledExecutor { Thread(it, &quot;scheduler&quot;).apply { isDaemon = true } }suspend fun main() { print(&quot;Before &quot;) suspendCoroutine&lt;Unit&gt; { continuation -&gt; executorschedule({ continuation.resume(Unit) }, 1000, TimeUnit.MILLISECONDS) } print(&quot;After &quot;)}// Before (1 seconds delay) After 설정한 시간동안 일시정지하는 건 유용한 피처로 보인다. 그러니 이걸 delay라는 함수로 추출해보자. 123456suspend fun delay(timeMillis: Long): Unit = suspendCoroutine { continuation -&gt; executor.schedule({ continuation.resume(Unit) }, timeMillis, TimeUnit.MILLISECONDS) } executor가 여전히 스레드를 사용하고 있지만 delay 함수를 사용하는 모든 코루틴에 한 개의 스레드만을 할당한다. 이 점은 하나의 스레드를 매번 블록하는 것보다는 낫다. 이는 코틀린 코루틴 라이브러리에서 지원하는 delay의 방식이다. 구현은 더 복잡하지만 필수적인 요소는 이렇다. (adsbygoogle = window.adsbygoogle || []).push({}); 어떤 값을 가지고 다시 시작하기resume 함수에서 Unit을 넘겨주는 거에 대해 걱정할 수도 있다. 그러면서 suspendCoroutine의 매개변수로 Unit을 사용하는 이유가 궁금해질 것이다. 이 두가지가 같다는 사실은 우연이 아니다. Unit은 함수로부터 반환되고, Continuation 타입 파라미터는 제네릭 타입이다. 1234val ret: Unit = suspendCoroutine&lt;Unit&gt; { cont: Continuation&lt;Unit&gt; -&gt; cont.resume(Unit) } suspendCoroutine이 호출될 때, 이 continuation에서 반환되는 타입이 어떤 것인지 명확해진다. 그 타입은 resume을 호출할 때 사용되곤 한다. 12345678910111213141516suspend fun main() { val i: Int = suspendCoroutine&lt;Int&gt; { cont -&gt; cont.resume(42) } println(i) // 42 val str: String = suspendCoroutine&lt;String&gt; { cont -&gt; cont.resume(&quot;Some text&quot;) } println(str) // Some text val b: Boolean = suspendCoroutine&lt;Boolean&gt; { cont -&gt; cont.resume(true) } println(b)} 이는 (save-resume) 게임 비유에는 잘 들어맞지 않는다. 저장본을 다시 시작할 때 게임 내에서 어떤 것(값)을 가져올 수 있는 게임을 나는 알지 못한다. 그러나 이 점은 코루틴을 사용하면 완벽하게 이해된다. 종종 우리는 API로부터 네트워크 response를 받는 것처럼 어떤 데이터를 받아오기 위해 대기하곤 한다. 흔한 시나리오다. 스레드는 특정 데이터가 있는 지점에 도달할 때가지 비즈니스 로직을 실행시킨다. 그래서 네트워크 라이브러리에 이를 전달할 것을 요구한다. 코루틴 없이, 이 스레드는 앉아서 기다릴 수밖에 없다. 스레드가 비싼 자원이기 때문에 이는 엄청난 낭비다. 특히 안드로이드의 메인스레드와 같이 중요한 스레드라면 더욱 그렇다. 코루틴을 사용하면 그냥 일시정지 시켰다가, 라이브러리에게 “이 데이터를 받자마자 resume 함수에게 그냥 넘겨”라는 명령과 함께 continuation을 넘기기만 하면 된다. 그러면 스레드는 다른 일을 하러 갈 수 있다. 데이터가 오면 바로 그 스레드는 코루틴이 일시정지한 지점부터 다시 시작할 것이다. 실제로 이를 확인하기 위해 데이터를 수신할 때까지 일시정지하는 방법을 살펴보자. 아래 예제에서는 외부에서 가져온 requestUser 콜백함수를 사용한다. 1234567891011121314suspend fun main() { println(&quot;Before&quot;) val user = suspendCoroutine&lt;User&gt; { cont -&gt; requestUser { user -&gt; cont.resume(user) } } println(user) println(&quot;After&quot;)}// Before// (1 second delay)// User(name=Test)// After suspendCoroutine을 직접 호출하는 것은 편리하지 않다. 대신 suspend 함수를 만드는 것을 선호한다. 그래서 이를 추출할 수도 있다. 1234567891011121314suspend fun requestUser(): User { return suspendCoroutine&lt;User&gt; { cont -&gt; requestUser { user -&gt; cont.resume(user) } }}suspend fun main() { println(&quot;Before&quot;) val user = requestUser() println(user) println(&quot;After&quot;)} 현재 suspend 함수는 Retrofit이나 Room과 같은 많은 유명한 라이브러리에서 지원하고 있다. 그물게 suspend 함수 안에 콜백 함수를 쓸 때가 있다. 하지만 그런 경우라면 suspendCoroutine 때신suspendConcellableCoroutine을 사용하는 걸 추천한다. 이는 Cancellation 챕터에서 설명할 것이다. 1234567suspend fun requestUser(): User { return suspendCancellableCoroutine&lt;User&gt; { cont -&gt; requestUser { user -&gt; cont.resume(user) } }} 여기서 API가 데이터가 아닌 다른 문제가 발생했을 때는 어떻게 될지 궁금할 수도 있다. 서비스가 죽거나 오류를 수신할까? 위 예제에서는 데이터를 반환하지 않는다. 대신 코루틴이 일시정지한 곳에서 예외가 발생해야 한다. 예외를 받고 다시 시작한다. 예외를 받은 resume우리가 호출하는 모든 함수는 어떤 값을 반환하거나 예외를 던진다. suspendCoroutine도 같다. resume이 호출되면 매개변수로 데이터를 넘긴다. resumeWithException이 호출되면 매개변수로 전달된 예외가 일시정지한 지점에 개념적으로 던져진다. 123456789101112class MyException : Throwable(&quot;Just an exception&quot;)suspend fun main() { try { suspendCoroutine&lt;Unit&gt; { cont -&gt; cont.resumeWithException(MyException()) } } catch (e: MyException) { println(&quot;Caught!&quot;) }}// Caught! 이 매커니즘은 다른 문제에서도 쓰인다. 한 예로, 네트워크 예외 신호를 보낼 때가 있다. 123456789101112131415161718192021222324suspend fun requestUser(): User { return suspendCancellableCoroutine&lt;User&gt; { cont -&gt; requestUser { resp -&gt; if (resp.isSuccessful) { cont.resume(resp.data) } else { val e = ApiException( resp.code, resp.message ) cont.resumeWithException(e) } } }}suspend fun requestNews(): News { return suspendCancellableCoroutine&lt;News&gt; { cont -&gt; requestNews( onSuccess = { news -&gt; cont.resume(news) }, onError = { e -&gt; cont.resumeWithException(e) } ) }} 함수가 아닌 코루틴을 일시정지하는 것하나 강조할 것은 함수가 아닌 코루틴을 일시정지 시킨다는 것이다. 함수를 일시정지할 수 있는 것은 코루틴이 아니라 코루틴을 일시정지할 수 있는 함수이다. 어떤 변수에 함수를 저장하는 상상를 해보아라. 그리고 함수 호출 후 다시 시작시켜라. 123456789101112131415161718// 정말 이렇게 짜지 마세요var continuation: Continuation&lt;Unit&gt;? = nullsuspend fun suspendAndSetContinuation() { suspendCancellableCotouine&lt;Unit&gt; { cont -&gt; continuation = cont }}suspend fun main() { println(&quot;Before&quot;) suspendAndSetContinuation() continuation?.resume(Unit) println(&quot;After&quot;)}// Before 이건 좀 이해가 안 된다. 이건 게임을 멈추고 이전 지점에서 재시작하는 프로세스와 동일한데도 resume이 전혀 호출되지 않는다. 출력결과에는 오직 “Before”만 보인다. 그리고 다른 스레드나 코루틴에서 resume을 호출하지 않으면 이 프로그램은 영원히 끝나지 않는다. 이를 위해 1초 후 reusme하는 다른 코루틴을 배치할 수도 있다. 12345678910111213141516171819202122// 정말 이렇게 짜지 마세요. 잠재적인 메모리 누수의 원인이 됩니다.var continuation: Continuation&lt;Unit&gt;? = nullsuspend fun suspendAndSetContinuation() { suspendCancellableCotouine&lt;Unit&gt; { cont -&gt; continuation = cont }}suspend fun main() { println(&quot;Before&quot;) launch { delay(1000) continuation?.resume(Unit) } suspendAndSetContinuation() println(&quot;After&quot;)}// Before// (1 second delay)// After (adsbygoogle = window.adsbygoogle || []).push({});","link":"/2024/03/22/030-kotlin-coroutines-deep-dive-02/"}],"tags":[],"categories":[{"name":"Android","slug":"Android","link":"/categories/Android/"},{"name":"Etc","slug":"Etc","link":"/categories/Etc/"},{"name":"Translation","slug":"Translation","link":"/categories/Translation/"},{"name":"Algorithm","slug":"Algorithm","link":"/categories/Algorithm/"},{"name":"Kotlin","slug":"Kotlin","link":"/categories/Kotlin/"},{"name":"&#x2F;BOOK","slug":"BOOK","link":"/categories/BOOK/"},{"name":"&#x2F;ARTICLE","slug":"ARTICLE","link":"/categories/ARTICLE/"}]}