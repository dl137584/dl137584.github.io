<!doctype html>
<html lang="ko"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-8868044834754772" crossorigin="anonymous"></script><title>leejs&#039;s blog</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="leejs&#039;s blog"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="leejs&#039;s blog"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta property="og:type" content="blog"><meta property="og:title" content="leejs&#039;s blog"><meta property="og:url" content="https://dl137584.github.io/"><meta property="og:site_name" content="leejs&#039;s blog"><meta property="og:locale" content="ko_KR"><meta property="og:image" content="https://dl137584.github.io/img/og_image.png"><meta property="article:author" content="LEEJS"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://dl137584.github.io"},"headline":"leejs's blog","image":["https://dl137584.github.io/img/og_image.png"],"author":{"@type":"Person","name":"LEEJS"},"publisher":{"@type":"Organization","name":"leejs's blog","logo":{"@type":"ImageObject","url":"https://dl137584.github.io/img/logo.svg"}},"description":""}</script><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.15.2/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><script src="https://www.googletagmanager.com/gtag/js?id=G-Z2WE5QEQRR" async></script><script>window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
    
        gtag('config', 'G-Z2WE5QEQRR');</script><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><script data-ad-client="ca-pub-8868044834754772" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js" async></script><!-- hexo injector head_end start -->
        <script>
            function switchTab(element) {
                const id = element.parentElement.id;
                const tabElements = element.parentElement.parentElement.children;
                const contentElements = element.parentElement.parentElement.parentElement.parentElement.children[1].children;
                for (let i = 0; i < tabElements.length; i++) {
                    const $tab = tabElements[i];
                    const $content = contentElements[i];
                    if ($tab.id === id) {
                        $tab.classList.add('is-active');
                    } else {
                        $tab.classList.remove('is-active');
                    }
                    if ($content.id === id) {
                        $content.classList.remove('is-hidden');
                    } else {
                        $content.classList.add('is-hidden');
                    }
                }
            }
        </script>
        <!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.0.0"><link rel="alternate" href="/rss2.xml" title="leejs's blog" type="application/rss+xml">
</head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.svg" alt="leejs&#039;s blog" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/archives">Home</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="external nofollow noopener noreferrer" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a><a class="navbar-item search" title="검색" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time datetime="2025-06-25T10:32:22.000Z" title="2025. 6. 25. 오후 7:32:22">2025-06-25</time>&nbsp;게시 됨</span><span class="level-item"><time datetime="2026-01-10T11:08:05.710Z" title="2026. 1. 10. 오후 8:08:05">2026-01-10</time>&nbsp;업데이트 됨</span><span class="level-item"><a class="link-muted" href="/categories/Android/">Android</a></span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2025/06/25/033-android15-edge-to-edge-01-inset/">[Android] Android 15 대응 - EdgeToEdge: 1. Inset 적용</a></h1><div class="content"><h1 id="TL-DR"><a href="#TL-DR" class="headerlink" title="TL; DR"></a><strong>TL; DR</strong></h1><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> android.view.View</span><br><span class="line"><span class="keyword">import</span> android.view.Window</span><br><span class="line"><span class="keyword">import</span> androidx.core.view.ViewCompat</span><br><span class="line"><span class="keyword">import</span> androidx.core.view.WindowCompat</span><br><span class="line"><span class="keyword">import</span> androidx.core.view.WindowInsetsCompat</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * EdgeToEdge(API 30부터 지원) 적용에 따른 인셋을 적용한다.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> Window.<span class="title">setupWindowInsets</span><span class="params">()</span></span> &#123;</span><br><span class="line">    WindowCompat.getInsetsController(<span class="keyword">this</span>, <span class="keyword">this</span>.decorView).apply &#123;</span><br><span class="line">        isAppearanceLightStatusBars = <span class="literal">true</span></span><br><span class="line">        isAppearanceLightNavigationBars = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ViewCompat.setOnApplyWindowInsetsListener(findViewById(android.R.id.content)) &#123; view, insets -&gt;</span><br><span class="line">        <span class="keyword">val</span> systemBars = insets.getInsets(WindowInsetsCompat.Type.systemBars())</span><br><span class="line">        view.setPadding(systemBars.left, systemBars.top, systemBars.right, systemBars.bottom)</span><br><span class="line">        insets</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * EdgeToEdge(API 30부터 지원) 적용에 따른 인셋을 적용한다.</span></span><br><span class="line"><span class="comment"> * 추가로, 키보드가 올라올 때 (IME 인셋이 있을 때) 버튼을 이동시킨다.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> viewForKeyboard 키보드가 올라올 때 이동시킬 View</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> Window.<span class="title">setupWindowInsetsKeyboard</span><span class="params">(viewForKeyboard: <span class="type">View</span>)</span></span> &#123;</span><br><span class="line">    WindowCompat.getInsetsController(<span class="keyword">this</span>, <span class="keyword">this</span>.decorView).apply &#123;</span><br><span class="line">        isAppearanceLightStatusBars = <span class="literal">false</span></span><br><span class="line">        isAppearanceLightNavigationBars = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ViewCompat.setOnApplyWindowInsetsListener(findViewById(android.R.id.content)) &#123; view, insets -&gt;</span><br><span class="line">        <span class="keyword">val</span> systemBars = insets.getInsets(WindowInsetsCompat.Type.systemBars())</span><br><span class="line">        <span class="keyword">val</span> imeInsets = insets.getInsets(WindowInsetsCompat.Type.ime())</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 키보드가 올라올 때 (IME 인셋이 있을 때) 버튼을 이동</span></span><br><span class="line">        viewForKeyboard.translationY = <span class="keyword">if</span> (imeInsets.bottom &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            -(imeInsets.bottom - systemBars.bottom).toFloat()</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="number">0f</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        view.setPadding(systemBars.left, systemBars.top, systemBars.right, systemBars.bottom)</span><br><span class="line">        insets</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-8868044834754772" crossorigin="anonymous"></script>
<p><ins class="adsbygoogle" style="display:block; text-align:center;" data-ad-layout="in-article" data-ad-format="fluid" data-ad-client="ca-pub-8868044834754772" data-ad-slot="1292114373"></ins></p>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>




<h1 id="EdgeToEdge-적용"><a href="#EdgeToEdge-적용" class="headerlink" title="EdgeToEdge 적용"></a><strong>EdgeToEdge 적용</strong></h1><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> : <span class="type">ComponentActivitiy</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">setupWindowInsets</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ViewCompat.setOnApplyWindowInsetsListener(findViewById(android.R.id.content)) &#123; view, insets -&gt;</span><br><span class="line">      <span class="keyword">val</span> systemBars = insets.getInsets(WindowInsetsCompat.Type.systemBars())</span><br><span class="line">      view.setPadding(systemBars.left, systemBars.top, systemBars.right, systemBars.bottom)</span><br><span class="line">      insets</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">    enableEdgeToEdge() <span class="comment">// 반드시 onCreate보다 먼저 호출해야 한다.</span></span><br><span class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">    setupWindowInsets()</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="setDecorFitsSystemWindows"><a href="#setDecorFitsSystemWindows" class="headerlink" title="setDecorFitsSystemWindows"></a><a target="_blank" rel="external nofollow noopener noreferrer" href="https://developer.android.com/reference/androidx/core/view/WindowCompat#setDecorFitsSystemWindows(android.view.Window,boolean)">setDecorFitsSystemWindows</a></h1><blockquote>
<p>WindowInsetsCompat에 따라 decorView가 루트 수준 콘텐츠 뷰에 맞출 것인지 여부를 설정한다.</p>
<p>false로 설정하면 프레임워크는 콘텐츠 뷰를 인셋에 맞추지 않고 WindowInsetsCompat을 통해 콘텐츠 뷰에 전달한다.</p>
</blockquote>
<p>API 35 미만에서는 시스템 바까지 확장된 풀스크린(edgeToEdge)이 decorFitsSystemWindows 옵션을 통해 선택적이었다.</p>
<p>decorFitsSystemWindows는 내부적으로 API 16-29에서 setSystemUiVisibility를 사용한다.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">static <span class="class"><span class="keyword">class</span> <span class="title">Api16Impl</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Api16Impl() &#123;</span><br><span class="line">        <span class="comment">// This class is not instantiable.</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static void setDecorFitsSystemWindows(</span><br><span class="line">            <span class="meta">@NonNull</span> Window window,</span><br><span class="line">            <span class="keyword">final</span> boolean decorFitsSystemWindows</span><br><span class="line">    ) &#123;</span><br><span class="line">        <span class="keyword">final</span> int decorFitsFlags = View.SYSTEM_UI_FLAG_LAYOUT_STABLE</span><br><span class="line">                | View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION</span><br><span class="line">                | View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN;</span><br><span class="line">        <span class="keyword">final</span> View decorView = window.getDecorView();</span><br><span class="line">        <span class="keyword">final</span> int sysUiVis = decorView.getSystemUiVisibility();</span><br><span class="line">        decorView.setSystemUiVisibility(decorFitsSystemWindows</span><br><span class="line">                ? sysUiVis &amp; ~decorFitsFlags</span><br><span class="line">                : sysUiVis | decorFitsFlags);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>WindowCompat.setDecorFitsSystemWindows(window, boolean)은 API에 맞는 동작으로 하도록 구성되어, API 30 이상과 API 16-29가 분기처리되어 있다.</p>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-8868044834754772" crossorigin="anonymous"></script>
<p><ins class="adsbygoogle" style="display:block; text-align:center;" data-ad-layout="in-article" data-ad-format="fluid" data-ad-client="ca-pub-8868044834754772" data-ad-slot="1292114373"></ins></p>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>






<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> static void setDecorFitsSystemWindows(<span class="meta">@NonNull</span> Window window,</span><br><span class="line">        <span class="keyword">final</span> boolean decorFitsSystemWindows) &#123;</span><br><span class="line">    <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= <span class="number">30</span>) &#123;</span><br><span class="line">        Api30Impl.setDecorFitsSystemWindows(window, decorFitsSystemWindows);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Api16Impl.setDecorFitsSystemWindows(window, decorFitsSystemWindows);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>그런데, API 35에서 이를 아우를 수 있는, 즉 decorFitsSystemWindows나 setSystemUiVisibility를 개발자가 사용하지 않고 enableEdgeToEdge() 함수 호출만으로 풀스크린을 구현할 수 있게 되었다.</p>
<p>문제는 그것 뿐만이 아니라 풀스크린이 기본 기기 설정이 된 것이다. enableEdgeToEdge()를 설정하지 않아도 targetSDK가 35인 앱은 풀스크린으로 실행된다. 따라서 그 기본 설정을 위해 enableEdgeToEdge()를 호출해줘야 하는 것이다.</p>
<p>enableEdgeToEdge()를 사용하기 이전에는 decorFitsSystemWindows를 사용하여 시스템 표시줄 뒤에 앱을 배치하였다.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">  <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">  WindowCompat.setDecorFitsSystemWindows(window, <span class="literal">false</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">RelativeLayout</span></span></span><br><span class="line"><span class="tag">  <span class="attr">...</span></span></span><br><span class="line"><span class="tag">  <span class="attr">android:fitsSystemWindows</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>그런데 enableEdgeToEdge()의 내부 코드를 보면 내부적으로 모두 setDecorFitsSystemWindows(window, false)를 호출하고 있음을 볼 수 있다.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@JvmName(<span class="meta-string">&quot;enable&quot;</span>)</span></span><br><span class="line"><span class="meta">@JvmOverloads</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> ComponentActivity.<span class="title">enableEdgeToEdge</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    statusBarStyle: <span class="type">SystemBarStyle</span> = SystemBarStyle.auto(Color.TRANSPARENT, Color.TRANSPARENT)</span></span>,</span><br><span class="line">    navigationBarStyle: SystemBarStyle = SystemBarStyle.auto(DefaultLightScrim, DefaultDarkScrim)</span><br><span class="line">) &#123;</span><br><span class="line">    <span class="keyword">val</span> view = window.decorView</span><br><span class="line">    <span class="keyword">val</span> statusBarIsDark = statusBarStyle.detectDarkMode(view.resources)</span><br><span class="line">    <span class="keyword">val</span> navigationBarIsDark = navigationBarStyle.detectDarkMode(view.resources)</span><br><span class="line">    <span class="keyword">val</span> impl = Impl ?: <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= <span class="number">29</span>) &#123;</span><br><span class="line">        EdgeToEdgeApi29()</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= <span class="number">26</span>) &#123;</span><br><span class="line">        EdgeToEdgeApi26()</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= <span class="number">23</span>) &#123;</span><br><span class="line">        EdgeToEdgeApi23()</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= <span class="number">21</span>) &#123;</span><br><span class="line">        EdgeToEdgeApi21()</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        EdgeToEdgeBase()</span><br><span class="line">    &#125;.also &#123; Impl = it &#125;</span><br><span class="line">    impl.setUp(</span><br><span class="line">        statusBarStyle, navigationBarStyle, window, view, statusBarIsDark, navigationBarIsDark</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequiresApi(21)</span></span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">EdgeToEdgeApi21</span> : <span class="type">EdgeToEdgeImpl &#123;</span></span></span><br><span class="line">    <span class="meta">@Suppress(<span class="meta-string">&quot;DEPRECATION&quot;</span>)</span></span><br><span class="line">    <span class="meta">@DoNotInline</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">setUp</span><span class="params">(...)</span></span> &#123;</span><br><span class="line">        WindowCompat.setDecorFitsSystemWindows(window, <span class="literal">false</span>)</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequiresApi(23)</span></span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">EdgeToEdgeApi23</span> : <span class="type">EdgeToEdgeImpl &#123;</span></span></span><br><span class="line">    <span class="meta">@DoNotInline</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">setUp</span><span class="params">(...)</span></span> &#123;</span><br><span class="line">        WindowCompat.setDecorFitsSystemWindows(window, <span class="literal">false</span>)</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequiresApi(26)</span></span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">EdgeToEdgeApi26</span> : <span class="type">EdgeToEdgeImpl &#123;</span></span></span><br><span class="line">    <span class="meta">@DoNotInline</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">setUp</span><span class="params">(...)</span></span> &#123;</span><br><span class="line">        WindowCompat.setDecorFitsSystemWindows(window, <span class="literal">false</span>)</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequiresApi(29)</span></span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">EdgeToEdgeApi29</span> : <span class="type">EdgeToEdgeImpl &#123;</span></span></span><br><span class="line">    <span class="meta">@DoNotInline</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">setUp</span><span class="params">(...)</span></span> &#123;</span><br><span class="line">        WindowCompat.setDecorFitsSystemWindows(window, <span class="literal">false</span>)</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><a target="_blank" rel="external nofollow noopener noreferrer" href="https://velog.io/@hyemdooly/enableEdgeToEdge-%EB%82%B4%EB%B6%80-%EC%BD%94%EB%93%9C-%EC%95%8C%EA%B3%A0-%EC%93%B0%EA%B8%B0">링크</a> Scrim은 연극 용어이다. 앞쪽에 빛을 비추면 불투명하고, 뒤쪽에 빛을 비추면 투명하거나 반투명하게 보이는 theater drop을 의미한다.</p>
</blockquote>
<h1 id="키보드가-나타났을-때의-인셋-대응-adjustResize"><a href="#키보드가-나타났을-때의-인셋-대응-adjustResize" class="headerlink" title="키보드가 나타났을 때의 인셋 대응 - adjustResize"></a><strong>키보드가 나타났을 때의 인셋 대응 - adjustResize</strong></h1><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * EdgeToEdge(API 30부터 지원) 적용에 따른 인셋을 적용한다.</span></span><br><span class="line"><span class="comment"> * 추가로, 키보드가 올라올 때 (IME 인셋이 있을 때) 버튼을 이동시킨다.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> viewForKeyboard 키보드가 올라올 때 이동시킬 View</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> Window.<span class="title">setupWindowInsetsKeyboard</span><span class="params">(viewForKeyboard: <span class="type">View</span>)</span></span> &#123;</span><br><span class="line">    ViewCompat.setOnApplyWindowInsetsListener(findViewById(android.R.id.content)) &#123; view, insets -&gt;</span><br><span class="line">        <span class="keyword">val</span> systemBars = insets.getInsets(WindowInsetsCompat.Type.systemBars())</span><br><span class="line">        <span class="keyword">val</span> imeInsets = insets.getInsets(WindowInsetsCompat.Type.ime())</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 키보드가 올라올 때 (IME 인셋이 있을 때) 버튼을 이동</span></span><br><span class="line">        viewForKeyboard.translationY = <span class="keyword">if</span> (imeInsets.bottom &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            -(imeInsets.bottom - systemBars.bottom).toFloat()</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="number">0f</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        view.setPadding(systemBars.left, systemBars.top, systemBars.right, systemBars.bottom)</span><br><span class="line">        insets</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>관련글<ul>
<li><a href="https://dl137584.github.io/2025/06/25/034-android15-edge-to-edge-02-statusbar-and-navigationbar/">[Android] Android 15 대응 - EdgeToEdge: 2. StatusBar 및 NavigationBar</a></li>
<li><a href="https://dl137584.github.io/2025/06/25/035-android15-edge-to-edge-03-windowinsetscontroller/">[Android] Android 15 대응 - EdgeToEdge: 3. WindowInsetsController</a></li>
<li><a href="https://dl137584.github.io/2025/06/25/036-android15-edge-to-edge-03-display-cutout/">[Android] Android 15 대응 - EdgeToEdge: 4. 디스플레이 컷아웃</a></li>
</ul>
</li>
</ul>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-8868044834754772" crossorigin="anonymous"></script>
<p><ins class="adsbygoogle" style="display:block; text-align:center;" data-ad-layout="in-article" data-ad-format="fluid" data-ad-client="ca-pub-8868044834754772" data-ad-slot="1292114373"></ins></p>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>






</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time datetime="2025-05-12T11:16:16.000Z" title="2025. 5. 12. 오후 8:16:16">2025-05-12</time>&nbsp;게시 됨</span><span class="level-item"><time datetime="2026-01-10T11:32:08.010Z" title="2026. 1. 10. 오후 8:32:08">2026-01-10</time>&nbsp;업데이트 됨</span><span class="level-item"><a class="link-muted" href="/categories/Android/">Android</a></span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2025/05/12/037-why-you-should-use-flow-instead-of-livedata/">[Android/Flow] LiveData가 아닌 Flow를 사용해야 하는 이유</a></h1><div class="content"><p><img src="/2025/05/12/037-why-you-should-use-flow-instead-of-livedata/037-livedata-and-flow.png"></p>
<p>예전에는,</p>
<ul>
<li>LiveData는 생명주기에 종속적이었고, 메인 스레드에서 실행되었기 때문에 Repository에서 사용하기엔 알맞지 않았다.</li>
<li>반면 Flow는 생명주기를 인식할 수 없었으나 데이터 스트림을 관리하는 객체로서 확장 함수가 잘 구성되어있었고, 코틀린 코루틴 라이브러리의 일부이기 때문에 Repository에서 사용하더라도 클린 아키텍처에 반하지 않았다.<ul>
<li>Flow는 coroutine 라이브러리에 포함되어있기 때문에 Repository에서 사용 시 의존성을 추가하지 않아도 된다.  <figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> kotlinx.coroutines.flow.MutableSharedFlow</span><br><span class="line"><span class="keyword">import</span> kotlinx.coroutines.flow.asSharedFlow</span><br></pre></td></tr></table></figure></li>
</ul>
  또한,<blockquote>
<p>Flow는 Cold Stream 방식이다. 연속해서 계속 들어오는 데이터를 처리할 수 없고, collect 되었을 때만 생성되고 값을 반환한다. 만약 하나의 Flow Builder에 대해 다수의 collector가 있다면 collector 하나마다 하나씩 데이터를 호출하기 대문에 비용이 비싼 DB 접근, 서버 통신 등을 수행한다면 여러 번 리소스 요청을 하게될 수 있다.</p>
</blockquote>
</li>
</ul>
<p>→ LiveData는 ViewModel, Flow는 Repository에서 사용하는 상호보완적 관계였다.</p>
<ul>
<li>그런데 repeatOnLifecycle 블록에서 데이터를 collect함으로써 생명주기를 인식할 수 있는 StateFlow/SharedFlow가 등장했다.<ul>
<li>LiveData와 Flow는 ViewModel단에서는 상호대체 가능해졌다.</li>
</ul>
  → 하지만 Flow가 사용성이 더 높기 때문에(ViewModel과 Repository 두 영역에서 모두 사용할 수 있게 되었기 때문에) LiveData보다는 Flow를 더 선호하게 되었다.</li>
<li>StateFlow<blockquote>
<p>StateFlow는 현재 상태와 새로운 상태 업데이트를 수집기에 내보내는 관찰 가능한 상태 홀더 흐름이다. value 속성을 통해서도 현재 상태 값을 읽을 수 있다. 상태를 업데이트하고 Flow에 전송하려면 MutableStateFlow 클래스의 value 속성에 새 값을 할당한다.</p>
</blockquote>
<blockquote>
<p>StateFlow는 Hot Flow이다. Flow에서 수집해도 생산자 코드가 트리거되지 않는다.</p>
</blockquote>
  즉, StateFlow는 Hot 스트림 방식으로, 소비자의 collect 요청이 없어도 바로 값을 내보내고, 데이터가 업데이트 될 떄마다 데이터를 발행한다.</li>
</ul>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-8868044834754772" crossorigin="anonymous"></script>
<p><ins class="adsbygoogle" style="display:block; text-align:center;" data-ad-layout="in-article" data-ad-format="fluid" data-ad-client="ca-pub-8868044834754772" data-ad-slot="1292114373"></ins></p>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>





</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time datetime="2025-03-20T11:21:46.000Z" title="2025. 3. 20. 오후 8:21:46">2025-03-20</time>&nbsp;게시 됨</span><span class="level-item"><time datetime="2026-01-10T11:29:32.351Z" title="2026. 1. 10. 오후 8:29:32">2026-01-10</time>&nbsp;업데이트 됨</span><span class="level-item"><a class="link-muted" href="/categories/Android/">Android</a></span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2025/03/20/038-about-cookie/">[Android] 쿠키에 관하여</a></h1><div class="content"><h1 id="쿠키"><a href="#쿠키" class="headerlink" title="쿠키"></a><strong>쿠키</strong></h1><p>여기서는 앱에 내려주는 쿠키형식에 관하여 이야기한다.</p>
<ul>
<li>[<a target="_blank" rel="external nofollow noopener noreferrer" href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Reference/Headers/Set-Cookie">MDN</a>] Set-Cookie</li>
</ul>
<h2 id="1-세션-쿠키"><a href="#1-세션-쿠키" class="headerlink" title="1. 세션 쿠키"></a>1. 세션 쿠키</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set-Cookie: sessionId=38afes7a8</span><br></pre></td></tr></table></figure>

<p>가장 간단한 형재는 key=value 형태로 되어있다.</p>
<p><a target="_blank" rel="external nofollow noopener noreferrer" href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Reference/Headers/Set-Cookie#expiresdate">Expires 속성</a> 설명에 나와있듯이,</p>
<blockquote>
<p>If unspecified, the cookie becomes a <strong>session cookie</strong>. A session finishes when the client shuts down, after which the session cookie is removed.</p>
</blockquote>
<p>Expires 속성값이 지정되지 않으면 세션 쿠키이고, Chrome Inspector의 쿠키 리스트 중 expires 값에 “session”이라고 나타난다.</p>
<h2 id="2-지속-persistent-쿠키"><a href="#2-지속-persistent-쿠키" class="headerlink" title="2. 지속(persistent) 쿠키"></a>2. 지속(persistent) 쿠키</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set-Cookie: id=a3fWa; Expires=Wed, <span class="number">21</span> Oct <span class="number">2015</span> <span class="number">07</span>:<span class="number">28</span>:<span class="number">00</span> GMT</span><br></pre></td></tr></table></figure>

<p>지속 쿠키는 Expires 값이 <a target="_blank" rel="external nofollow noopener noreferrer" href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Reference/Headers/Date">HTTP Date</a> 형태로 지정된 값이다. 이는 GMT(그리니치 평균시)를 따르며 런던을 기점으로 하는 시각이고, 로컬 시각이 아니다.</p>
<p>⚠️ 한국의 경우 GMT+09:00으로 표현하나, Expires 속성값 마지막에 “GMT” 대신 “GMT+09:00”를 쓰더라도 “+09:00”는 무시되기 때문에 날짜는 항상 “GMT” 시간을 나타내는 점에 주의해야 한다.</p>
<p>이렇게 Expires 속성값이 지정된 쿠키는 지정된 만료 일자까지 살아있는다.</p>
<h2 id="3-안드로이드-웹뷰에도-세션-쿠키와-지속-쿠키가-나뉘어져서-보관되는가"><a href="#3-안드로이드-웹뷰에도-세션-쿠키와-지속-쿠키가-나뉘어져서-보관되는가" class="headerlink" title="3. 안드로이드 웹뷰에도 세션 쿠키와 지속 쿠키가 나뉘어져서 보관되는가?"></a>3. 안드로이드 웹뷰에도 세션 쿠키와 지속 쿠키가 나뉘어져서 보관되는가?</h2><p>결론만 말하면, 그렇다.</p>
<p>이는 CookieManager의 removeSessionCookies()와 removeAllCookies() 메소드로 확인할 수 있다.</p>
<ol>
<li>우선 expires 속성값이 내려오는 “test” 쿠키가 있다고 하자. <figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set-Cookie: test=<span class="number">1</span>; Expires=Thu, <span class="number">20</span> Mar <span class="number">2025</span> <span class="number">11</span>:<span class="number">13</span>:<span class="number">47</span> GMT+09:<span class="number">00</span>; Domain=.megastudy.net; Path=/;</span><br></pre></td></tr></table></figure>
</li>
<li>이를 앱에서 받아(받는 방법은 아래의 [okhttp3.CookieJar] 항목을 참조) cookieManager를 이용해 setCookie한다.</li>
<li>removeSessionCookies()와 removeAllCookies()를 각각 수행하고 쿠키가 삭제되는지 확인한다.</li>
</ol>
<p>그 결과는 다음과 같다.</p>
<table>
<thead>
<tr>
<th></th>
<th>expires 속성 없음</th>
<th>expires 속성 있음</th>
</tr>
</thead>
<tbody><tr>
<td>removeSessionCookies</td>
<td>삭제됨</td>
<td>삭제안됨</td>
</tr>
<tr>
<td>removeAllCookies</td>
<td>삭제됨</td>
<td>삭제됨</td>
</tr>
</tbody></table>
<p>여기서 removeSessionCookie로 삭제되지 않는 값, 즉 expires 속성이 있는 쿠키값은 지속 쿠키로 간주할 수 있겠다.</p>
<p>CookieManager의 getCookie를 통해서는 쿠키의 이름과 값만 내려온다. 따라서 CookieManager를 통해 해당 쿠키의 만료일자 또는 만료여부를 판단할 수 있는 deprecated되지 않은 메소드는 없다.(CookieManager#removeExpiredCookie()는 deprecated되었다.) 그러나 앱 내부적으로 쿠키DB에 저장은 되고 있음을 inspector의 [Application] 탭 &gt; 사이드바의 [Storage] &gt; [Cookies] &gt; [해당 도메인]으로 접근하여 expires 값이 세팅되어있음을 확인할 수 있다.</p>
<p><img src="/2025/03/20/038-about-cookie/038-01.png"></p>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-8868044834754772" crossorigin="anonymous"></script>
<p><ins class="adsbygoogle" style="display:block; text-align:center;" data-ad-layout="in-article" data-ad-format="fluid" data-ad-client="ca-pub-8868044834754772" data-ad-slot="1292114373"></ins></p>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>






<h1 id="okhttp3-CookieJar"><a href="#okhttp3-CookieJar" class="headerlink" title="okhttp3.CookieJar"></a><strong>okhttp3.CookieJar</strong></h1><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> cookieManager = CookieManager.getInstance()</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> myCookieJar = <span class="keyword">object</span> : CookieJar &#123;</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">loadForRequest</span><span class="params">(url: <span class="type">HttpUrl</span>)</span></span>: MutableList&lt;Cookie&gt; &#123;</span><br><span class="line">    <span class="keyword">val</span> cookies = mutableListOf&lt;Cookie&gt;()</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 여기서 앱에서 가지고 있는 쿠키를 웹으로 보낼 수 있다.</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> cookies</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">saveFromResponse</span><span class="params">(url: <span class="type">HttpUrl</span>, cookies: <span class="type">MutableList</span>&lt;<span class="type">Cookie</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 여기서 파라미터를 통해 받아온 cookies 값은 웹에서 세팅된 쿠키값이며</span></span><br><span class="line">    <span class="comment">// 이를 안드로이드에 setCookie 해주어야 한다.</span></span><br><span class="line">    </span><br><span class="line">    cookies.forEachIndexed &#123; i, cookie -&gt;</span><br><span class="line">      cookieManager.setCookie(url.toString(), cookie.toString())</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>CookieJar은 loadForRequest와 saveFromResponse 두 개의 함수를 구현하도록 되어 있다.</p>
<ul>
<li>loadForRequest: HTTP 요청을 보내 기 전에 요청에 사용할 쿠키를 반환한다.</li>
<li>saveFromResponse: HTTP 응답으로부터 받은 쿠키를 저장소에 저장한다.</li>
</ul>
<p>따라서 순서로 따지면 loadForRequest 후에 saveFromReponse가 호출된다.</p>
<p>이를 적용하는 코드는 다음과 같다.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> clientBuilder = OkHttpClient.Builder().apply &#123;</span><br><span class="line">  connectTimeout(Const.TIMEOUT, TimeUnit.SECONDS)</span><br><span class="line">  writeTimeout(Const.TIMEOUT, TimeUnit.SECONDS)</span><br><span class="line">  readTimeout(Const.TIMEOUT, TimeUnit.SECONDS)</span><br><span class="line">&#125;</span><br><span class="line">.cookieJar(myCookieJar)</span><br></pre></td></tr></table></figure>



<h1 id="Web-Attribute-Expires"><a href="#Web-Attribute-Expires" class="headerlink" title="[Web/Attribute] Expires"></a><strong>[Web/Attribute] Expires</strong></h1><p>Expires 속성을 가진 지속 쿠키를 웹으로부터 받아온 경우(CookieJar의 saveFromResponse로 확인) 이 만료 기간이 잘 작동하는지 확인하고자 하였다.</p>
<p>우선 아래와 같이 test 라는 이름의 쿠키를 추가한다.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> time = SimpleDateFormat(<span class="string">&quot;EEE, dd MMM yyyy HH:mm:ss z&quot;</span>, Locale.US)</span><br><span class="line">time.timeZone = TimeZone.getTimeZone(<span class="string">&quot;GMT&quot;</span>)</span><br><span class="line"><span class="keyword">val</span> expiryDate = time.format(</span><br><span class="line">    Date(System.currentTimeMillis() + <span class="number">60</span> * <span class="number">1000</span>)</span><br><span class="line">)</span><br><span class="line">cookieManager.setCookie(</span><br><span class="line">  url.toString(),</span><br><span class="line">  <span class="string">&quot;test=1; Expires=<span class="variable">$expiryDate</span>;Domain=.megastudy.net; Path=/;&quot;</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// &quot;test=1; Expires=Thu, 20 Mar 2025 11:13:47 GMT+09:00;Domain=.megastudy.net; Path=/;&quot;</span></span><br></pre></td></tr></table></figure>

<p>Expires 속성값은 <a target="_blank" rel="external nofollow noopener noreferrer" href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Reference/Headers/Date">HTTP Date 형식</a>으로 되어, GMT(그리니치 표준시)를 따른다. 이를 위해 타임존을 설정하면 로컬(한국)의 시간보다 9시간차이가 나는 값을 얻을 수 있다. 즉 아래 두 값은 같은 시각을 나타낸다고 보면 된다.</p>
<ol>
<li>Thu, 20 Mar 2025 15:00:00 GMT+09:00</li>
<li>Thu, 20 Mar 2025 06:00:00 GMT</li>
</ol>
<p>그리고 Expires 속성값은 1번을 넣어도 2번으로 인식하는 게 아니기 때문에 반드시 로컬 시간을 보정해주어야 하며 이를 위해 timeZone을 <code>TimeZone.getTimeZone(&quot;GMT&quot;)</code>로 설정한다.</p>
<p><img src="/2025/03/20/038-about-cookie/038-02.png" alt="chrome inspector"></p>
<p>그리고 해당 “test” 쿠키는 GMT 값에 따라 만료일이 경과하면 자동으로 사라지는 것을 inspector를 통해 확인할 수 있다.</p>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-8868044834754772" crossorigin="anonymous"></script>
<p><ins class="adsbygoogle" style="display:block; text-align:center;" data-ad-layout="in-article" data-ad-format="fluid" data-ad-client="ca-pub-8868044834754772" data-ad-slot="1292114373"></ins></p>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>





</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time datetime="2025-01-08T11:33:12.000Z" title="2025. 1. 8. 오후 8:33:12">2025-01-08</time>&nbsp;게시 됨</span><span class="level-item"><time datetime="2026-01-10T11:34:39.539Z" title="2026. 1. 10. 오후 8:34:39">2026-01-10</time>&nbsp;업데이트 됨</span><span class="level-item"><a class="link-muted" href="/categories/Android/">Android</a></span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2025/01/08/039-lifecycleownerwrapper/">[Android] LifecycleOwnerWrapper 분석</a></h1><div class="content"><p>앱이 포그라운드에서 백그라운드로 전환됐을 때 해당 Activity가 onPause에서 onStop으로 전환된다. 이때 ViewModel의 LiveData가 변경을 감지하고자 등록된 (Activity 또는 Fragment로부터 받은) lifecycleOwner는 활성화(active) 상태에서 비활성화(inActive) 상태로 전환된다.</p>
<p>이때 onStop(inActive 상태) 시에도 활성화 상태를 유지하기 위해 구현된 LifecycleOwnerWrapper 상세는 다음과 같다.</p>
<ul>
<li><a target="_blank" rel="external nofollow noopener noreferrer" href="https://stackoverflow.com/questions/57909258/android-viewmodel-observer-not-called-from-background/72467101#72467101">stackoverflow</a></li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LifecycleOwnerWrapper</span></span>(</span><br><span class="line">  sourceOwner: LifecycleOwner</span><br><span class="line">): LifecycleOwner, LifecycleEventObserver &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="keyword">val</span> lifecycle = LifecycleRegistry(<span class="keyword">this</span>)</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">init</span> &#123;</span><br><span class="line">    sourceOwner.lifecycle.addObserver(<span class="keyword">this</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">when</span> (<span class="keyword">val</span> state = sourceOwner.lifecycle.currentState) &#123;</span><br><span class="line">      Lifecycle.State.DESTROYED -&gt; lifecycle.handleLifecycleEvent(Lifecycle.Event.ON_DESTROY)</span><br><span class="line">      Lifecycle.State.CREATED -&gt; lifecycle.handleLifecycleEvent(Lifecycle.Event.ON_CREATE)</span><br><span class="line">      Lifecycle.State.STARTED -&gt; lifecycle.handleLifecycleEvent(Lifecycle.Event.ON_START)</span><br><span class="line">      Lifecycle.State.RESUMED -&gt; lifecycle.handleLifecycleEvent(Lifecycle.Event.ON_RESUME)</span><br><span class="line">      <span class="keyword">else</span> -&gt; &#123;</span><br><span class="line">        <span class="comment">// do nothing, the observer will catch up</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onStateChanged</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    source: <span class="type">LifecycleOwner</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    event: <span class="type">Lifecycle</span>.<span class="type">Event</span></span></span></span><br><span class="line"><span class="params"><span class="function">  )</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (event != Lifecycle.Event.ON_PAUSE</span><br><span class="line">      &amp;&amp; event != Lifecycle.Event.ON_STOP) &#123;</span><br><span class="line">      lifecycle.handleLifecycleEvent(event)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-8868044834754772" crossorigin="anonymous"></script>
<p><ins class="adsbygoogle" style="display:block; text-align:center;" data-ad-layout="in-article" data-ad-format="fluid" data-ad-client="ca-pub-8868044834754772" data-ad-slot="1292114373"></ins></p>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>






<ol>
<li><p>“onStop(inactive 상태) 시에도 활성화 상태를 유지하”는 lifecycle을 새롭게 만들기 위해 LifecycleOwner를 상속받아 lifecycle 변수를 새로 정의한다.</p>
 <figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LifecycleOwnerWrapper</span></span>(sourceOwner: LifecycleOwner): LifecycleOwner, LifecycleEventObserver &#123;</span><br><span class="line">  <span class="keyword">override</span> <span class="keyword">val</span> lifecycle = LifecycleRegistry(<span class="keyword">this</span>)</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>그 lifecycle이 생성되었을 때 현재 state를 init을 통해 등록한다.</p>
 <figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">init</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">when</span> (<span class="keyword">val</span> state = sourceOwner.lifecycle.currentState) &#123;</span><br><span class="line">    Lifecycle.State.DESTROYED -&gt; lifecycle.handleLifecycleEvent(Lifecycle.Event.ON_DESTROY)</span><br><span class="line">    Lifecycle.State.CREATED -&gt; lifecycle.handleLifecycleEvent(Lifecycle.Event.ON_CREATE)</span><br><span class="line">    Lifecycle.State.STARTED -&gt; lifecycle.handleLifecycleEvent(Lifecycle.Event.ON_START)</span><br><span class="line">    Lifecycle.State.RESUMED -&gt; lifecycle.handleLifecycleEvent(Lifecycle.Event.ON_RESUME)</span><br><span class="line">    <span class="keyword">else</span> -&gt; &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 여기서 handleLifecycleEvent는 아래 구현부와 같이 파라미터로 받은 state를 currentState로 등록하는 역할을 한다.</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Sets the current state and notifies the observers.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">open fun <span class="title">handleLifecycleEvent</span><span class="params">(event: Event)</span> </span>&#123;</span><br><span class="line">    enforceMainThreadIfNeeded(<span class="string">&quot;handleLifecycleEvent&quot;</span>)</span><br><span class="line">    moveToState(event.targetState)</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">private</span> fun <span class="title">moveToState</span><span class="params">(next: State)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (state == next) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    check(!(state == State.INITIALIZED &amp;&amp; next == State.DESTROYED)) &#123;</span><br><span class="line">        <span class="string">&quot;no event down from $state in component $&#123;lifecycleOwner.get()&#125;&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    state = <span class="function">next</span></span><br><span class="line"><span class="function">    <span class="title">if</span> <span class="params">(handlingEvent || addingObserverCounter != <span class="number">0</span>)</span> </span>&#123;</span><br><span class="line">        newEventOccurred = <span class="keyword">true</span></span><br><span class="line">        <span class="comment">// we will figure out what to do on upper level.</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    handlingEvent = <span class="function"><span class="keyword">true</span></span></span><br><span class="line"><span class="function">    <span class="title">sync</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    handlingEvent </span>= <span class="function"><span class="keyword">false</span></span></span><br><span class="line"><span class="function">    <span class="title">if</span> <span class="params">(state == State.DESTROYED)</span> </span>&#123;</span><br><span class="line">        observerMap = FastSafeIterableMap()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>새로운 lifecycle에 대한 동작을 구현하기 위해 LifecycleEventObserver를 상속받도록 하여 onStateChanged를 구현할 수 있도록 한다.</p>
 <figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LifecycleOwnerWrapper</span></span>(</span><br><span class="line">  sourceOwner: LifecycleOwner</span><br><span class="line">): LifecycleOwner, LifecycleEventObserver &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onStateChanged</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    source: <span class="type">LifecycleOwner</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    event: <span class="type">Lifecycle</span>.<span class="type">Event</span></span></span></span><br><span class="line"><span class="params"><span class="function">  )</span></span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>여기서 LifecycleEventObserver를 상속받지 않고 LifecycleOwnerWrapper를 사용하는 Activity 또는 Fragment 내의 observer를 등록하는 부분에서 LifecycleEventObserver를 구현해도 된다.<ul>
<li><a target="_blank" rel="external nofollow noopener noreferrer" href="https://velog.io/@blucky8649/%EC%95%88%EB%93%9C%EB%A1%9C%EC%9D%B4%EB%93%9C-%EC%88%98%EB%AA%85%EC%A3%BC%EA%B8%B0-%EC%9D%B8%EC%8B%9D-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8">링크</a></li>
</ul>
</li>
</ul>
</li>
<li><p>onStateChanged에는 “onStop(inactive 상태) 시에도 활성화 상태를 유지하”기 위해 onStop일 경우 정상적으로 handleLifecycleEvent를 호출하지 <strong>않도록</strong> 한다.</p>
 <figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onStateChanged</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  source: <span class="type">LifecycleOwner</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">  event: <span class="type">Lifecycle</span>.<span class="type">Event</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (event != Lifecycle.Event.ON_PAUSE</span><br><span class="line">    &amp;&amp; event != Lifecycle.Event.ON_STOP) &#123;</span><br><span class="line">    lifecycle.handleLifecycleEvent(event)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 그럼으로써 이 lifecycle에서는 다음과 같은 커스텀 lifecycle이 적용된다.</p>
<table>
<thead>
<tr>
<th>정상 lifecycle</th>
<th>활성화 여부</th>
<th>커스텀 lifecycle에서의 state</th>
<th>활성화 여부</th>
</tr>
</thead>
<tbody><tr>
<td>onCreate</td>
<td>x</td>
<td>ON_CREATE</td>
<td>x</td>
</tr>
<tr>
<td>onStart</td>
<td>o</td>
<td>ON_START</td>
<td>o</td>
</tr>
<tr>
<td>onResume</td>
<td>o</td>
<td>ON_RESUME</td>
<td>o</td>
</tr>
<tr>
<td>onPause</td>
<td>o*</td>
<td>ON_RESUME</td>
<td>o</td>
</tr>
<tr>
<td>onStop</td>
<td>x</td>
<td>ON_RESUME</td>
<td>o</td>
</tr>
<tr>
<td>onDestroy</td>
<td>x</td>
<td>ON_DESTROY</td>
<td>x</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>*<a target="_blank" rel="external nofollow noopener noreferrer" href="https://pluu.github.io/blog/android/2023/01/19/fragment_visible_lifecycleowner/">링크</a>에 따르면, Fragment에서는 onPause에서도 active하다고 함.</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
</li>
<li><p>마지막으로 구현된 새로운 lifecycle을 적용하기 위해 sourceOwner에 LifecycleEventObserver를 등록(addObserver)한다.</p>
 <figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sourceOwner.lifecycle.addObserver(<span class="keyword">this</span>)</span><br></pre></td></tr></table></figure></li>
</ol>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-8868044834754772" crossorigin="anonymous"></script>
<p><ins class="adsbygoogle" style="display:block; text-align:center;" data-ad-layout="in-article" data-ad-format="fluid" data-ad-client="ca-pub-8868044834754772" data-ad-slot="1292114373"></ins></p>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>





</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time datetime="2024-03-22T12:22:31.000Z" title="2024. 3. 22. 오후 9:22:31">2024-03-22</time>&nbsp;게시 됨</span><span class="level-item"><time datetime="2024-03-22T12:26:10.000Z" title="2024. 3. 22. 오후 9:26:10">2024-03-22</time>&nbsp;업데이트 됨</span><span class="level-item"><a class="link-muted" href="/categories/Translation/">Translation</a></span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2024/03/22/030-kotlin-coroutines-deep-dive-02/">[번역: Kotlin Coroutines: Deep Dive] (2) 코틀린 코루틴에서 일시 정지 작업을 하는 방법</a></h1><div class="content"><blockquote>
<p>이 포스팅은 <a target="_blank" rel="external nofollow noopener noreferrer" href="https://kt.academy/book/coroutines">Kotlin Coroutines: Deep Dive</a>의 글을 번역한 것입니다. 오역, 많은 의역, 생략이 있으니 감안하여 읽어주십시오.</p>
</blockquote>
<p>하나의 코루틴을 일시정지하는 것은 중간에 멈추는 것을 의미한다. 이건 세이브한 게임을 멈추고 당신이 다른 일에 집중할 수 있는 상태와 유사하다. 그리고 후에 언제든 세이브포인트에서 게임을 다시 시작할 수 있다. 코루틴은 일시정지하면 Continuation을 반환한다. 이를 사용하여 멈춘 지점에서 다시 시작할 수 있다.</p>
<p>이는 save가 아니라 block하는 스레드와는 매우 다르다는 사실에 주의하라. 코루틴은 매우 강력하다. 일시정지했을 때 어떤 리소스도 사용하지 않는다. 코루틴은 다른 스레드를 다시 시작할 수 있다. (적어도 이론 상으로는) 하나의 continuation은 직렬화, 비직렬화되어있을 수 있고 다시 시작될 수도 있다.</p>
<h3 id="다시-시작"><a href="#다시-시작" class="headerlink" title="다시 시작"></a><strong>다시 시작</strong></h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  println(<span class="string">&quot;Before&quot;</span>)</span><br><span class="line">	suspendCoroutine&lt;<span class="built_in">Unit</span>&gt; &#123; &#125;</span><br><span class="line">	println(<span class="string">&quot;After&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>위 코드를 실행하면 “After” 글자를 볼 수 없을 것이다. 그리고 (main 함수는 절대 끝나지 않기 때문에) 코드가 실행을 멈춘 것도 아니다. 우리는 게임을 멈췄지만 다시 시작하지는 않았다. 그렇다면 어떻게 다시 시작할 것인가? 앞서 언급한 Continuation는 어디에 있는가?</p>
<p>suspendCoroutine 블록의 람다식을 다시 보자. argument를 받는 이 함수는 일시정지하기 전에 불리워진다. 그때의 매개변수가 continuation이다. </p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  println(<span class="string">&quot;Before&quot;</span>)</span><br><span class="line">	suspendCoroutine&lt;<span class="built_in">Unit</span>&gt; &#123; continuation -&gt;</span><br><span class="line">		println(<span class="string">&quot;Before too&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	println(<span class="string">&quot;After&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>같은 곳에서 다른 함수를 부르는 이러한 함수는 전혀 새로운 것이 아니다. 이는 let이나 apply, useLines와 유사하다. suspendCoroutine 함수는 이와 같은 방식으로 디자인되었다. 즉 일시정지하기 전에 continuation을 사용할 수 있도록 하는 것이다. suspendCoroutine이 호출된 후면 너무 늦을 것이다. 그래서 람다식을 통해 그 전에 부를 수 있도록 한다. 람다는 continuation을 어디서든 저장하거나 이를 다시시작할지 여부를 계획하기도 한다.</p>
<p>즉시 다시 시작하려면 이렿게하면 된다.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  println(<span class="string">&quot;Before&quot;</span>)</span><br><span class="line">	suspendCoroutine&lt;<span class="built_in">Unit</span>&gt; &#123; continuation -&gt;</span><br><span class="line">		continuation.resume(<span class="built_in">Unit</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	println(<span class="string">&quot;After&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Before</span></span><br><span class="line"><span class="comment">// After</span></span><br></pre></td></tr></table></figure>

<p>위에서 “After”가 suspendCoroutine 안에서 resume을 호출했기 때문에 출력되었음에 주의하라.</p>
<blockquote>
<p>Kotlin 1.3 이후로 Continuation 정의가 바뀌었다. resume과 resumeWithException 대신 하나의 결과값이 있는 resumeWith 함수가 있다. 우리가 사용하고 있는 resume과 resumeWithException 함수는 resumeWith를 사용한 표준 라이브러리에 있는 extension 함수이다.</p>
</blockquote>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> Continuation<span class="type">&lt;T&gt;</span>.<span class="title">resume</span><span class="params">(value: <span class="type">T</span>)</span></span>: <span class="built_in">Unit</span> =</span><br><span class="line">	resumeWith(Result.success(value))</span><br><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> Continuation<span class="type">&lt;T&gt;</span>.<span class="title">resumeWithException</span><span class="params">(exception: <span class="type">Throwable</span>)</span></span>: <span class="built_in">Unit</span> =</span><br><span class="line">	resumeWith(Result.failure(exception))</span><br></pre></td></tr></table></figure>

<p>설정된 시간동안 sleep할 다른 스레드를 시작할 수도 있다. 이는 언제든지 다시 시작할 수 있다.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	print(<span class="string">&quot;Before &quot;</span>)</span><br><span class="line">	suspendCoroutine&lt;<span class="built_in">Unit</span>&gt;&#123; continuation -&gt;</span><br><span class="line">		thread &#123;</span><br><span class="line">			print(<span class="string">&quot;Suspended &quot;</span>)</span><br><span class="line">			Thread.sleep(<span class="number">1000</span>)</span><br><span class="line">			continuation.resume(<span class="built_in">Unit</span>)</span><br><span class="line">			print(<span class="string">&quot;Resumed &quot;</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	print(<span class="string">&quot;After &quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Before Suspended (1 second delay) After Resumed </span></span><br></pre></td></tr></table></figure>

<p>중요한 부분이다. 정의된 시간이 끝난 후에 continuation을 다시 시작할 함수를 만들 수 있음에 주목하라. 여기서 continuation은 아래 보이는 것처럼 람다식에 의해 좌우된다.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">continueAfterSecond</span><span class="params">(continuation: <span class="type">Continuation</span>&lt;<span class="type">Unit</span>&gt;)</span></span> &#123;</span><br><span class="line">	thread &#123;</span><br><span class="line">		Thread.sleep(<span class="number">1000</span>)</span><br><span class="line">		continuation.resume(<span class="built_in">Unit</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	print(<span class="string">&quot;Before &quot;</span>)</span><br><span class="line">	suspendCoroutine&lt;<span class="built_in">Unit</span>&gt; &#123; continutaion -&gt;</span><br><span class="line">		continueAfterSecond(continuation)</span><br><span class="line">	&#125;</span><br><span class="line">	print(<span class="string">&quot;After &quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Before (1 sec) After </span></span><br></pre></td></tr></table></figure>

<p>이건 오류 없이 작동은 한다. 하지만 단 일 초 동안만 비활성화 상태가 되었다가 끝나는 스레드를 불필요하게 생성한다. 스레드는 비용이 싸지 않은데도 왜 낭비하고 있는가? 더 좋은 방법은 “알람”을 설정하는 것이다. JVM에서 그것을 구현하기 위해 ScheduledExecutorService를 사용했다. 여기서는 정의된 얼마간의 시간 후에 몇 개의 continuation.resume(Unit)을 호출하는 걸로 알람을 설정할 수 있다.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> executor = </span><br><span class="line">	Executor.newSingleThreadScheduledExecutor &#123;</span><br><span class="line">		Thread(it, <span class="string">&quot;scheduler&quot;</span>).apply &#123; isDaemon = <span class="literal">true</span> &#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	print(<span class="string">&quot;Before &quot;</span>)</span><br><span class="line">	suspendCoroutine&lt;<span class="built_in">Unit</span>&gt; &#123; continuation -&gt;</span><br><span class="line">		executorschedule(&#123;</span><br><span class="line">			continuation.resume(<span class="built_in">Unit</span>)</span><br><span class="line">		&#125;, <span class="number">1000</span>, TimeUnit.MILLISECONDS)</span><br><span class="line">	&#125;</span><br><span class="line">	print(<span class="string">&quot;After &quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Before (1 seconds delay) After</span></span><br></pre></td></tr></table></figure>

<p>설정한 시간동안 일시정지하는 건 유용한 피처로 보인다. 그러니 이걸 delay라는 함수로 추출해보자.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">delay</span><span class="params">(timeMillis: <span class="type">Long</span>)</span></span>: <span class="built_in">Unit</span> = </span><br><span class="line">	suspendCoroutine &#123; continuation -&gt;</span><br><span class="line">		executor.schedule(&#123;</span><br><span class="line">			continuation.resume(<span class="built_in">Unit</span>)</span><br><span class="line">		&#125;, timeMillis, TimeUnit.MILLISECONDS)</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>executor가 여전히 스레드를 사용하고 있지만 delay 함수를 사용하는 모든 코루틴에 한 개의 스레드만을 할당한다. 이 점은 하나의 스레드를 매번 블록하는 것보다는 낫다.</p>
<p>이는 코틀린 코루틴 라이브러리에서 지원하는 delay의 방식이다. 구현은 더 복잡하지만 필수적인 요소는 이렇다.</p>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-8868044834754772" crossorigin="anonymous"></script>
<p><ins class="adsbygoogle" style="display:block; text-align:center;" data-ad-layout="in-article" data-ad-format="fluid" data-ad-client="ca-pub-8868044834754772" data-ad-slot="1292114373"></ins></p>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>




<h3 id="어떤-값을-가지고-다시-시작하기"><a href="#어떤-값을-가지고-다시-시작하기" class="headerlink" title="어떤 값을 가지고 다시 시작하기"></a><strong>어떤 값을 가지고 다시 시작하기</strong></h3><p>resume 함수에서 Unit을 넘겨주는 거에 대해 걱정할 수도 있다. 그러면서 suspendCoroutine의 매개변수로 Unit을 사용하는 이유가 궁금해질 것이다. 이 두가지가 같다는 사실은 우연이 아니다. Unit은 함수로부터 반환되고, Continuation 타입 파라미터는 제네릭 타입이다.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> ret: <span class="built_in">Unit</span> = </span><br><span class="line">	suspendCoroutine&lt;<span class="built_in">Unit</span>&gt; &#123; cont: Continuation&lt;<span class="built_in">Unit</span>&gt; -&gt;</span><br><span class="line">			cont.resume(<span class="built_in">Unit</span>)</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>suspendCoroutine이 호출될 때, 이 continuation에서 반환되는 타입이 어떤 것인지 명확해진다. 그 타입은 resume을 호출할 때 사용되곤 한다.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">val</span> i: <span class="built_in">Int</span> = suspendCoroutine&lt;<span class="built_in">Int</span>&gt; &#123; cont -&gt;</span><br><span class="line">			cont.resume(<span class="number">42</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	println(i) <span class="comment">// 42</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">val</span> str: String = suspendCoroutine&lt;String&gt; &#123; cont -&gt;</span><br><span class="line">			cont.resume(<span class="string">&quot;Some text&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	println(str) <span class="comment">// Some text</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">val</span> b: <span class="built_in">Boolean</span> = suspendCoroutine&lt;<span class="built_in">Boolean</span>&gt; &#123; cont -&gt;</span><br><span class="line">			cont.resume(<span class="literal">true</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	println(b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>이는 (save-resume) 게임 비유에는 잘 들어맞지 않는다. 저장본을 다시 시작할 때 게임 내에서 어떤 것(값)을 가져올 수 있는 게임을 나는 알지 못한다. 그러나 이 점은 코루틴을 사용하면 완벽하게 이해된다. 종종 우리는 API로부터 네트워크 response를 받는 것처럼 어떤 데이터를 받아오기 위해 대기하곤 한다. 흔한 시나리오다. 스레드는 특정 데이터가 있는 지점에 도달할 때가지 비즈니스 로직을 실행시킨다. 그래서 네트워크 라이브러리에 이를 전달할 것을 요구한다. 코루틴 없이, 이 스레드는 앉아서 기다릴 수밖에 없다. 스레드가 비싼 자원이기 때문에 이는 엄청난 낭비다. 특히 안드로이드의 메인스레드와 같이 중요한 스레드라면 더욱 그렇다. 코루틴을 사용하면 그냥 일시정지 시켰다가, 라이브러리에게 “이 데이터를 받자마자 resume 함수에게 그냥 넘겨”라는 명령과 함께 continuation을 넘기기만 하면 된다. 그러면 스레드는 다른 일을 하러 갈 수 있다. 데이터가 오면 바로 그 스레드는 코루틴이 일시정지한 지점부터 다시 시작할 것이다.</p>
<p>실제로 이를 확인하기 위해 데이터를 수신할 때까지 일시정지하는 방법을 살펴보자. 아래 예제에서는 외부에서 가져온 requestUser 콜백함수를 사용한다.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	println(<span class="string">&quot;Before&quot;</span>)</span><br><span class="line">	<span class="keyword">val</span> user = suspendCoroutine&lt;User&gt; &#123; cont -&gt;</span><br><span class="line">		requestUser &#123; user -&gt;</span><br><span class="line">			cont.resume(user)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	println(user)</span><br><span class="line">	println(<span class="string">&quot;After&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Before</span></span><br><span class="line"><span class="comment">// (1 second delay)</span></span><br><span class="line"><span class="comment">// User(name=Test)</span></span><br><span class="line"><span class="comment">// After</span></span><br></pre></td></tr></table></figure>

<p>suspendCoroutine을 직접 호출하는 것은 편리하지 않다. 대신 suspend 함수를 만드는 것을 선호한다. 그래서 이를 추출할 수도 있다.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">requestUser</span><span class="params">()</span></span>: User &#123;</span><br><span class="line">	<span class="keyword">return</span> suspendCoroutine&lt;User&gt; &#123; cont -&gt;</span><br><span class="line">		requestUser &#123; user -&gt;</span><br><span class="line">			cont.resume(user)</span><br><span class="line">			&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	println(<span class="string">&quot;Before&quot;</span>)</span><br><span class="line">	<span class="keyword">val</span> user = requestUser()</span><br><span class="line">	println(user)</span><br><span class="line">	println(<span class="string">&quot;After&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>현재 suspend 함수는 Retrofit이나 Room과 같은 많은 유명한 라이브러리에서 지원하고 있다. 그물게 suspend 함수 안에 콜백 함수를 쓸 때가 있다. 하지만 그런 경우라면 suspendCoroutine 때신suspendConcellableCoroutine을 사용하는 걸 추천한다. 이는 Cancellation 챕터에서 설명할 것이다.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">requestUser</span><span class="params">()</span></span>: User &#123;</span><br><span class="line">	<span class="keyword">return</span> suspendCancellableCoroutine&lt;User&gt; &#123; cont -&gt;</span><br><span class="line">		requestUser &#123; user -&gt;</span><br><span class="line">			cont.resume(user)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>여기서 API가 데이터가 아닌 다른 문제가 발생했을 때는 어떻게 될지 궁금할 수도 있다. 서비스가 죽거나 오류를 수신할까? 위 예제에서는 데이터를 반환하지 않는다. 대신 코루틴이 일시정지한 곳에서 예외가 발생해야 한다. 예외를 받고 다시 시작한다.</p>
<h3 id="예외를-받은-resume"><a href="#예외를-받은-resume" class="headerlink" title="예외를 받은 resume"></a><strong>예외를 받은 resume</strong></h3><p>우리가 호출하는 모든 함수는 어떤 값을 반환하거나 예외를 던진다. suspendCoroutine도 같다. resume이 호출되면 매개변수로 데이터를 넘긴다. resumeWithException이 호출되면 매개변수로 전달된 예외가 일시정지한 지점에 개념적으로 던져진다.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyException</span> : <span class="type">Throwable</span></span>(<span class="string">&quot;Just an exception&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		suspendCoroutine&lt;<span class="built_in">Unit</span>&gt; &#123; cont -&gt;</span><br><span class="line">			cont.resumeWithException(MyException())</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">catch</span> (e: MyException) &#123;</span><br><span class="line">		println(<span class="string">&quot;Caught!&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Caught!</span></span><br></pre></td></tr></table></figure>

<p>이 매커니즘은 다른 문제에서도 쓰인다. 한 예로, 네트워크 예외 신호를 보낼 때가 있다.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">requestUser</span><span class="params">()</span></span>: User &#123;</span><br><span class="line">	<span class="keyword">return</span> suspendCancellableCoroutine&lt;User&gt; &#123; cont -&gt;</span><br><span class="line">		requestUser &#123; resp -&gt;</span><br><span class="line">			<span class="keyword">if</span> (resp.isSuccessful) &#123;</span><br><span class="line">				cont.resume(resp.<span class="keyword">data</span>)</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">val</span> e = ApiException(</span><br><span class="line">					resp.code,</span><br><span class="line">					resp.message</span><br><span class="line">				)</span><br><span class="line">				cont.resumeWithException(e)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">requestNews</span><span class="params">()</span></span>: News &#123;</span><br><span class="line">	<span class="keyword">return</span> suspendCancellableCoroutine&lt;News&gt; &#123; cont -&gt;</span><br><span class="line">		requestNews(</span><br><span class="line">			onSuccess = &#123; news -&gt; cont.resume(news) &#125;,</span><br><span class="line">			onError = &#123; e -&gt; cont.resumeWithException(e) &#125;</span><br><span class="line">		)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="함수가-아닌-코루틴을-일시정지하는-것"><a href="#함수가-아닌-코루틴을-일시정지하는-것" class="headerlink" title="함수가 아닌 코루틴을 일시정지하는 것"></a><strong>함수가 아닌 코루틴을 일시정지하는 것</strong></h3><p>하나 강조할 것은 함수가 아닌 코루틴을 일시정지 시킨다는 것이다. 함수를 일시정지할 수 있는 것은 코루틴이 아니라 코루틴을 일시정지할 수 있는 함수이다. 어떤 변수에 함수를 저장하는 상상를 해보아라. 그리고 함수 호출 후 다시 시작시켜라.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 정말 이렇게 짜지 마세요</span></span><br><span class="line"><span class="keyword">var</span> continuation: Continuation&lt;<span class="built_in">Unit</span>&gt;? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">suspendAndSetContinuation</span><span class="params">()</span></span> &#123;</span><br><span class="line">	suspendCancellableCotouine&lt;<span class="built_in">Unit</span>&gt; &#123; cont -&gt;</span><br><span class="line">		continuation = cont</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	println(<span class="string">&quot;Before&quot;</span>)</span><br><span class="line">	</span><br><span class="line">	suspendAndSetContinuation()</span><br><span class="line">	continuation?.resume(<span class="built_in">Unit</span>)</span><br><span class="line">	</span><br><span class="line">	println(<span class="string">&quot;After&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Before</span></span><br></pre></td></tr></table></figure>

<p>이건 좀 이해가 안 된다. 이건 게임을 멈추고 이전 지점에서 재시작하는 프로세스와 동일한데도 resume이 전혀 호출되지 않는다. 출력결과에는 오직 “Before”만 보인다. 그리고 다른 스레드나 코루틴에서 resume을 호출하지 않으면 이 프로그램은 영원히 끝나지 않는다. 이를 위해 1초 후 reusme하는 다른 코루틴을 배치할 수도 있다.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 정말 이렇게 짜지 마세요. 잠재적인 메모리 누수의 원인이 됩니다.</span></span><br><span class="line"><span class="keyword">var</span> continuation: Continuation&lt;<span class="built_in">Unit</span>&gt;? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">suspendAndSetContinuation</span><span class="params">()</span></span> &#123;</span><br><span class="line">	suspendCancellableCotouine&lt;<span class="built_in">Unit</span>&gt; &#123; cont -&gt;</span><br><span class="line">		continuation = cont</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	println(<span class="string">&quot;Before&quot;</span>)</span><br><span class="line">	</span><br><span class="line">	launch &#123;</span><br><span class="line">	  delay(<span class="number">1000</span>)</span><br><span class="line">	  continuation?.resume(<span class="built_in">Unit</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	suspendAndSetContinuation()</span><br><span class="line">	println(<span class="string">&quot;After&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Before</span></span><br><span class="line"><span class="comment">// (1 second delay)</span></span><br><span class="line"><span class="comment">// After</span></span><br></pre></td></tr></table></figure>



<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-8868044834754772" crossorigin="anonymous"></script>
<p><ins class="adsbygoogle" style="display:block; text-align:center;" data-ad-layout="in-article" data-ad-format="fluid" data-ad-client="ca-pub-8868044834754772" data-ad-slot="1292114373"></ins></p>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>





</div></article></div><nav class="pagination" role="navigation" aria-label="pagination"><div class="pagination-previous"><a href="/">이전</a></div><div class="pagination-next"><a href="/page/3/">다음</a></div><ul class="pagination-list is-hidden-mobile"><li><a class="pagination-link" href="/">1</a></li><li><a class="pagination-link is-current" href="/page/2/">2</a></li><li><a class="pagination-link" href="/page/3/">3</a></li><li><span class="pagination-ellipsis">&hellip;</span></li><li><a class="pagination-link" href="/page/8/">8</a></li></ul></nav></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1 is-sticky"><!--!--><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/img/avatar.png" alt="LEEJS"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">LEEJS</p><p class="is-size-6 is-block">Android Dev.</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>South Korea</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">포스트</p><a href="/archives"><p class="title">38</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">카테고리</p><a href="/categories"><p class="title">7</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">태그</p><a href="/tags"><p class="title">0</p></a></div></div></nav><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="external nofollow noopener noreferrer" title="Github" href="https://github.com/dl137584"><i class="fab fa-github"></i></a></div></div></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">카테고리</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/ARTICLE/"><span class="level-start"><span class="level-item">/ARTICLE</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/BOOK/"><span class="level-start"><span class="level-item">/BOOK</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/Algorithm/"><span class="level-start"><span class="level-item">Algorithm</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Android/"><span class="level-start"><span class="level-item">Android</span></span><span class="level-end"><span class="level-item tag">24</span></span></a></li><li><a class="level is-mobile" href="/categories/Etc/"><span class="level-start"><span class="level-item">Etc</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/Kotlin/"><span class="level-start"><span class="level-item">Kotlin</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/Translation/"><span class="level-start"><span class="level-item">Translation</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li></ul></div></div></div><div class="card widget" data-type="adsense"><div class="card-content"><div class="menu"><h3 class="menu-label">광고</h3><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-8868044834754772" data-ad-slot="4130112855" data-ad-format="auto" data-full-width-responsive="true"></ins><script>(adsbygoogle = window.adsbygoogle || []).push({});</script></div></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.svg" alt="leejs&#039;s blog" height="28"></a><p class="is-size-7"><span>&copy; 2026 LEEJS</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="external nofollow noopener noreferrer">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="external nofollow noopener noreferrer">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="external nofollow noopener noreferrer" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="external nofollow noopener noreferrer" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="external nofollow noopener noreferrer" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("ko");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="맨 위로" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "이 웹 사이트는 귀하의 경험을 향상시키기 위해 Cookie를 사용합니다.",
          dismiss: "무시",
          allow: "허용",
          deny: "거부",
          link: "더 알아보기",
          policy: "Cookie 정책",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="입력 하세요..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"입력 하세요...","untitled":"(제목 없음)","posts":"포스트","pages":"페이지","categories":"카테고리","tags":"태그"});
        });</script></body></html>